<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Thanks for Bill</title>
    <url>/2017/05/02/Bill/</url>
    <content><![CDATA[<p>谁的青春不迷茫，我们都一样。<br>感谢<a href="http://blog.zhanghuiliang.cn/" target="_blank" rel="noopener">阿亮</a>在博客搭建中帮我解决的诸多问题。</p>
]]></content>
      <categories>
        <category>大千世界</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6常用语法总结</title>
    <url>/2019/02/27/ES6/</url>
    <content><![CDATA[<p><strong>前言</strong>: 本文中所有api及语法糖均是基于阮一峰老师的<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6标准入门(第三版)</a>做的汇总及扩展。<br><a id="more"></a></p>
<h3 id="let-和-const命令"><a href="#let-和-const命令" class="headerlink" title="let 和 const命令"></a>let 和 const命令</h3><h4 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h4><ul>
<li>描述: 新增let命令，用于声明变量，用法类似于var。但声明的变量只在let所在的代码块内有效。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	let a = 10;</span><br><span class="line">	var b = 20;</span><br><span class="line">&#125;</span><br><span class="line">a // Uncaught ReferenceError: a is not defined</span><br><span class="line">b // 20</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="不存在变量提升，不允许重复声明"><a href="#不存在变量提升，不允许重复声明" class="headerlink" title="不存在变量提升，不允许重复声明"></a>不存在变量提升，不允许重复声明</h5><ul>
<li><p>var 命令会发生变量提升，及变量在声明之前使用，值为undefined。let命令纠正了这种现象，let声明的变量一定要在声明之后使用，不然会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a) // ReferenceError: a is not defined</span><br><span class="line"></span><br><span class="line">console.log(b) // undefined </span><br><span class="line">var b = 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>不允许重复定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = &apos;123&apos;</span><br><span class="line">a // &apos;123&apos;</span><br><span class="line">let a = &apos;456&apos; // 报错 Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><ul>
<li><p>在es5中，只有函数作用域和全局作用域，全局作用域导致部分场景下的变量污染或变量覆盖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var tmp = &apos;hello world&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>es6增加了块级作用域及允许块级作用域的任意嵌套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  let n = 5;</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    let n = 10;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(n); // 5</span><br><span class="line"></span><br><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  let insane = &apos;Hello World&apos;;</span><br><span class="line">  &#123; </span><br><span class="line">    let insane = &apos;Hello Cinaiet&apos;</span><br><span class="line">    console.log(insane) // Hello Cinaiet</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(insane) // Hello World</span><br><span class="line">&#125;&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h4><ul>
<li><p>const 声明一个只读的变量，一旦声明，常量的值就不能改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PI = 3.1415;</span><br><span class="line">PI // 3.1415</span><br><span class="line"></span><br><span class="line">PI = 3; // TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>
</li>
<li><p>本质<br>const 实际并不是变量的值不可改，而是变量指向的内存地址所保存的数据不可更改。</p>
<h5 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h5></li>
<li>var </li>
<li>function</li>
<li>let  </li>
<li>const </li>
<li>import</li>
<li>class</li>
</ul>
<h3 id="变量的解构析构"><a href="#变量的解构析构" class="headerlink" title="变量的解构析构"></a>变量的解构析构</h3><h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><h5 id="允许按照一定的模式从数组或是对象中提取某个值，然后对变量进行赋值"><a href="#允许按照一定的模式从数组或是对象中提取某个值，然后对变量进行赋值" class="headerlink" title="允许按照一定的模式从数组或是对象中提取某个值，然后对变量进行赋值"></a>允许按照一定的模式从数组或是对象中提取某个值，然后对变量进行赋值</h5><p>以前，为变量赋值，只能直接指定值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">let c = 3;</span><br></pre></td></tr></table></figure></p>
<p>ES6 允许写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [a, b, c] = [1, 2, 3];</span><br><span class="line">let obj = &#123; d: &apos;d&apos;, e: &apos;e&apos;, f: &apos;f&apos;&#125;</span><br><span class="line">const &#123;</span><br><span class="line">	d, e, f</span><br><span class="line">&#125; = obj</span><br><span class="line">d // &apos;d&apos;</span><br></pre></td></tr></table></figure>
<h5 id="允许指定默认值，也可以解构赋值"><a href="#允许指定默认值，也可以解构赋值" class="headerlink" title="允许指定默认值，也可以解构赋值"></a>允许指定默认值，也可以解构赋值</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let [foo = true] = [] </span><br><span class="line">foo // true</span><br><span class="line">let [x, y = &apos;yyy&apos;] = [&apos;xxx&apos;]</span><br><span class="line">y // yyy</span><br><span class="line">x // xxx</span><br><span class="line"></span><br><span class="line">let &#123;foo, bar&#125; = &#123;foo: &apos;foo&apos;, bar: &apos;bar&apos;&#125;</span><br><span class="line">foo // foo</span><br></pre></td></tr></table></figure>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>传统上，Js只有indexOf 方法，用来确定一个字符串中是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let aaa = &apos;hello Cinaiet&apos;</span><br><span class="line">aaa.includes(&apos;hello&apos;) // true</span><br><span class="line">aaa.startsWith(&apos;hello&apos;) // true</span><br><span class="line">aaa.endsWith(&apos;Cinaiet&apos;) // true</span><br></pre></td></tr></table></figure>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;x&apos;.repeat(3) // &apos;xxx&apos;</span><br><span class="line">&apos;aaa&apos;.repeat(0) // &apos;&apos;</span><br></pre></td></tr></table></figure>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>相较于传统的模板字符串，使得模板更加简洁便利<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 传统模板</span><br><span class="line">$(&apos;#result&apos;).append(</span><br><span class="line">  &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; +</span><br><span class="line">  &apos;items in your basket, &apos; +</span><br><span class="line">  &apos;&lt;em&gt;&apos; + basket.onSale +</span><br><span class="line">  &apos;&lt;/em&gt; are on sale!&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// ES6模板字符串</span><br><span class="line">$(&apos;#result&apos;).append(`</span><br><span class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</span><br><span class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</span><br><span class="line">  are on sale!</span><br><span class="line">`);</span><br></pre></td></tr></table></figure></p>
<p>未完待续</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>平行宇宙</tag>
      </tags>
  </entry>
  <entry>
    <title>Handlebars使用中的一些工具集</title>
    <url>/2017/10/19/Handlebars%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
    <content><![CDATA[<ul>
<li>分离以逗号隔开的数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(&apos;splitDetailImg&apos;,function (value) &#123;</span><br><span class="line">        var splitvalue=value.split(&apos;,&apos;);</span><br><span class="line">        var reValues=[];</span><br><span class="line">        for ( var i=0; i&lt;splitvalue.length; i++ )&#123;</span><br><span class="line">            var reValue=&#123;&#125;;</span><br><span class="line">            reValue.name=splitvalue[i];</span><br><span class="line">            reValues[i]=reValue;</span><br><span class="line">        &#125;</span><br><span class="line">        return reValues;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>比较两个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//sym可以是&lt;,&gt;,=</span><br><span class="line">Handlebars.registerHelper(&apos;compare&apos;,function (first, sym, sec) &#123;</span><br><span class="line">    var r=first+sym+sec;</span><br><span class="line">    return eval(r);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据value返回不同的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//判断value的状态，渲染不同的数据</span><br><span class="line">  Handlebars.registerHelper(&apos;valueCompare&apos;, function(left, operator, right, options) &#123;</span><br><span class="line">      if (arguments.length &lt; 3) &#123;</span><br><span class="line">          throw new Error(&apos;Handlerbars Helper &quot;compare&quot; needs 2 parameters&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">      var operators = &#123;</span><br><span class="line">          &apos;==&apos;:     function(l, r) &#123;return l == r; &#125;,</span><br><span class="line">          &apos;===&apos;:    function(l, r) &#123;return l === r; &#125;,</span><br><span class="line">          &apos;!=&apos;:     function(l, r) &#123;return l != r; &#125;,</span><br><span class="line">          &apos;!==&apos;:    function(l, r) &#123;return l !== r; &#125;,</span><br><span class="line">          &apos;&lt;&apos;:      function(l, r) &#123;return l &lt; r; &#125;,</span><br><span class="line">          &apos;&gt;&apos;:      function(l, r) &#123;return l &gt; r; &#125;,</span><br><span class="line">          &apos;&lt;=&apos;:     function(l, r) &#123;return l &lt;= r; &#125;,</span><br><span class="line">          &apos;&gt;=&apos;:     function(l, r) &#123;return l &gt;= r; &#125;,</span><br><span class="line">          &apos;typeof&apos;: function(l, r) &#123;return typeof l == r;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      if (!operators[operator]) &#123;</span><br><span class="line">          throw new Error(&apos;Handlerbars Helper &quot;compare&quot; doesn\&apos;t know the operator &apos; + operator);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var result = operators[operator](left, right);</span><br><span class="line"></span><br><span class="line">      if (result) &#123;</span><br><span class="line">          return options.fn(this);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          return options.inverse(this);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据条件将数组分割成多个数组，用于分页等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Handlebars.registerHelper(&apos;cateList&apos;,function (value) &#123;</span><br><span class="line">    var valLen = value.length;</span><br><span class="line">    var pageLen = 8;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0; i &lt; valLen; i += pageLen)&#123;</span><br><span class="line">        result.push(value.slice(i,i+pageLen));</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>JSX的实现原理</title>
    <url>/2021/07/25/JSX%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>JSX是React框架背后的核心机理，它使得我们可以在Javaascript中直接书写html。</p>
<p>本文将由JSX展开实现一个简化版的simpleReact。</p>
<a id="more"></a>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm init -y // 初始化当前项目</span><br><span class="line">$ npm i webpack webpack -D // 打包配置</span><br></pre></td></tr></table></figure>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack 是一个前端打包工具，支持各种自定义loader，plugin。<br>使用方法详见 <a href="https://blog.wangguanwei.com/2020/03/14/webpack%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">webpack 基础用法</a></p>
<h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>babel 是一个将高版本的js，编译成老版本Js的一种工具。</p>
<p>babel在webpack中是以loader的形式存在的。<br>babel本身是一个不带任何配置的一个核心，<code>@babel/preset-env</code>是一个配置好了的、比较常见的（如es6 -&gt; es5）转换配置包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i @babel/core @babel/preset-env babel-loader -D</span><br></pre></td></tr></table></figure>
<h2 id="编写webpack-配置文件"><a href="#编写webpack-配置文件" class="headerlink" title="编写webpack 配置文件"></a>编写webpack 配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">module.exports =  &#123;</span><br><span class="line">  entry: &apos;./main.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.join(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: &apos;babel-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [&apos;@babel/preset-env&apos;],</span><br><span class="line">            </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="babel-plugin-transform-react-jsx"><a href="#babel-plugin-transform-react-jsx" class="headerlink" title="@babel/plugin-transform-react-jsx"></a>@babel/plugin-transform-react-jsx</h2><p>在常规的babel preset配置中是不包含JSX的转换的，所以需要借助单独的插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i @babel/plugin-transform-react-jsx -D</span><br></pre></td></tr></table></figure>
<p>修改webpack配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.conf.js</span><br><span class="line">// ...others</span><br><span class="line">options: &#123;</span><br><span class="line">            presets: [&apos;@babel/preset-env&apos;],</span><br><span class="line">            plugins: [</span><br><span class="line">              &quot;@babel/plugin-transform-react-jsx&quot;,</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<h2 id="书写"><a href="#书写" class="headerlink" title="书写"></a>书写</h2><p>当在js中书写jsx语法，使用webpack打包之后的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// main.js</span><br><span class="line"></span><br><span class="line">let x = &lt;div /&gt;</span><br><span class="line"></span><br><span class="line">// build.js 打包之后的js</span><br><span class="line"></span><br><span class="line">var x = /*#__PURE__*/React.createElement(&quot;div&quot;, null);</span><br><span class="line"></span><br><span class="line">// 浏览器解析js报错</span><br><span class="line"></span><br><span class="line">// Uncaught ReferenceError: React is not defined</span><br></pre></td></tr></table></figure>
<p>这是由于babel-jsx翻译之后生成的js为<code>React.createElement(ele)</code>函数，而<code>React.createElement</code><br>在当前是一个未定义的状态。</p>
<h3 id="babel-plugin-transform-react-jsx-扩展"><a href="#babel-plugin-transform-react-jsx-扩展" class="headerlink" title="@babel/plugin-transform-react-jsx 扩展"></a>@babel/plugin-transform-react-jsx 扩展</h3><p><code>@babel/plugin-transform-react-jsx</code> 支持传入的第二个参数为当前的函数名，如<code>React.createElement</code>。</p>
<p>修改webpack.conf.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">              [</span><br><span class="line">                &quot;@babel/plugin-transform-react-jsx&quot;,</span><br><span class="line">                &#123;</span><br><span class="line">                  pragma: &quot;wgwCreateElement&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            ]</span><br></pre></td></tr></table></figure>
<p>再使用webpack打包jsx转换之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = wgwCreateElement(&quot;div&quot;, null);</span><br></pre></td></tr></table></figure>
<p>即函数名变为了自定义的函数名。</p>
<h3 id="编写自定义函数"><a href="#编写自定义函数" class="headerlink" title="编写自定义函数"></a>编写自定义函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.a = &lt;div class=&quot;class&quot; id=&quot;id&quot; &gt;</span><br><span class="line">  &lt;div&gt;123&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 打包之后的window.a </span><br><span class="line"></span><br><span class="line">window.a= wgwCreateElement(&quot;div&quot;, &#123;</span><br><span class="line">  &quot;class&quot;: &quot;class&quot;,</span><br><span class="line">  id: &quot;id&quot;</span><br><span class="line">&#125;, wgwCreateElement(&quot;div&quot;, null, &quot;123&quot;), wgwCreateElement(&quot;div&quot;, null), wgwCreateElement(&quot;div&quot;, null));</span><br><span class="line"></span><br><span class="line">// 由此可得</span><br><span class="line">function wgwCreateElement(tagName, attributes, ...childrens) &#123;</span><br><span class="line">  let ele = document.createElement(tagName)</span><br><span class="line">  for(let attr in attributes) &#123;</span><br><span class="line">    ele.setAttribute(attr, attributes[attr])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for(let child of childrens) &#123;</span><br><span class="line">    if(typeof child === &apos;string&apos;) &#123;</span><br><span class="line">      child = document.createTextNode(child)</span><br><span class="line">    &#125;</span><br><span class="line">    ele.appendChild(child)</span><br><span class="line">  &#125;</span><br><span class="line">  return ele</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JSX组件机制"><a href="#JSX组件机制" class="headerlink" title="JSX组件机制"></a>JSX组件机制</h2><p>在jsx中，如果tagName 为小写，那么就会认为是一个原生的html标签，如果是大写开头，那么就会认为是一个组件。</p>
<p>如改写main.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.a = &lt;MyComponent class=&quot;class&quot; id=&quot;id&quot; &gt;</span><br><span class="line">  &lt;div&gt;123&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/MyComponent&gt;</span><br><span class="line"></span><br><span class="line">// 打包翻译转换后</span><br><span class="line">wgwCreateElement(MyComponent, &#123;</span><br><span class="line">  &quot;class&quot;: &quot;class&quot;,</span><br><span class="line">  id: &quot;id&quot;</span><br><span class="line">&#125;, wgwCreateElement(&quot;div&quot;, null, &quot;123&quot;), wgwCreateElement(&quot;div&quot;, null), wgwCreateElement(&quot;div&quot;, null));</span><br><span class="line">// 此时MyComponent处于未定义状态</span><br></pre></td></tr></table></figure>
<h3 id="编写MyComponent"><a href="#编写MyComponent" class="headerlink" title="编写MyComponent"></a>编写MyComponent</h3><p>代码不想赘述了，详见 github <a href="https://github.com/Cinaiet/toy-react/blob/two/main.js" target="_blank" rel="noopener">main.js</a><br><a href="https://github.com/Cinaiet/toy-react/blob/two/toy-react.js" target="_blank" rel="noopener">toy-react.js</a></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="jsx编译方式"><a href="#jsx编译方式" class="headerlink" title="jsx编译方式"></a>jsx编译方式</h3><h4 id="运行时编译（React-Automatic-Runtime）"><a href="#运行时编译（React-Automatic-Runtime）" class="headerlink" title="运行时编译（React Automatic Runtime）"></a>运行时编译（React Automatic Runtime）</h4><p>当pagram参数值为wgwCreateElement，所以代码编译时会自动解析jsx并调用wgwCreateElement方法。所以定义了pagram之后函数不需要去调用</p>
<h4 id="手动引入-（React-Classic-Runtime）"><a href="#手动引入-（React-Classic-Runtime）" class="headerlink" title="手动引入 （React Classic Runtime）"></a>手动引入 （React Classic Runtime）</h4><p><strong>为什么render方法里父节点要接收一个component.root作为参数而不是component？</strong></p>
<p>在运行编jsx译时，调用wgwCreateElement方法后会实例化一个Component对象，该对象初始root为null，从而会调用render方法（即MyComponent中的render方法），该方法返回一个JSX，从而又会调用createElement方法，此时是一个真实的DOM节点，所以会初始化一个ElementWrapper对象，该对象包含一个root属性，这时root就不为null了，而是一个div。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>核心原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Js浮点型运算bug及toFixed</title>
    <url>/2019/04/25/Js%E6%B5%AE%E7%82%B9%E5%9E%8B%E8%BF%90%E7%AE%97bug%E5%8F%8AtoFixed/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>上周上线的一个关于基金类的任务，有一个地方需要对浮点型的数据进行计算转换，漏判了一种情况以及对toFixed的滥用，直接导致线上页面无法正常加载，差点祭天… </p>
<a id="more"></a>
<hr>
<h4 id="问题复述"><a href="#问题复述" class="headerlink" title="问题复述"></a>问题复述</h4><p>服务端返回一个字段a: 0.3456 ，前端要展示a转化成百分比的值 以及 (1 - a) 的百分值，均保留一位小数。</p>
<ul>
<li>行吧，简单。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = 0.3456</span><br><span class="line">let b = (a * 100).toFixed(1)  // &quot;34.6&quot;</span><br><span class="line">let c = 100 - b // 65.4</span><br></pre></td></tr></table></figure>
<ul>
<li>搞定。</li>
<li>第一轮测试中期，测试指着某条数据问我，不是保留一位小数莫，这是怎么回事。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = 0.6923</span><br><span class="line">let b = (a * 100).toFixed(1) // 69.2</span><br><span class="line">let c = 100 - b // 30.799999999999997</span><br></pre></td></tr></table></figure>
<ul>
<li>这是因为js浮点型运算有一个bug，众所周知 js 0.3 - 0.1 ≠ 0.2 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subNumber = val =&gt; &#123;  // 解决小数运算bug</span><br><span class="line">    let float1 = val.toString().split(&apos;.&apos;)[1]</span><br><span class="line">    let valLen = float1.length ? float1.length : 0</span><br><span class="line">    let len = Math.pow(10, valLen)</span><br><span class="line">    return (Math.ceil(val * len) / len).toFixed(1)</span><br><span class="line">  &#125;</span><br><span class="line">let a = 0.5923</span><br><span class="line">let b = (a * 100).toFixed(1) // 59.2</span><br><span class="line">let c = subNumber(100 -b) // 40.8</span><br></pre></td></tr></table></figure>
<ul>
<li>连续通过了三轮测试，到了生产，出问题了。</li>
<li><p>当a的第三位小数为0 且第四位小数小于5时，按如上方法运行的话，b就是一个没有小数的函数，函数第一行 split(‘.’)[1] 是一个undefined，取undefined的length就会报错，天了噜，上线无bug,自挂东南枝。</p>
</li>
<li><p>直接再对c toFixed不就解决了问题莫。但忽略了一个致命的问题，toFixed 是对数值进行四舍五入，前言也说了，这是基金类型的项目，一个百分位可能影响到很多的钱。</p>
</li>
<li><p>解决办法的代码就不贴了，思路以及方向已经很清楚了。</p>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>少用toFixed,能不用就不用。</li>
<li>对数组或者字符串的边界值进行判空或做特殊处理的时候需要谨慎。</li>
<li>少壮不努力，自挂东南枝。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>Js构造对象的过程</title>
    <url>/2021/07/12/Js%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>早在JavaScript 1.0 时代，JavaScript是没有继承的。</p>
<a id="more"></a>
<h2 id="基于对象的-JavaScript"><a href="#基于对象的-JavaScript" class="headerlink" title="基于对象的 JavaScript"></a>基于对象的 JavaScript</h2><h3 id="1-0-如何实现面向对象的（类抄写）"><a href="#1-0-如何实现面向对象的（类抄写）" class="headerlink" title="1.0 如何实现面向对象的（类抄写）"></a>1.0 如何实现面向对象的（类抄写）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Car() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &quot;Car&quot;;</span><br><span class="line"></span><br><span class="line">  this.color = &quot;Red&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = new Car();</span><br></pre></td></tr></table></figure>
<p>在JavaScript 1.0中，将函数作为<strong>构造器</strong>，并且在函数中向它的实例（也就是this对象）抄写类声明的属性。</p>
<p>在当时的面向对象理论里面，就已经可以称这个函数为<strong>类</strong>，而这个被创建出来的实例为<strong>对象</strong>了。</p>
<p>所以，有了类、对象，以及一个约定的构造过程，有了这三个东西，JavaScript 就声称了自己是一门“面向对象”的语言，并且还是一门”有类语言”。</p>
<p>所谓“类抄写”，就是将类所拥有的属性声明一项一项地抄写到对象上面，而这个对象，也就是我们现在大家都知道的 this 引用。</p>
<h2 id="类与构造器"><a href="#类与构造器" class="headerlink" title="类与构造器"></a>类与构造器</h2><p>由于在这样的构造过程中，this是作为new运算所构造出来的那个实例来使用的，因此 JavaScript 1.0 约定全局环境中不能使用this的。因为全局环境与new运算无关，全局环境中也并不存在一个被new创建出来的实例。</p>
<p>而随着JavaScript 1.1的到来，JavaScript 支持“原型继承”了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Device() &#123;</span><br><span class="line"></span><br><span class="line">  this.id = 0; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Car() &#123;</span><br><span class="line"></span><br><span class="line">  this.name = &quot;Car&quot;;</span><br><span class="line"></span><br><span class="line">  this.color = &quot;Red&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype = new Device();</span><br><span class="line"></span><br><span class="line">var x = new Car();</span><br><span class="line"></span><br><span class="line">console.log(x.id);</span><br></pre></td></tr></table></figure>
<p>在这个例子中所创建出来的对象x是“Car()”的一个实例，但是在面向对象编程（OOP）中，x既是Car()的子类实例，也是“Device()”的子类实例，这是 OOP 的继承性所约定的基本概念。这正是这门语言很有趣的地方：<strong>一方面使用了类继承的基础结构和概念，另一方面又要实现原型继承和基于原型链检查的逻辑。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  `x`是`Device()`的子类实例吗？</span><br><span class="line">x instanceof Device</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 因为</span><br><span class="line"></span><br><span class="line">x.[[Prototype]] === Car.prototype</span><br><span class="line"></span><br><span class="line">// 且</span><br><span class="line"></span><br><span class="line">Car.prototype = new Device()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 所以</span><br><span class="line"></span><br><span class="line">x.[[Prototype]].[[Prototype]] === Device.prototype</span><br></pre></td></tr></table></figure>
<h2 id="ECMAScript-6-之后的类"><a href="#ECMAScript-6-之后的类" class="headerlink" title="ECMAScript 6 之后的类"></a>ECMAScript 6 之后的类</h2><p>在 ECMAScript 6 之前，JavaScript 中的函数、类和构造器这三个概念是混用的。一般来说，它们都被统一为“函数 Car()”这个基础概念，而当它用作“x = new Car()”这样的运算，或从x.constructor这样的属性中读取时，它被理解为构造器；当它用作“x instanceof Car”这样的运算，或者讨论 OOP 的继承关系时，它被理解为类。</p>
<p>从 ECMAScript 6 开始，JavaScript 有了使用class来声明“类”的语法。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AClass &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自此之后，JavaScript 的“类”与“函数”有了明确的区别：类只能用 new 运算来创建，而不能使用“()”来做函数调用。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AClass &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new AClass() // AClass &#123;&#125;</span><br><span class="line"></span><br><span class="line">AClass() // TypeError: Class constructor AClass cannot be invoked without &apos;new&apos;</span><br></pre></td></tr></table></figure>
<p>在 ECMAScript 6 之后，JavaScript 内部是明确区分方法与函数的：不能对方法做 new 运算。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 声明一个带有方法的对象字面量</span><br><span class="line">obj = &#123; foo() &#123;&#125; &#125;</span><br><span class="line">// &#123; foo: [Function: foo] &#125;</span><br><span class="line"></span><br><span class="line">// 对方法使用new运算会导致异常</span><br><span class="line"> new obj.foo()</span><br><span class="line"></span><br><span class="line">// TypeError: obj.foo is not a constructor</span><br></pre></td></tr></table></figure>
<p>在 ECMAScript 6 之后，函数可以简单地分为三个大类：</p>
<ol>
<li>类：只可以做 new 运算；</li>
<li>方法：只可以做调用“( )”运算；</li>
<li>一般函数：（除部分函数有特殊限制外，）同时可以做 new 和调用运算。</li>
</ol>
<p>其中，典型的“方法”在内部声明时，有三个主要特征：</p>
<ol>
<li>具有一个名为“主对象[[HomeObject]]”的内部槽；</li>
<li>没有名为“构造器[[Construct]]”的内部槽；</li>
<li>没有名为“prototype”的属性。</li>
</ol>
<h2 id="创建this的顺序问题"><a href="#创建this的顺序问题" class="headerlink" title="创建this的顺序问题"></a>创建this的顺序问题</h2><p>如果对 ECMAScript 6 之前的构造器函数（例如f）使用new运算，那么这个 new 运算会使用f.prototype作为原型来创建一个this对象，然后才是调用f()函数，并将这个函数的执行过程理解为“类抄写（向用户实例抄写类所声明的属性）”。从用户代码的视角上来看，这个新对象就是由当前new运算所操作的那个函数f()创建的。</p>
<p>这在语义上非常简洁明了：由于f()是 this 的类，因此f.prototype决定了 this 的原型，而f()执行过程决定了初始化 this 实例的方式。但是它带了一个问题：从 JavaScript 1.1 开始至今都困扰 JavaScript 程序员的问题：</p>
<p><strong><span>无法创建一个有特殊性质的对象，也无法声明一个具有这类特殊性质的类。</span></strong></p>
<p>这是什么意思呢？比如说，所有的函数有一个公共的父类 / 祖先类，称为Function()。所以你可以用new Function()来创建一个普通函数，这个普通函数也是可以调用的，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; f = new Function;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; f instanceof Function</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; f()</span><br><span class="line"></span><br><span class="line">undefine</span><br></pre></td></tr></table></figure>
<p>你也确实可以用传统方法写一个Function()的子类，但这样的子类创建的实例就不能调用。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; MyFunction = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; MyFunction.prototype = new Function;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; f = new MyFunction;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; [f instanceof MyFunction, f instanceof Functcion]</span><br><span class="line"></span><br><span class="line">[ true, true ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; f()</span><br><span class="line"></span><br><span class="line">TypeError: f is not a func</span><br></pre></td></tr></table></figure>
<p>至于原因: JavaScript 所谓的函数，其实是“一个有[[Call]]内部槽的对象”。而Function()作为 JavaScript 原生的函数构造器，它能够在创建的对象（例如this）中添加这个内部槽，而当使用上面的继承逻辑时，用户代码（例如MyFunction()）就只是创建了一个普通的对象，因为用户代码没有能力操作 JavaScript 引擎层面才支持的那些“内部槽”。</p>
<p>所以到了ECMAScript 6，它的“类声明”采用了不同的构造逻辑。ECMAScript 6 要求所有子类的构造过程都不得创建这个this实例，并主动的把这个创建的权力“交还”给父类、乃至祖先类。这也就是 ECMAScript 6 中类的两个著名特性的由来，即，如果类声明中通过 extends 指定了父类，那么：</p>
<p>必须在构造器方法（constructor）中显式地使用super()来调用父类的构造过程；</p>
<p>在上述调用结束之前，是不能使用this引用的。</p>
<p><strong>ECMAScript 6 的类是由父类或祖先类创建this实例的。</strong></p>
<p>如果类声明class中不带有extends子句，因为它无法找到一个显式指示的父类，那么它所创建出来的类与传统 JavaScript 的函数 / 构造器是一样的，也就是由自己来创建this对象。</p>
<p><strong>文章出自 <a href="https://time.geekbang.org/column/intro/100039701" target="_blank" rel="noopener">周爱民老师的JavaScript核心原理解析</a> 侵权请联系删除。</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>核心原理</tag>
      </tags>
  </entry>
  <entry>
    <title>delete, JavaScript中有什么是可以销毁的</title>
    <url>/2020/06/11/delete-JavaScript%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E4%BB%A5%E9%94%80%E6%AF%81%E7%9A%84/</url>
    <content><![CDATA[<p>在了解delete之前，先说下JavaScript的数据类型的分类。<br><a id="more"></a></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>JavaScript中强行定义了Object和Function 就是引用类型。<br>及对象和函数，按照引用来传递和使用。</p>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>绝大多数情况下，按数据的传递和使用来解释起来是行得通的。但是到了 delete 运算这里，就不行。</p>
<p>按照引用定义，delete 0 就是删除一个值，而delete x 就是删除一个值或者删除一个引用。</p>
<p>delete 运算的表面意思，是该运算试图销毁某种东西。而delete 0 中的 0 是一个具体的字面量的值，字面量的值是不能销毁的，所以JavaScript认为“所有删除值的 delete 就直接返回 true”</p>
<p><em>delete 这个操作的正式语法设计并不是“删除某个东西”，而是“删除一个表达式的结果”</em></p>
<p>所以，现在这里的 0，其实不是值（Value）类型的数据，而是一个表达式运算的结果（Result）。而在进一步的删除操作之前，JavaScript 需要检测这个 Result 的类型：</p>
<ul>
<li>如果它是值，则按照传统的 JavaScript 的约定返回 true；</li>
<li>如果它是一个引用，那么对该引用进行分析，以决定如何操作。</li>
</ul>
<p>这个检测过程说明，ECMAScript 约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用。</p>
<h3 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h3><p>GetValue()是从一个引用中取出值来的行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x  = x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有赋值操作的含义，是将右边的“值”，赋给左边用于包含该值的“引用”。<br>那么上面的x = x 可翻译为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = GetValue(x)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>所以x = x的语义并不是“x 赋给 x”，而是“把值 x 赋给引用 x”。</p>
<p>所以，“delete x”归根到底，是在删除一个表达式的、引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>delete 运算符尝试删除值数据时，会返回 true，用于表示没有错误（Error）。</li>
<li>delete 0 的本质是删除一个表达式的值（Result）。</li>
<li>delete x 与上述的区别只在于 Result 是一个引用（Reference）。</li>
<li>delete 其实只能删除一种引用，即对象的成员（Property）</li>
</ul>
<h2 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h2><h3 id="delete-undefined"><a href="#delete-undefined" class="headerlink" title="delete undefined"></a>delete undefined</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete undefined // false</span><br></pre></td></tr></table></figure>
<p>在早起的JavaScript中，undefined是一个特殊的值，是在运行期间，通过void运算，或者不返回值的函数又或者一个声明了但未赋值的变量，等等类似这样的情况来“计算得到”的。所以在JavaScript早期的版本中，是无法判断x === undefined 这样的代码的，只能判断 typeof  x === undefined 这样的代码。<br>后来，将undefined 声明为一个全局属性。</p>
<p>所以由于undefined是全局属性，所以<code>delete undefined</code>其实就是<code>delete global.undefined</code>，是删除引用，而不是删除值。而这个属性是只读的，所以就返回false了。</p>
<h3 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h3><p>访问不存在的变量时，会报<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ x</span><br><span class="line">Uncaught ReferenceError: x is not defined</span><br></pre></td></tr></table></figure></p>
<p>之所以报错是因为对x的表达式的result进行了getValue()操作。而 typeof x 不报错，是因为没有求值。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>核心原理</tag>
      </tags>
  </entry>
  <entry>
    <title>css规则</title>
    <url>/2020/06/19/css%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>CSS 的顶层样式表由两种规则组成的规则列表构成，一种被称为 at-rule，也就是 at 规则，另一种是 qualified rule，也就是普通规则。</p>
<a id="more"></a>
<h3 id="at-rule"><a href="#at-rule" class="headerlink" title="at-rule"></a>at-rule</h3><p>at-rule 由一个 @ 关键字和后续的一个区块组成，如果没有区块，则以分号结束。</p>
<h4 id="charset"><a href="#charset" class="headerlink" title="@charset"></a>@charset</h4><p>@charset 用于提示 CSS 文件使用的字符编码方式，它如果被使用，必须出现在最前面。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@charset &quot;utf-8&quot;;</span><br></pre></td></tr></table></figure></p>
<h4 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h4><p>@import 用于引入一个 CSS 文件，除了 @charset 规则不会被引入，@import 可以引入另一个文件的全部内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;mystyle.css&quot;;</span><br><span class="line">@import url(&quot;mystyle.css&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h4><p>media 就是大名鼎鼎的 media query 使用的规则了，它能够对设备的类型进行一些判断。在 media 的区块内，是普通规则列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media print &#123;</span><br><span class="line">    body &#123; font-size: 10pt &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="page"><a href="#page" class="headerlink" title="@page"></a>@page</h4><p>page 用于分页媒体访问网页时(如打印)的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@page &#123;</span><br><span class="line">  size: 8.5in 11in;</span><br><span class="line">  margin: 10%;</span><br><span class="line">  @top-left &#123;</span><br><span class="line">    content: &quot;Hamlet&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  @top-right &#123;</span><br><span class="line">    content: &quot;Page &quot; counter(page);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="counter-style"><a href="#counter-style" class="headerlink" title="@ counter-style"></a>@ counter-style</h4><p>counter-style 产生一种数据，用于定义列表项的表现。如可以自定义counter的样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@counter-style triangle &#123;</span><br><span class="line">  system: cyclic;</span><br><span class="line">  symbols: ‣;</span><br><span class="line">  suffix: &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="key-frames"><a href="#key-frames" class="headerlink" title="@ key-frames"></a>@ key-frames</h4><p>keyframes 产生一种数据，用于定义动画关键帧。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes diagonal-slide &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    left: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  to &#123;</span><br><span class="line">    left: 100px;</span><br><span class="line">    top: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="fontface"><a href="#fontface" class="headerlink" title="@ fontface"></a>@ fontface</h4><p>fontface 用于定义一种字体，icon font 技术就是利用这个特性来实现的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">  font-family: Gentium;</span><br><span class="line">  src: url(http://example.com/fonts/Gentium.woff);</span><br><span class="line">&#125;</span><br><span class="line">p &#123; font-family: Gentium, serif; &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="support"><a href="#support" class="headerlink" title="@ support"></a>@ support</h4><p>support 检查环境的特性，它与 media 比较类似。</p>
<h4 id="namespace"><a href="#namespace" class="headerlink" title="@ namespace"></a>@ namespace</h4><p>用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。</p>
<h4 id="viewport"><a href="#viewport" class="headerlink" title="@ viewport"></a>@ viewport</h4><p>用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 HTML 的 meta 代替。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>@color-profile 是 SVG1.0 引入的 CSS 特性，但是实现状况不怎么好。</li>
<li>@document 还没讨论清楚，被推迟到了 CSS4 中。</li>
<li>@font-feature-values 。</li>
</ul>
<h3 id="普通规则"><a href="#普通规则" class="headerlink" title="普通规则"></a>普通规则</h3><p>普通规则主要是由选择器和声明区块构成。声明区块又由属性和值构成。</p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>任何选择器，都是由几个符号结构连接的：空格、大于号、加号、波浪线、双竖线，这里需要注意一下，空格，即为后代选择器的优先级较低。</p>
<h4 id="声明：属性和值"><a href="#声明：属性和值" class="headerlink" title="声明：属性和值"></a>声明：属性和值</h4><p>声明部分是一个由“属性: 值”组成的序列。</p>
<p><strong>属性</strong>是由中划线、下划线、字母等组成的标识符，CSS 还支持使用反斜杠转义。我们需要注意的是：属性不允许使用连续的两个中划线开头，这样的属性会被认为是 CSS 变量。</p>
<p><strong>值</strong>的部分，根据每个 CSS 属性可以取到不同的值，这里的值可能是字符串、标识符</p>
<p>CSS 属性值可能是以下类型。</p>
<ul>
<li>CSS 范围的关键字：initial，unset，inherit，任何属性都可以的关键字。</li>
<li>字符串：比如 content 属性。</li>
<li>URL：使用 url() 函数的 URL 值。</li>
<li>整数 / 实数：比如 flex 属性。</li>
<li>维度：单位的整数 / 实数，比如 width 属性。</li>
<li>百分比：大部分维度都支持。</li>
<li>颜色：比如 background-color 属性。</li>
<li>图片：比如 background-image 属性。</li>
<li>2D 位置：比如 background-position 属性。</li>
<li>函数：来自函数的值，比如 transform 属性。</li>
</ul>
<p>CSS 支持的特定计算型函数：</p>
<ul>
<li><p>calc()  支持加减乘除四则运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">section &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  margin: 1em; border: solid 1px;</span><br><span class="line">  width: calc(100%/3 - 2*1em - 2*1px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>max()  取两数中较大的一个</p>
</li>
<li>min() 取两数中较小的一个</li>
<li>clamp()  给一个值限定一个范围，超出范围外则使用范围的最大或者最小值。</li>
<li><p>toggle()  在规则选中多于一个元素时生效，它会在几个值之间来回切换，比如我们要让一个列表项的样式圆点和方点间隔出现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ul &#123; list-style-type: toggle(circle, square); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>attr()  允许 CSS 接受属性值的控制。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>如果当时</tag>
      </tags>
  </entry>
  <entry>
    <title>export default function() {} </title>
    <url>/2020/06/14/export-default-function/</url>
    <content><![CDATA[<p>无法导出一个匿名函数表达式</p>
<a id="more"></a>
<p>export 是在ES6中出现的一个模块技术。由于当前使用较多的是 Node.js 环境带有自己内置的模块加载技术，所以ES6 模块需要通过特定的命令行参数才能开启，因此它的应用一直以来也就不够广泛。</p>
<p>导致这种现象的根本原因在于 ECMAScript 6 模块是静态装配的，而传统的 Node.js 模块却是动态加载的。因而两种模块的实现效果与处理逻辑都大相径庭，Node.js 无法在短期内提供有效的手段帮助开发者将既有代码迁移到新的模块规范下。</p>
<h3 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h3><p>严格意义上讲，JavaScript 只有变量和常量两种标识符，六条声明语句中：</p>
<ul>
<li>let x = …</li>
<li>const x = …</li>
<li>var x = …</li>
<li>class x = …</li>
<li>function x= …</li>
<li>import x = …</li>
</ul>
<p>除了这六个语句之外，还有两个语句有潜在的声明标识符的能力，不过它们并不是严格意义上的声明语句（声明只是它们的语法效果）：</p>
<ul>
<li>try … catch(err …)</li>
<li>for (var i = …)</li>
</ul>
<h3 id="导出的内容"><a href="#导出的内容" class="headerlink" title="导出的内容"></a>导出的内容</h3><p>在本质上，export只能导出上述声明的六条声明语法声明的标识符，并且在导出时将他们统一称为”名字”</p>
<p>在语言设计中，所谓“标识符”与“名字”是有语义差别的，export 将之称为名字，就意味着这是一个标识符的子集。类似的其它子集也是存在的，例如“保留字是标识符名，但不能用作标识符。</p>
<p>在 JavaScript 语言的设计上，除了那些预设的标点符号（例如大括号、运算符之类），以及部分的保留字和关键字之外，事实上用户代码可以书写的只有三种东西。</p>
<ol>
<li>标识符：（通常是）一个名字</li>
<li>字面量： 表明由它的字面含义所决定的一个值</li>
<li>模板：一个可计算结果的字符串值</li>
</ol>
<p>所以，如果在这个层面上解构一份你所书写的 JavaScript 代码，那么你所能书写 / 声明的，就一定只有“名字和值”。</p>
<h3 id="解析-export"><a href="#解析-export" class="headerlink" title="解析 export"></a>解析 export</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 导出“（声明的）名字”</span><br><span class="line">export &lt;let/const/var&gt; x ...;</span><br><span class="line">export function x() ...</span><br><span class="line">export class x ...</span><br><span class="line">export &#123;x, y, z, ...&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 导出“（重命名的）名字”</span><br><span class="line">export &#123; x as y, ...&#125;;</span><br><span class="line">export &#123; x as default, ... &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 导出“（其它模块的）名字”</span><br><span class="line">export ... from ...;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 导出“值”</span><br><span class="line">export default &lt;expression</span><br></pre></td></tr></table></figure>
<p>关于导出声明的、重命名的和其它模块的名字这三种情况，其实都比较容易理解，就是形成一个名字表，让外部模块能够查看就可以了。</p>
<p>但是对于最后这种形式，也就是“（导出）值”的形式，事实上是非常特殊的。要导出一个模块的全部内容就必须导出“（全部的）名字和值”，然而纯粹的值没有名字，于是也就没法访问了，所以这就与“导出点什么东西”的概念矛盾了。</p>
<blockquote>
<p>export default </p>
</blockquote>
<h3 id="导出语句的处理逻辑"><a href="#导出语句的处理逻辑" class="headerlink" title="导出语句的处理逻辑"></a>导出语句的处理逻辑</h3><h4 id="export-如何导出名字"><a href="#export-如何导出名字" class="headerlink" title="export 如何导出名字?"></a>export 如何导出名字?</h4><p>如果只是导出一个名字，那么它其实在“某个名字表”中做一个登记项就可以了。并且 JavaScript 中也的确是这样处理的。但是实际到使用的时候，这个名字还是要绑定一个具体的值才是可以使用的。因此，一个 export 也必须理解为这样两个步骤：<br>1.导出一个名字</p>
<ol start="2">
<li>为上述名字绑定一个值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export var x = 100;</span><br></pre></td></tr></table></figure>
<ol>
<li>（与 export 类似）按照语法在当前模块中声明名字，例如上面的x；</li>
<li>添加一个当前模块对目标模块的依赖项。</li>
</ol>
<p>有了上述的第二步操作，JavaScript 就可以依据所有它能在静态文本中发现的import语句来形成模块依赖树，最后就可以找到这个模块依赖树最顶端的根模块，并尝试加载之。</p>
<p>所以关键的是，在“模块 export/import”语法中 ，JavaScript 是依赖 import 来形成依赖树的，与 export 无关。但是直到目前为止（我的意思是直到找到所有导入和导出的名字，并完成所有模块的装配的现在为止），没有任何一行用户的 JavaScript 代码是被执行过的。</p>
<h4 id="JavaScript-的装配过程"><a href="#JavaScript-的装配过程" class="headerlink" title="JavaScript 的装配过程"></a>JavaScript 的装配过程</h4><ul>
<li>找到并遍历模块依赖树的所有模块（这个树是排序的），然后</li>
<li>执行这些模块最顶层的代码</li>
</ul>
<p>所谓模块的装配过程，就是执行一次顶层代码而已。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">export default function() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>它并不是导出了一个匿名函数表达式，而是导出了一个匿名函数定义（Anonymous  Function  Definition）。</p>
<p>因此，该匿名函数初始化时才会绑定给它左侧的名字“default”，这会导致import f from …之后访问f.name值会得到“default”这个名字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  &quot;default&quot;: function() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj.default.name); // &quot;default&quot;</span><br></pre></td></tr></table></figure>
<h3 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h3><ol>
<li>export …语句通常是按它的词法声明来创建的标识符的，例如export var x = …就意味着在当前模块环境中创建的是一个变量，并可以修改等等。但是当它被导入时，在import语句所在的模块中却是一个常量，因此总是不可写的。</li>
<li>由于export default …没有显式地约定名字“default（或default）”应该按let/const/var的哪一种来创建，因此 JavaScript 缺省将它创建成一个普通的变量（var），但即使是在当前模块环境中，它事实上也是不可写的，因为你无法访问一个命名为“default”的变量——它不是一个合法的标识符。</li>
<li><p>所谓匿名函数，仅仅是当它直接作为操作数（而不是具有上述“匿名函数定义”的语法结构）时，才是真正匿名的，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log((function()&#123;&#125;).name);  // &quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于类表达式（包括匿名类表达式）在本质上就是函数，因此它作为 default 导出时的性质与上面所讨论的是一致的。</p>
</li>
<li>导出项（的名字）总是作为词法声明被声明在当前模块作用域中的，这意味着它不可删除，且不可重复导出。亦即是说即使是用var x…来声明，这个x也是在 <em>lexicalNames</em> 中，而不是在 <em>varNames</em> 中。</li>
<li>没有模块会导出（传统意义上的）main()，因为 ECMAScript 为了维护模块的静态语义，而把执行过程及其入口的定义丢回给了引擎或宿主本身。</li>
</ol>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>为什么在 import 语句中会出现“变量提升”的效果？</p>
<p>答： ESModule 根据 import 构建依赖树，所以在代码运行前名字就是已经存在于上下文，然后在运行模块最顶层代码，给名字绑定值，就出现了‘变量提升’的效果。<br>在代码真正被执行前，会先进行模块的装配过程，也就是执行一次顶层代码。所以如果import了一个模块，就会先执行模块内部的顶层代码，看起来的现象就是“变量提升”了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>核心原理</tag>
      </tags>
  </entry>
  <entry>
    <title>JS异步</title>
    <url>/2019/12/06/async/</url>
    <content><![CDATA[<p><strong>前言</strong>  什么是异步？异步和同步又有什么区别？</p>
<p>通常来说，程序是按顺序执行的，同一时刻只会发生一件事。如果一个函数依赖另一个函数的结果，它那么它只能等待那个函数结束才能继续执行。</p>
<hr>
<a id="more"></a>
<h3 id="什么是同步？"><a href="#什么是同步？" class="headerlink" title="什么是同步？"></a>什么是同步？</h3><p>一定要等任务执行完了，得到结果，才执行下一个任务。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const btn = document.querySelector(&quot;button&quot;)</span><br><span class="line">  btn.addEventListener(&quot;click&quot;, () =&gt; &#123;</span><br><span class="line">    alert(&quot;点击确定之后，后续代码才会执行&quot;)</span><br><span class="line">    console.log(&quot;aaa&quot;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>上述代码，一行行按顺序执行。</p>
<ol>
<li>先获取DOM里的button引用</li>
<li>监听按钮的click事件<br>alert弹框出现<br>点击弹框确认按钮之后，打印”aaa”</li>
</ol>
<p>每一个操作在执行的时候，其它任何事件都没有发生，因为JavaScript <strong>任何时候只能做一件事情, 只有一个主线程，其他的事情都阻塞了，直到前面的操作完成。</strong></p>
<hr>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>不等任务执行完，直接执行下一个任务。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const asyncFunc = function (callback) &#123;</span><br><span class="line">  return setTimeout(() =&gt; &#123;</span><br><span class="line">    callback(&quot;异步任务执行结束后的结果&quot;)</span><br><span class="line">  &#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncFunc((result) =&gt; &#123;</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&quot;aaa&quot;)</span><br></pre></td></tr></table></figure>
<p>上述代码，先打印”aaa”，后延时2000毫秒执行callback回调。</p>
<h4 id="什么情况下会用到异步？"><a href="#什么情况下会用到异步？" class="headerlink" title="什么情况下会用到异步？"></a>什么情况下会用到异步？</h4><p>当几个任务函数之间没有任何关系，相互之间没有任何影响时，就应该使用异步。</p>
<h4 id="异步代码的本质"><a href="#异步代码的本质" class="headerlink" title="异步代码的本质"></a>异步代码的本质</h4><p>通过以下代码示例，来进一步了解异步代码的本质</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(0);</span><br><span class="line">    &#125;); </span><br><span class="line"></span><br><span class="line">    new Promise(resolve =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(1);</span><br><span class="line">        </span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve();</span><br><span class="line">            Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">                console.log(2);</span><br><span class="line">                setTimeout(() =&gt; console.log(3));</span><br><span class="line">                Promise.resolve().then(() =&gt; console.log(4));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Promise.resolve().then(() =&gt; console.log(5));</span><br><span class="line"></span><br><span class="line">    &#125;).then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(6);</span><br><span class="line">        Promise.resolve().then(() =&gt; console.log(7));</span><br><span class="line">        setTimeout(() =&gt; console.log(8));</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(9);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>简单版理解</p>
<ul>
<li>js 的执行顺序，是先同步再异步。</li>
<li>异步中任务的执行顺序: 先微任务 microtask队列，再宏任务macrotask队列</li>
<li>调用Promise中的resolve，reject属于微任务队列，setTimeout属于宏任务队列</li>
</ul>
<p><strong>同步 &gt; 异步；微任务 &gt; 宏任务</strong></p>
<p>对以上代码任务执行顺序进行编号<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(0);</span><br><span class="line">    &#125;);   // 任务一</span><br><span class="line"></span><br><span class="line">    new Promise(resolve =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(1);</span><br><span class="line">        // 任务二</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve();  // 任务三</span><br><span class="line">            Promise.resolve().then(() =&gt; &#123;  // 任务四</span><br><span class="line">                console.log(2);</span><br><span class="line">                setTimeout(() =&gt; console.log(3)); // 任务八</span><br><span class="line">                Promise.resolve().then(() =&gt; console.log(4)); // 任务九</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);  </span><br><span class="line"></span><br><span class="line">        Promise.resolve().then(() =&gt; console.log(5)); // 任务五</span><br><span class="line"></span><br><span class="line">    &#125;).then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(6);</span><br><span class="line">        Promise.resolve().then(() =&gt; console.log(7));  // 任务六</span><br><span class="line">        setTimeout(() =&gt; console.log(8)); // 任务七</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(9);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>第一步：<br>任务一的setTimeout 函数属于宏任务，先丢入宏列队。<br>同步执行，先打印1.同步执行打印 9</p>
<table>
<thead>
<tr>
<th>微任务</th>
<th>宏任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>任务五</td>
<td>任务一</td>
</tr>
<tr>
<td></td>
<td>任务二</td>
</tr>
</tbody>
</table>
<p>第二步:<br>任务二丢入宏列队，执行微任务任务三，打印5<br>第三步:<br>同步任务及微任务已经执行完毕，开始执行宏任务</p>
<ul>
<li>执行任务一，打印0</li>
<li>执行任务二<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve();  // 任务三</span><br><span class="line">            Promise.resolve().then(() =&gt; &#123;  // 任务四</span><br><span class="line">                console.log(2);</span><br><span class="line">                setTimeout(() =&gt; console.log(3)); // 任务八</span><br><span class="line">                Promise.resolve().then(() =&gt; console.log(4));  // 任务九</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>第四步:<br> 执行任务三，打印 6，将任务六丢入微任务中，任务七丢入宏任务中</p>
<p>第五步:<br>执行任务四，打印 2，将任务八丢入宏任务，任务九丢入微任务</p>
<p>第六步:<br>执行任务六，打印7<br>执行任务九，打印4<br>任务七，打印8<br>任务八，打印3</p>
<table>
<thead>
<tr>
<th>微任务</th>
<th>宏任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>任务三</td>
<td></td>
</tr>
<tr>
<td>任务四</td>
<td></td>
</tr>
<tr>
<td>任务六</td>
<td>任务七</td>
</tr>
<tr>
<td>任务九</td>
<td>任务八</td>
</tr>
</tbody>
</table>
<p>最终打印输出的顺序为1，9，5，0，6，2，7，4，8，3</p>
<font color="#ccc">2020.0519补充</font>

<h3 id="如何分析异步执行的顺序"><a href="#如何分析异步执行的顺序" class="headerlink" title="如何分析异步执行的顺序"></a>如何分析异步执行的顺序</h3><ul>
<li>首先我们分析有多少个宏任务</li>
<li>在每个宏任务中，分析有多少个微任务</li>
<li>根据调用次序，确定宏任务中的微任务执行次序</li>
<li>根据宏任务的触发规则和调用次序，确定宏任务的执行次序</li>
<li>确定整个顺序。</li>
</ul>
<h3 id="新特性-async-await"><a href="#新特性-async-await" class="headerlink" title="新特性 async/await"></a>新特性 async/await</h3><p>async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样，就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。async 函数必定返回 Promise。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function sleep(duration) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        setTimeout(resolve,duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async function foo(name)&#123;</span><br><span class="line">    await sleep(2000)</span><br><span class="line">    console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">async function foo2()&#123;</span><br><span class="line">    await foo(&quot;a&quot;);</span><br><span class="line">    await foo(&quot;b&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>异步还是同步执行代码，取决于我们要做什么。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>你该如何找到理财正确的方向</title>
    <url>/2019/05/16/finance/</url>
    <content><![CDATA[<p><strong>前言</strong>   是什么让你决定开始理财？<br><strong>理财是赚钱吗？</strong> </p>
<a id="more"></a>
<h2 id="理财的认知"><a href="#理财的认知" class="headerlink" title="理财的认知"></a>理财的认知</h2><p> <strong>应时刻谨记，你不是为了赚钱而理财，而是为了拥有更好的生活而理财。</strong><br> <strong>理财只是用来“改善生活”提升幸福感的，绝不是用来逆袭改变命运的。</strong></p>
<h3 id="为什么要理财？"><a href="#为什么要理财？" class="headerlink" title="为什么要理财？"></a>为什么要理财？</h3><h4 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h4><p><strong>通货膨胀，就是钱的购买力越来越低。其实质是社会总需求大于社会总供给 。</strong><br>《小狗钱钱》一书中有提到一个<strong>72定理</strong>，它可以告诉我们在一定通货膨胀率下，我们的钱在多长时间后会贬值一半。<br>假如说通货膨胀率为3%， 72 / 3 = 24 ，就是说24年以后，你的钱将会贬值一半。</p>
<h4 id="增加被动收入"><a href="#增加被动收入" class="headerlink" title="增加被动收入"></a>增加被动收入</h4><p>让钱动起来，让钱为你工作。</p>
<h4 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h4><blockquote>
<p>理财是规划，是打理我们的时间、也是打理我们的生活。<br>理财的目的不应该是是为了追求收益，而是可以通过理财规划去实现每个人生阶段的财务需求目标，使得生活更美好。<br>理财是一场平淡而持久的人生管理，是伴随我们一生的一种生活方式。</p>
</blockquote>
<h3 id="理财误区"><a href="#理财误区" class="headerlink" title="理财误区"></a>理财误区</h3><h4 id="没钱没法理财"><a href="#没钱没法理财" class="headerlink" title="没钱没法理财"></a>没钱没法理财</h4><p>你不理财，财不理你。理财不仅仅是投资，还包括了收支规划、养老安排、子女教育、甚至税务筹划等等。它不是一个简单的工具，更多的是一种思维习惯和生活方式。</p>
<h4 id="把所有的钱都拿去投资"><a href="#把所有的钱都拿去投资" class="headerlink" title="把所有的钱都拿去投资"></a>把所有的钱都拿去投资</h4><p><strong>不要把所有的鸡蛋都放在同一个篮子里。</strong><br>钱应该分位4份： 1份用来日常花销；一份用来买保障；一份用来跑赢通货膨胀；还有一份，用来赚取高收益。</p>
<h4 id="不懂不投"><a href="#不懂不投" class="headerlink" title="不懂不投"></a>不懂不投</h4><p>刚考完驾照的时候，你敢上高速莫？(Ps: 感觉这个例子不恰当，后续再做修改。我驾照没俩月的时候已经两趟高速了。)</p>
<blockquote>
<p><strong>靠运气赚来的钱最终会被靠实力亏掉。</strong></p>
</blockquote>
<hr>
<font color="#ddd" size="2">20190517补充</font>

<h2 id="你有多少钱可以用来理财？"><a href="#你有多少钱可以用来理财？" class="headerlink" title="你有多少钱可以用来理财？"></a>你有多少钱可以用来理财？</h2><p>在理财投资之前，应该清楚的知道自己的资产状况。只有知道自己有多少资产，才能做出正确的投资行为。</p>
<h3 id="资产负债"><a href="#资产负债" class="headerlink" title="资产负债"></a>资产负债</h3><h4 id="什么是资产？"><a href="#什么是资产？" class="headerlink" title="什么是资产？"></a>什么是资产？</h4><p><strong>资产，就是能换成钱的东西。</strong><br>比方说你的房子、车子、工资、甚至是别人欠你的钱，都算作资产（Ps: 钱本身就是资产）。</p>
<h4 id="什么是负债？"><a href="#什么是负债？" class="headerlink" title="什么是负债？"></a>什么是负债？</h4><p><strong>负债，就是你欠别人的钱。</strong><br>比方说你的房贷、车贷、信用卡、甚至是借的别人的钱，都算作负债。</p>
<h3 id="所有者权益"><a href="#所有者权益" class="headerlink" title="所有者权益"></a>所有者权益</h3><p><strong>所有者权益就是真正属于你自己的钱</strong><br>会计学上有个公式: <strong>资产=负债 + 所有者权益</strong> 资产减负值，才是真正属于你自己的钱。<br>意思是指，你所拥有的钱，等于你借来的钱，加上真正属于你的钱。</p>
<h3 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a>资产负债表</h3><table>
<thead>
<tr>
<th>资产种类</th>
<th>本月余额</th>
<th>负债种类</th>
<th>本月负债</th>
</tr>
</thead>
<tbody>
<tr>
<td>现金</td>
<td></td>
<td>熟人借款</td>
<td></td>
</tr>
<tr>
<td>定期存款</td>
<td></td>
<td>信用卡欠款</td>
<td></td>
</tr>
<tr>
<td>活期存款</td>
<td></td>
<td>花呗</td>
<td></td>
</tr>
<tr>
<td>理财型保险</td>
<td></td>
<td>京东白条</td>
<td></td>
</tr>
<tr>
<td>货币基金</td>
<td></td>
<td>微粒贷</td>
<td></td>
</tr>
<tr>
<td>其它种类基金</td>
<td></td>
<td>其它手机借款</td>
<td></td>
</tr>
<tr>
<td>股票</td>
<td></td>
<td>房贷</td>
<td></td>
</tr>
<tr>
<td>收藏品</td>
<td></td>
<td>车贷</td>
<td></td>
</tr>
<tr>
<td>汽车</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>电器</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>应收借款</td>
<td></td>
<td>本月总负债</td>
<td></td>
</tr>
<tr>
<td>其它</td>
<td></td>
<td>所有者权益(总资产 - 总负债)</td>
<td></td>
</tr>
<tr>
<td>本月总资产</td>
<td></td>
<td>资产负债率(总负债 / 总资产)</td>
<td>.</td>
</tr>
</tbody>
</table>
<h3 id="收入支出表"><a href="#收入支出表" class="headerlink" title="收入支出表"></a>收入支出表</h3><p>收入支出表，就是根据自己的收支情况，每天做一个基本的记录。收入多少，花费多少。</p>
<p>弄清楚这几个概念，以后应当养成每周或每月记录消费情况，用来看清楚自己的收支情况。</p>
]]></content>
      <categories>
        <category>大千世界</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>Loader和插件的编写</title>
    <url>/2021/01/17/Loader%E5%92%8C%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<p>webpack loader 和插件编写。</p>
<a id="more"></a>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>loader 本身是一个函数，接受源文件作为参数，返回转换的结果。</p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>loader 的执行顺序为从右向左。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// webpack 采用的执行顺序(函数组合情况)</span><br><span class="line">compose = (f, g) =&gt; (...args) =&gt; f(g(...args))</span><br></pre></td></tr></table></figure>
<h3 id="loader-runner"><a href="#loader-runner" class="headerlink" title="loader-runner"></a>loader-runner</h3><p><strong>定义：</strong> 允许在不安装 webpack-cli 的前提下运行 loader</p>
<p><strong>作用：</strong></p>
<ol>
<li>提供独立的运行环境</li>
<li>作为 webpack 的依赖，在 webpack 中使用它执行 loader；</li>
<li>进行 loader 的开发和调试。</li>
<li><a href="https://github.com/webpack/loader-runner" target="_blank" rel="noopener">github 地址</a></li>
</ol>
<h4 id="编写一个调试实例（处理-es6-安全性问题）"><a href="#编写一个调试实例（处理-es6-安全性问题）" class="headerlink" title="编写一个调试实例（处理 es6 安全性问题）"></a>编写一个调试实例（处理 es6 安全性问题）</h4><p><em>编码为 2028 的字符为行分隔符，会被浏览器理解为换行，而在 Javascript 的字符串表达式中是不允许换行的，从而导致错误。2029 为段分隔号，同 2028</em></p>
<ul>
<li>目录结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- pageage.json</span><br><span class="line">-- src</span><br><span class="line">	-- demo.txt</span><br><span class="line">	-- raw-loader.js</span><br><span class="line">-- run-loader.js</span><br><span class="line"></span><br><span class="line">$ npm i loader-runner -S</span><br></pre></td></tr></table></figure>
<ul>
<li>src/demo.txt</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asd</span><br></pre></td></tr></table></figure>
<ul>
<li>src/raw-loader.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = function(source) &#123;</span><br><span class="line">  const json = JSON.stringify(source)</span><br><span class="line">    .replace(/\u2028/g, &apos;\\u2028&apos;)</span><br><span class="line">    .replace(/\u2029/g, &apos;\\u2029&apos;)</span><br><span class="line"></span><br><span class="line">  rerurn `export defalut $&#123;json&#125;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>run-loader.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 核心函数runLoaders</span><br><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">const &#123; runLoaders &#125; = require(&apos;loader-runner&apos;)</span><br><span class="line"></span><br><span class="line">runLoaders(&#123;</span><br><span class="line">  resource: path.join(__dirname, &apos;./src/demo.txt&apos;), // 资源绝对路径</span><br><span class="line">  loaders: [</span><br><span class="line">    path.join(__dirname, &apos;./src/raw-loader.js&apos;)</span><br><span class="line">  ],</span><br><span class="line">  context: &#123; // 额外上下文</span><br><span class="line">    minimize: true, // 压缩参数</span><br><span class="line">  &#125;,</span><br><span class="line">  readResource: fs.readFile.bind(fs)</span><br><span class="line"></span><br><span class="line">&#125;, (err, result) =&gt; &#123;</span><br><span class="line">  err ? console.error(err) : console.log(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 打印结果</span><br><span class="line"></span><br><span class="line">&#123; result: [ &apos;export defalut &quot;&quot;&apos; ],</span><br><span class="line">  resourceBuffer: &lt;Buffer &gt;,</span><br><span class="line">  cacheable: true,</span><br><span class="line">  fileDependencies:</span><br><span class="line">   [ &apos;/Users/wangguanwei/Desktop/test/webpack/raw-loader/src/demo.txt&apos; ],</span><br><span class="line">  contextDependencies: [],</span><br><span class="line">  missingDependencies: [] &#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写一个构建资源为-zip-包的插件"><a href="#编写一个构建资源为-zip-包的插件" class="headerlink" title="编写一个构建资源为 zip 包的插件"></a>编写一个构建资源为 zip 包的插件</h3><p><a href="https://github.com/Cinaiet/zip-loader" target="_blank" rel="noopener">代码仓库地址</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2018/12/06/git/</url>
    <content><![CDATA[<h4 id="本地配置多个sshkey"><a href="#本地配置多个sshkey" class="headerlink" title="本地配置多个sshkey"></a>本地配置多个sshkey</h4><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  生成一个私人使用的sshkey</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;email@privite.com&quot; -f ~/.ssh/id_rsa </span><br><span class="line"></span><br><span class="line">// 生成一个公司使用的sshkey</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;2email@github.com&quot; -f ~/.ssh/company_rsa </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">or </span><br><span class="line"></span><br><span class="line">$ ssh-keygen -t rsa -C &quot;email@privite.com&quot;</span><br><span class="line">// 第一次生成是一路回车生成默认的 id_rsa</span><br><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ssh-keygen -t rsa -C‘youremail@company.com’ 继续生成第二个sshkey</span><br><span class="line">// 回车之后输入sshkey的名字，之后一路回车就行。</span><br></pre></td></tr></table></figure>
<h4 id="从远端服务器拉取分支到本地"><a href="#从远端服务器拉取分支到本地" class="headerlink" title="从远端服务器拉取分支到本地"></a>从远端服务器拉取分支到本地</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b &lt;branchName&gt; origin/&lt;branchName&gt;</span><br></pre></td></tr></table></figure>
<h4 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -D &lt;branchName&gt;</span><br></pre></td></tr></table></figure>
<h4 id="删除远端分支"><a href="#删除远端分支" class="headerlink" title="删除远端分支"></a>删除远端分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete &lt;branchName&gt;</span><br></pre></td></tr></table></figure>
<h4 id="丢弃当前工作区里修改的内容"><a href="#丢弃当前工作区里修改的内容" class="headerlink" title="丢弃当前工作区里修改的内容"></a>丢弃当前工作区里修改的内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout --&lt;branch&gt; // -- 必须有，不然就是切换分支命令</span><br><span class="line">$ git checkout . // 为丢弃当前所有修改的内容</span><br></pre></td></tr></table></figure>
<h4 id="在不更改本地代码的情况下代码回退一个版本"><a href="#在不更改本地代码的情况下代码回退一个版本" class="headerlink" title="在不更改本地代码的情况下代码回退一个版本"></a>在不更改本地代码的情况下代码回退一个版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  git reset --soft HEAD~1       // 在不更改本地代码的前提(soft)下代码回退一个版本 HEAD~100 就是回退100个版本</span><br><span class="line">$ git push --force               // 强制覆盖掉远程上一个版本</span><br></pre></td></tr></table></figure>
<h4 id="将本地分支代码指定push到远端某一个分支"><a href="#将本地分支代码指定push到远端某一个分支" class="headerlink" title="将本地分支代码指定push到远端某一个分支"></a>将本地分支代码指定push到远端某一个分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  git push origin &lt;branchName&gt;:&lt;branchName&gt;</span><br></pre></td></tr></table></figure>
<h4 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h4><p>在切换分支前当前分支代码已经做出改动，需要先将代码暂存才能切换分支进行操作。</p>
<h5 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h5>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure>
<h5 id="查看当前缓存区列表"><a href="#查看当前缓存区列表" class="headerlink" title="查看当前缓存区列表"></a>查看当前缓存区列表</h5>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure>
<h5 id="还原当前分支缓存区内容"><a href="#还原当前分支缓存区内容" class="headerlink" title="还原当前分支缓存区内容"></a>还原当前分支缓存区内容</h5>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash pop stash@&#123;0&#125; // stash@&#123;0&#125; 为list里的第一个内容</span><br></pre></td></tr></table></figure>
<h5 id="删除本地暂存内容"><a href="#删除本地暂存内容" class="headerlink" title="删除本地暂存内容"></a>删除本地暂存内容</h5>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash drop stash@&#123;0&#125;  // stash@&#123;0&#125; 为list里的第一个内容</span><br></pre></td></tr></table></figure>
<h4 id="重返未来。"><a href="#重返未来。" class="headerlink" title="重返未来。"></a>重返未来。</h4><p>记录每一次的命令，用于确定要回到未来的哪个版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure></p>
<h4 id="回退到指定版本"><a href="#回退到指定版本" class="headerlink" title="回退到指定版本"></a>回退到指定版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD~1 // HEAD~1表示回退一个版本</span><br></pre></td></tr></table></figure>
<h4 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h4><p>比方说现在有个任务分支dev，并且已经提到了远端，现想合并到master分支<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge origin/dev</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master </span><br><span class="line">$ git pull origin/dev</span><br></pre></td></tr></table></figure></p>
<h4 id="合并指定的某一次提交到功能分支"><a href="#合并指定的某一次提交到功能分支" class="headerlink" title="合并指定的某一次提交到功能分支"></a>合并指定的某一次提交到功能分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout dev // 切换到想合并的分支</span><br><span class="line">$ git log // 查看提交记录</span><br><span class="line">$ git checkout master // 切换到功能分支</span><br><span class="line">$ git cherry-pick xxx // xxx 为某一次的提交记录的commit-id</span><br></pre></td></tr></table></figure>
<p><em>20210118补充</em></p>
<h4 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h4><h5 id="将一个分支上的所有提交内容，转移到新的任务分支上。"><a href="#将一个分支上的所有提交内容，转移到新的任务分支上。" class="headerlink" title="将一个分支上的所有提交内容，转移到新的任务分支上。"></a>将一个分支上的所有提交内容，转移到新的任务分支上。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// A~B 为连续的几次提交内容</span><br><span class="line">$ git cherry-pick A^..B</span><br></pre></td></tr></table></figure>
<h4 id="根据commit-id-回滚指定的提交"><a href="#根据commit-id-回滚指定的提交" class="headerlink" title="根据commit id 回滚指定的提交"></a>根据commit id 回滚指定的提交</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git revert xxx -m  1</span><br></pre></td></tr></table></figure>
<h4 id="以上"><a href="#以上" class="headerlink" title="以上"></a>以上</h4>]]></content>
      <categories>
        <category>千百度</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2018/12/06/hexo/</url>
    <content><![CDATA[<h4 id="前言-基于hexo-GitHub-构建个人博客，当前环境默认已安装git-和node，两者的安装方法这里不再赘述。"><a href="#前言-基于hexo-GitHub-构建个人博客，当前环境默认已安装git-和node，两者的安装方法这里不再赘述。" class="headerlink" title="前言: 基于hexo + GitHub 构建个人博客，当前环境默认已安装git 和node，两者的安装方法这里不再赘述。"></a>前言: 基于hexo + GitHub 构建个人博客，当前环境默认已安装git 和node，两者的安装方法这里不再赘述。</h4><a id="more"></a>
<hr>
<h2 id="相关步骤"><a href="#相关步骤" class="headerlink" title="相关步骤"></a>相关步骤</h2><ul>
<li><p>新建文件目录，并进入新的文件目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog/</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装hexo (-g 为全局安装)，并检查是否安装成功。<br><strong><em>由于本地已经安装hexo上述代码不再详细赘述。</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wangguanweideMacBook-Pro:blog xiaowei$ npm install hexo -g</span><br><span class="line">wangguanweideMacBook-Pro:blog xiaowei$ hexo -v</span><br><span class="line">hexo: 3.8.0</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">node: 8.11.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>有hexo 就说明安装成功，初始化该文件夹，初始化完成之后再下载文件依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wangguanweideMacBook-Pro:blog xiaowei$ hexo init</span><br><span class="line">wangguanweideMacBook-Pro:blog xiaowei$ npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成静态文件，启动服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wangguanweideMacBook-Pro:blog xiaowei$ hexo g</span><br><span class="line">wangguanweideMacBook-Pro:blog xiaowei$ hexo s</span><br></pre></td></tr></table></figure>
</li>
<li><p>将git的公钥配置在GitHub中。配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）username 为你的github名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>deploy:<br> type: git<br> repository: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:username/username.github.io.git<br> branch: master</p>
</blockquote>
</li>
<li><p>新建文章。layout为布局，title为文件名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑完成之后，就可以发布部署了。在生成以及部署文章之前，需要安装一个hexo-deployer-git 扩展。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="以上。"><a href="#以上。" class="headerlink" title="以上。"></a>以上。</h6><hr>
<h6 id="2019-04-25-补充"><a href="#2019-04-25-补充" class="headerlink" title="2019.04.25 补充"></a>2019.04.25 补充</h6><ol>
<li>针对于每次发布部署新的文章之后，都需要在github page页上面重新配置解析的域名。<ul>
<li>解决办法: 在blog/source/ 目录下，新建一个无任何格式的文件，文件名 CNAME。在CNAME文件中写入要解析到域名url</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim CNAME</span><br><span class="line">  blog.xxx.com // 在文件中写入域名url</span><br></pre></td></tr></table></figure>
<h6 id="以上。-1"><a href="#以上。-1" class="headerlink" title="以上。"></a>以上。</h6>]]></content>
      <categories>
        <category>千百度</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>npm与包的发布</title>
    <url>/2019/08/28/npm%E4%B8%8E%E5%8C%85%E7%9A%84%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p><strong>前言</strong>   npm包的出现，一定程度上的解决了变量依赖、依赖关系等代码组织性问题。<br><a id="more"></a></p>
<hr>
<h3 id="包的结构"><a href="#包的结构" class="headerlink" title="包的结构"></a>包的结构</h3><p> <strong>包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原为目录。</strong></p>
<h4 id="package-json-包描述文件"><a href="#package-json-包描述文件" class="headerlink" title="package.json  包描述文件"></a>package.json  包描述文件</h4><p>package.json中定义了如下必需字段(未全列入)</p>
<ul>
<li><strong>name 包名</strong> 包名必须是唯一的，规范定义它需要由小写的字母和数字组成，可以包含、. _和 -，但不允许出现空格。</li>
<li><strong>description</strong> 包简介。</li>
<li><strong>version</strong> 版本号</li>
<li><strong>keywords</strong> 关键字。用来NPM中的分类搜索。</li>
<li><em>未完待续…</em></li>
</ul>
<hr>
<h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><p>为了将整个流程串联起来，这里演示如何编写一个包，将其发布到npm仓库中，并通过npm安装到本地。</p>
<h4 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编写hello.js</span><br><span class="line">exports.sayHello = function () &#123;</span><br><span class="line">  return &apos;Hello World&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化包描述文件"><a href="#初始化包描述文件" class="headerlink" title="初始化包描述文件"></a>初始化包描述文件</h4><p>package.json 文件的内容尽管相对较多，但实际发布一个包时不需要一行行编写。NPM提供 <strong>npm init</strong> 命令来帮助生成package.json 文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm init </span><br><span class="line"></span><br><span class="line">// 以下内容NPM通过提问式的交互形式，来逐个填写。</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;wgw_test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A Wgw Hello Test&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;hello.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https://github.com/Cinaiet/wgw_hello.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;wgw&quot;,</span><br><span class="line">    &quot;hello&quot;,</span><br><span class="line">    &quot;world&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;cinaiet&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/Cinaiet/wgw_hello/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;https://github.com/Cinaiet/wgw_hello#readme&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="注册npm包仓库账号"><a href="#注册npm包仓库账号" class="headerlink" title="注册npm包仓库账号"></a>注册npm包仓库账号</h4><p>为了维护包，NPM必须要使用仓库账号才允许将包发布到仓库中。注册命令是<strong>npm adduser</strong>，这也是一个提问式的交互过程。<br><em>注：注册成功之后，务必去npm官网激活邮箱， 这点很重要，关联到包能否正常发布</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm adduser</span><br><span class="line">  Username: xxx</span><br><span class="line">  Password: xxx</span><br><span class="line">  Email: xxx</span><br></pre></td></tr></table></figure>
<h4 id="上传包"><a href="#上传包" class="headerlink" title="上传包"></a>上传包</h4><p>上传包的命令是<strong>npm publish <folder></folder></strong>。在刚刚创建package.json的文件夹下，执行<strong>npm publish .</strong>，开始上传包。</p>
<h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><p>安装包的命令是<strong>npm install xxx</strong>或 <strong>npm install xxx -g  </strong>(全局安装)</p>
<hr>
<p>以上。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能调优-HTML</title>
    <url>/2025/02/11/optimize-html/</url>
    <content><![CDATA[<p>就性能而言，HTML 本身非常简单，主要是文本，文本相较来说也比较小。可优化即需要注意的细节包括：</p>
<a id="more"></a>
<h2 id="精简-HTML-代码"><a href="#精简-HTML-代码" class="headerlink" title="精简 HTML 代码"></a>精简 HTML 代码</h2><ul>
<li>减少 HTML 的嵌套；</li>
<li>减少 DOM 节点数；</li>
<li>减少无语义代码 (如： <div class="clear"> </div> 消除浮动)；</li>
<li>删除 http 或者 https，如果 URL 的协议头和当前页面的协议头一致的，或者此 URL 在多个协议头都是可用的，则可以考虑删除协议头；</li>
<li>删除多余的空格、换行符、缩进和不必要的注释；</li>
<li>省略冗余标签和属性；</li>
<li>使用相对路径对的 URL；</li>
</ul>
<h2 id="文件放在合适位置"><a href="#文件放在合适位置" class="headerlink" title="文件放在合适位置"></a>文件放在合适位置</h2><ul>
<li>CSS 文件链接尽量放在头部；<br>CSS 的加载不会阻塞 DOM tree 的解析，但是会阻塞 DOM tree 的渲染，也会阻塞后面 JS 执行。任何 body 元素之前，可以确保在文档部分忠解析了所有的 CSS 样式(内联合外联)，从而减少浏览器的重排次数。</li>
<li>JS 引用放在 HTML 底部； 防止 JS 加载、解析、执行阻塞页面后续元素的正常渲染。</li>
</ul>
<h2 id="增强用户体验"><a href="#增强用户体验" class="headerlink" title="增强用户体验"></a>增强用户体验</h2><ul>
<li>设置 favicon.ico；<br>如果不设置 favicon.ico 控制台会报错，同时不利于记忆网站品牌。</li>
<li>增加首屏必要的 CSS 和 JS；<br>如页面 loading 或背景图，使首屏能快速显示。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能调优-CSS</title>
    <url>/2025/02/11/optimize-css/</url>
    <content><![CDATA[<p>CSS 性能调优对于提升页面的加载速度和渲染效率非常重要。下面是一些关键的 CSS 调优技巧。</p>
<a id="more"></a>
<h2 id="提升-CSS-渲染性能"><a href="#提升-CSS-渲染性能" class="headerlink" title="提升 CSS 渲染性能"></a>提升 CSS 渲染性能</h2><ul>
<li>慎用 expensive 属性；如 nth-child 伪类，position:fixed 定位；</li>
<li>尽量减少样式层级数； 如 div ul li span i {color: red;}</li>
<li>尽量避免使用占用过多 CPU 和内存的属性；如 text-indent:9999px;</li>
<li>尽量避免使用耗电量大的属性； 如 CSS3 3D transforms、transitions、Opaticy;</li>
</ul>
<h2 id="合理使用-CSS-选择器"><a href="#合理使用-CSS-选择器" class="headerlink" title="合理使用 CSS 选择器"></a>合理使用 CSS 选择器</h2><ul>
<li>尽量避免使用 CSS 表达式； 如 background-color: expression((new Date().getHours() % 2 ? ‘#FFF’: ‘#000’))</li>
<li>尽量避免使用通配符选择器 如 body &gt; a {xxx}</li>
<li>尽量避免类正则的属性选择器 如 *= |= ^= $=</li>
</ul>
<h2 id="提升-CSS-文件加载性能"><a href="#提升-CSS-文件加载性能" class="headerlink" title="提升 CSS 文件加载性能"></a>提升 CSS 文件加载性能</h2><ul>
<li>使用外链的 CSS</li>
<li>尽量避免使用 @import</li>
</ul>
<h2 id="精简-CSS-代码"><a href="#精简-CSS-代码" class="headerlink" title="精简 CSS 代码"></a>精简 CSS 代码</h2><ul>
<li>使用缩写语句；如 margin-top:10px; margin-bottom: 10; 可以合写为 margin: 10px 0;</li>
<li>删除不必要的零； 如 font-size:0.5rem; 可以写为 font-size: .5rem;</li>
<li>删除不必要的单位； 如 margin-top: 0px; 可写为 margin-top: 0;</li>
<li>删除过多分号；</li>
<li>删除空格和注释；</li>
<li>尽量减少样式表的大小；</li>
</ul>
<h2 id="合理使用-Web-fonts"><a href="#合理使用-Web-fonts" class="headerlink" title="合理使用 Web fonts"></a>合理使用 Web fonts</h2><ul>
<li>将字体部署在 CDN 上；</li>
<li>将字体以 base64 形式保存在 CSS 中并通过 localstorage 进行缓存；</li>
<li>Google 字体应使用国内托管服务；</li>
</ul>
<h2 id="CSS-动画优化"><a href="#CSS-动画优化" class="headerlink" title="CSS 动画优化"></a>CSS 动画优化</h2><ul>
<li>避免同时动画；</li>
<li>延迟动画初始化；保证其它动画正常渲染</li>
<li>结合 SVG；</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能调优-图片优化</title>
    <url>/2025/02/10/optimize-image/</url>
    <content><![CDATA[<p>图片优化，指的是在不牺牲图片质量的前提下，尽可能压缩图片大小，从而达到缩短页面加载时长的目的。同时，图片优化也有助于 SEO，提高图片在搜索引擎上的排名。</p>
<a id="more"></a>
<h2 id="图片格式及应用场景"><a href="#图片格式及应用场景" class="headerlink" title="图片格式及应用场景"></a>图片格式及应用场景</h2><h3 id="JPEG-Joint-Photographic-Experts-Group"><a href="#JPEG-Joint-Photographic-Experts-Group" class="headerlink" title="JPEG (Joint Photographic Experts Group)"></a>JPEG (Joint Photographic Experts Group)</h3><p>联合图像专家小组针对彩色图片而广泛使用的有损压缩图形格式。</p>
<ul>
<li>栅格图形。常用文件扩展名为 .jpg，也有.jpeg、.jpe。JPEG 在互联网上应用于存储和传输照片；</li>
<li>不适合线条图形和文字、图标图形，压缩算法不太适合这类型的图形，并且不支持透明度；</li>
<li>非常适合颜色丰富的照片、彩色图、大焦点图、Banner 图、结构不规则的图形。</li>
</ul>
<h3 id="PNG-Portable-Network-Graphics"><a href="#PNG-Portable-Network-Graphics" class="headerlink" title="PNG (Portable Network Graphics)"></a>PNG (Portable Network Graphics)</h3><p>便携式网络图形是一种无损压缩的位图图形格式，支持索引、灰度、RGB 三种颜色方案以及 Alpha 通道等特性。</p>
<ul>
<li>栅格图形。PNG 最初是作为替代 GIF 来设计的，能够显示 256 色，文件比 JPEG 或者 GIF 大，但是 PNG 能非常好的保留图像质量。支持 Alpha 通道的半透明和透明特性。最高支持 24 位彩色图像(PNG-24)和 8 位灰度图像(PNG-8)</li>
<li>不适合彩色图像；</li>
<li>非常适合 纯色、透明、线条绘图，图标；边缘清晰、有大块相同颜色区域；颜色数较少但需要半透明的图像。</li>
</ul>
<h3 id="GIF-Graphics-Interchange-Format"><a href="#GIF-Graphics-Interchange-Format" class="headerlink" title="GIF (Graphics Interchange Format)"></a>GIF (Graphics Interchange Format)</h3><p>图像互换格式是一种位图图形文件格式，以 8 位色(即 256 种颜色)重现真彩色的图像，采用 LAW 压缩算法进行编码。</p>
<ul>
<li>栅格图形。 支持 256 色；仅支持完全透明和完全不透明；如果需要比较通用的动画，GIF 是唯一选择；</li>
<li>不适合存储彩色图片，因为每个像素只有 8 比特；</li>
<li>适合用于 动画、图标。</li>
</ul>
<h3 id="Webp"><a href="#Webp" class="headerlink" title="Webp"></a>Webp</h3><p>Webp 是一种现代图像格式，可为图像提供无损压缩和有损压缩，这使得它非常灵活。</p>
<ul>
<li>能同时保证一定程序上的图像质量和比较小的体积。可以插入多帧，实现动画效果；可以设置透明度；采用 8 位压缩算法。无损的 Webp 比 PNG 小 26%，有损的 Webp 比 JPEG 小 25%-34%。比 GIF 有更好的动画。</li>
<li>不适合彩色图片，最多处理 256 色；</li>
<li>适用于图形和半透明图像。</li>
</ul>
<h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><h3 id="压缩-PNG"><a href="#压缩-PNG" class="headerlink" title="压缩 PNG"></a>压缩 PNG</h3><p>使用 <a href="https://github.com/oxUnd/node-pngquant-native" target="_blank" rel="noopener">node-pngquant-native</a> 进行压缩，压缩 PNG24 非常好，跨平台且压缩比高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pngquant = require(&apos;node-pngquant-native&apos;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;./input.png&apos;, function (err, buffer) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  var resBuffer = pngquant.compress(buffer, &#123;</span><br><span class="line">    &quot;speed&quot;: 1 //1 ~ 11</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fs.writeFile(&apos;./output.png&apos;, resBuffer, &#123;</span><br><span class="line">      flags: &apos;wb&apos;</span><br><span class="line">  &#125;, function(err)&#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="压缩-GIF"><a href="#压缩-GIF" class="headerlink" title="压缩 GIF"></a>压缩 GIF</h3><p>使用<a href="https://www.lcdf.org/gifsicle/" target="_blank" rel="noopener">Gifsicle</a>通过改变每帧比例，减少 gif 文件大小，同时可以使用透明来达到更小的文件大小，目前公认的解决方案。</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul>
<li><p>gifsicle –optimize=3 - o output.gif input.gif (优化级别设置为不小于 2,1 的话基本不压缩)</p>
</li>
<li><p>将透明部分截去: gifsicle –optimize=3 –crop-transparency -o output.gif input.gif</p>
</li>
</ul>
<h2 id="响应式图片加载"><a href="#响应式图片加载" class="headerlink" title="响应式图片加载"></a>响应式图片加载</h2><ul>
<li>通过 Js 检测窗口大小来修改图片大小；</li>
<li><p>CSS 媒体查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media screen and(max-width:640px) &#123;</span><br><span class="line">    image &#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>img 标签属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img srcset=&quot;img-320w.jpg,img-640w.jpg 2x,img-960w.jpg 3x&quot; src=&quot;img-960w.jpg&quot; alt=&quot;img&quot; /&gt;</span><br><span class="line"></span><br><span class="line">// x描述符标识图像设备的像素比</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="图像逐步加载"><a href="#图像逐步加载" class="headerlink" title="图像逐步加载"></a>图像逐步加载</h2><h3 id="统一占位符"><a href="#统一占位符" class="headerlink" title="统一占位符"></a>统一占位符</h3><p>如图像加载过程中使用固定的 loading 图；</p>
<h3 id="LQIP"><a href="#LQIP" class="headerlink" title="LQIP"></a>LQIP</h3><p>使用<a href="https://github.com/zouhir/lqip" target="_blank" rel="noopener">LQIP</a>低质量图像占位符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const lqip = require(&apos;lqip&apos;);</span><br><span class="line"></span><br><span class="line">const file = `./dest/to/file/zouhir-riding-a-bike.jpg`;</span><br><span class="line"></span><br><span class="line">lqip.base64(file).then(res =&gt; &#123;</span><br><span class="line">  console.log(res); // &quot;data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhY.....</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="SQIP"><a href="#SQIP" class="headerlink" title="SQIP"></a>SQIP</h3><p>基于 SVG 的图像占位符 <a href="https://github.com/axe312ger/sqip" target="_blank" rel="noopener">SQIP</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sqip = require(&apos;sqip&apos;);</span><br><span class="line"></span><br><span class="line">const result = sqip(&#123;</span><br><span class="line">    filename: &apos;input.png&apos;,</span><br><span class="line">    numberOfPrimitives: 10 // 效果值</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>
<h2 id="图片服务器智能优化"><a href="#图片服务器智能优化" class="headerlink" title="图片服务器智能优化"></a>图片服务器智能优化</h2><p>根据图片 URL 连接上的特殊参数服务器自动生成不同格式、大小、质量的图片。</p>
<p>如将上述不同的压缩图像的工具部署到服务器，采用不同的入参来控制不同的压缩形式来生成相应的图像。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能调优-JavaScript</title>
    <url>/2025/02/11/optimize-javascript/</url>
    <content><![CDATA[<p>并不是每次项目开发都需要进行优化，而是当项目进行到某一阶段，程序变得越来越复杂时，再进行优化。当需要时再进行优化，书写的同时也应当注意代码的可维护性。</p>
<a id="more"></a>
<h2 id="提升加载性能"><a href="#提升加载性能" class="headerlink" title="提升加载性能"></a>提升加载性能</h2><p>将 CSS 放在 head 标签里，JS 放在 body 结尾的地方；</p>
<h2 id="变量和函数优化"><a href="#变量和函数优化" class="headerlink" title="变量和函数优化"></a>变量和函数优化</h2><ul>
<li>尽量使用 id 选择器；</li>
<li>尽量避免使用 eval；</li>
<li>函数尽可能保持简洁；</li>
<li>使用事件节流函数；</li>
<li>使用事件委托；</li>
</ul>
<h2 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h2><ul>
<li>避免添加大量 JS 动画；</li>
<li>尽量使用 CSS3 动画；</li>
<li>尽量使用 canvas 动画；</li>
<li>合理使用 requestAnimationFrame 动画代替 setTimeout、setInterval;requestAnimationFrame 可以在正确的时间进行渲染.</li>
</ul>
<h2 id="合理使用缓存"><a href="#合理使用缓存" class="headerlink" title="合理使用缓存"></a>合理使用缓存</h2><ul>
<li>缓存 DOM 对象；</li>
<li>缓存列表长度；</li>
<li>使用可缓存的 Ajax；</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>simpleReact实现虚拟dom更新</title>
    <url>/2021/08/22/simpleReact%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9Fdom%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>在<a href="https://blog.wangguanwei.com/2021/08/01/%E4%B8%BASimpleReact%E6%B7%BB%E5%8A%A0%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F/" target="_blank" rel="noopener">上一篇</a>文章中，初步的实现了<strong>React的 State</strong>，本文将实现虚拟DOM的数据更新及render。</p>
<a id="more"></a>
<h2 id="vdom"><a href="#vdom" class="headerlink" title="vdom"></a>vdom</h2><p>对于 wgwCreateElement中，ElementWrapper和TextWrapper 基本上都是针对于root的操作。</p>
<h3 id="ElementWrapper"><a href="#ElementWrapper" class="headerlink" title="ElementWrapper"></a>ElementWrapper</h3><p>针对与ElementWrapper上所有的方法，可以理解为都是root这个真实dom的一个代理。</p>
<p>实现vdom虚拟dom的话，就需要将这些真实dom的代理去掉。</p>
<h4 id="创建ElementWrapper-vdom"><a href="#创建ElementWrapper-vdom" class="headerlink" title="创建ElementWrapper vdom"></a>创建ElementWrapper vdom</h4><p>主要包含三样: <code>type</code>, <code>props</code>, <code>children</code>。</p>
<ul>
<li>type 在构造函数中将type存起来；</li>
<li>props 改写当前setAttribute</li>
<li>children 改写当前children</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 为了看到vdom比较干净才这样写，后续将重构</span><br><span class="line">get vdom() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">type: this.type,</span><br><span class="line">props: this.props,</span><br><span class="line">children: this.children.map(item =&gt; item.vdom)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TextWrapper"><a href="#TextWrapper" class="headerlink" title="TextWrapper"></a>TextWrapper</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get vdom() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">type: &apos;#text&apos;,</span><br><span class="line">content: this.content</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对象上没有方法，是不能够完成dom的重绘的，需要改写vdom</p>
<h3 id="使用vdom创建一个新的dom树"><a href="#使用vdom创建一个新的dom树" class="headerlink" title="使用vdom创建一个新的dom树"></a>使用vdom创建一个新的dom树</h3><ol>
<li>去除this.root 的实dom操作;</li>
<li>vdom return this</li>
<li>在render to dom 中的创建this.root</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[REDDER_TO_DOM](range) &#123;</span><br><span class="line">range.deleteContents()</span><br><span class="line"></span><br><span class="line">let root = document.createElement(this.type) // 创建root</span><br><span class="line"></span><br><span class="line">// 插入this.props</span><br><span class="line">for(let name in this.props) &#123;</span><br><span class="line">let value = this.props[name]</span><br><span class="line"></span><br><span class="line">if(name.match(/^on([\s\S]+)/)) &#123;</span><br><span class="line">root.addEventListener(RegExp.$1.replace(/^[\s\S]/, val =&gt; val.toLowerCase()), value)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if(name === &apos;className&apos;) &#123;</span><br><span class="line">root.setAttribute(&apos;class&apos;, value)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">root.setAttribute(name, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入 this.children</span><br><span class="line">for(let child of this.children) &#123;</span><br><span class="line">let childRange = document.createRange()</span><br><span class="line">childRange.setStart(root, root.childNodes.length)</span><br><span class="line">childRange.setEnd(root, root.childNodes.length)</span><br><span class="line">childRange.deleteContents()</span><br><span class="line">child[REDDER_TO_DOM](childRange)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">range.insertNode(root)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get vdom() &#123;</span><br><span class="line">// 如果对象上没有方法，不能够完成重绘</span><br><span class="line">return this</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vdom比对"><a href="#vdom比对" class="headerlink" title="vdom比对"></a>vdom比对</h3><p>因为dom要更新，所以会使用到renderToDom函数。<br>及想要实现vdom的比对，需要在render之前进行。</p>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><ul>
<li>只对比对应位置的vdom是不是同一类型的节点</li>
<li>更高层级的修改，如两个dom的顺序调换，在真是的react中会采用更好的vdom算法，</li>
<li>此处只是为了讲解vdom的原理，不做深层次的展开</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update() &#123;</span><br><span class="line">// 只对比对应位置的vdom是不是同一类型的节点</span><br><span class="line">// 更高层级的修改，如两个dom的顺序调换，在真是的react中会采用更好的vdom算法，</span><br><span class="line">// 此处只是为了讲解vdom的原理，不做深层次的展开</span><br><span class="line"></span><br><span class="line">/***</span><br><span class="line"></span><br><span class="line">* isSameNode</span><br><span class="line">* 比较根节点是否一致，返回bool</span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* */</span><br><span class="line">  let isSameNode = (oldNode, newNode) =&gt; &#123;</span><br><span class="line">  // 类型不同</span><br><span class="line">  if(oldNode.type !== newNode.type ) return false</span><br><span class="line"></span><br><span class="line">// props 不同</span><br><span class="line">for(let name in newNode.props) &#123;</span><br><span class="line">if(newNode.props[name] !== oldNode.props[name]) return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 旧dom比新dom props多的话</span><br><span class="line">if(Object.keys(oldNode.props).length !== Object.keys(oldNode.props).length) return false</span><br><span class="line"></span><br><span class="line">// 文本节点</span><br><span class="line">if(newNode.type === &apos;#text&apos;) &#123;</span><br><span class="line">if(newNode.content !== oldNode.content) return false</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">* diff type</span><br><span class="line">* diff props</span><br><span class="line">* diff children （真实的react中，children的对比有很多种不同的diff算法，此处也不再展开,使用最土的同位置比较方法）</span><br><span class="line">* 类型为 #text 时需要对比content是否发生了更改</span><br><span class="line">  */</span><br><span class="line">  let updater = (oldNode, newNode) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">if(!isSameNode(oldNode, newNode)) &#123;</span><br><span class="line">// 新节点替换掉旧节点</span><br><span class="line">newNode[REDDER_TO_DOM](oldNode._range)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">newNode._range = oldNode._range</span><br><span class="line"></span><br><span class="line">// children中有可能放的是compoent,所以需要一个虚拟的children</span><br><span class="line">let newChildren = newNode.vchildren</span><br><span class="line">let oldChildren = oldNode.vchildren</span><br><span class="line"></span><br><span class="line">if(!newChildren || !newChildren.length) return</span><br><span class="line"></span><br><span class="line">let tailRange = oldNode.vchildren[oldNode.vchildren.length - 1]._range</span><br><span class="line"></span><br><span class="line">for(let i = 0; i &lt; newChildren.length; i++) &#123;</span><br><span class="line">let newChild = newChildren[i]</span><br><span class="line">let oldChild = oldChildren[i]</span><br><span class="line">// newChildren.len &gt; oldChildren.leng时</span><br><span class="line">if(i &lt; oldChildren.length) &#123;</span><br><span class="line">updater(oldChild, newChild)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">let range = document.createRange()</span><br><span class="line">range.setStart(tailRange.endContainer, tailRange.endOffset)</span><br><span class="line">range.setEnd(tailRange.endContainer, tailRange.endOffset)</span><br><span class="line">newChild[REDDER_TO_DOM](range)</span><br><span class="line">tailRange = range</span><br><span class="line">// todo</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let vdom = this.vdom</span><br><span class="line">updater(this.tempVdom, vdom)</span><br><span class="line"></span><br><span class="line">this.tempVdom = vdom // 至此默认为已经完成了dom的update,替换掉旧的vdom</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在真实的react中，事件是由一个事件管理中心的方式去处理的，对DOM的依赖更小，能做到更精准的去更新位置。</p>
<p>以上。写的有点着急了，后续有时间了再扩展完善。</p>
<p>完整代码仓库<a href="https://github.com/Cinaiet/toy-react" target="_blank" rel="noopener">地址</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>核心原理</tag>
      </tags>
  </entry>
  <entry>
    <title>为SimpleReact添加声明周期</title>
    <url>/2021/08/01/%E4%B8%BASimpleReact%E6%B7%BB%E5%8A%A0%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>在<a href="https://blog.wangguanwei.com/2021/07/25/JSX%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">上一篇</a>文章中，初步的实现了<strong>自定义组件</strong>，本文将补全React的State和生命周期。</p>
<a id="more"></a>
<p>在React中，我们可以认为它是由一个模板加上一个数据，来组成的我们UI。通过对数据的更改，重新使用render函数来实现UI的更改。</p>
<p><code>Ps: 气死我了，写到11点多草稿栏里没保存...</code></p>
<h2 id="state-贫血模型"><a href="#state-贫血模型" class="headerlink" title="state(贫血模型)"></a>state(贫血模型)</h2><p>其实state说起来就是一个非常简单的东西,就是一个普通的js对象，对象中存了一些数据,而这个对象中，不存在一些复杂的数据结构，如函数等..</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>setState 不但需要更改state的值本身之外，还需要启动重新render的动作。当多次setState时，它会在整个生命周期结束之后，发起一次重新的render。</p>
<p><strong>一个组件要想知道何时更新，一定是在render的环节中去得知的。</strong></p>
<p>在render函数中取root的过程，实际上就是一个真实的渲染过程。</p>
<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>在<code>Component</code>函数，<code>get root</code>函数中，如果render回来的结构是<code>Component 子类</code>,那么就会对this.root循环调用最终得到elementWraapper 或textWrapper的实例。</p>
<p>所以this.root 是与渲染所关联的关键，想要实现更新，需要添加一个私有函数。</p>
<h3 id="私有函数"><a href="#私有函数" class="headerlink" title="私有函数"></a>私有函数</h3><p>每次把<code>Component</code>创建出来，在render前，都需要调用到它的具体位置，而此时若是传入一个element，位置是不够精确的，因为我们可能在两个element中间，做重新渲染的话，dom不一定是要插入到最后的。</p>
<p>DOM API 中有一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range" target="_blank" rel="noopener">Range API</a> 可以精准的获取到对应的位置。</p>
<p>此时应由取一个元素，变化为渲染进一个range里。</p>
<ul>
<li>定义一个私有变量用于class中声明私有函数用于替换掉get root</li>
<li><p>elemenetWrapper and textWrapper 增加私有函数，render range</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// main.js</span><br><span class="line"></span><br><span class="line">  const REDDER_TO_DOM = Symbol(&apos;render to dom&apos;)</span><br><span class="line"></span><br><span class="line">  // class Component</span><br><span class="line">  [REDDER_TO_DOM](range) &#123; // 私有函数</span><br><span class="line">      // Range 接口表示一个包含节点与文本节点的一部分的文档片段。可将文本插入到指定位置</span><br><span class="line"></span><br><span class="line">      this.render()[REDDER_TO_DOM](range)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>elementWrapper appendChild 将range插入到指定位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// class elementWrapper and textWrapper add </span><br><span class="line"></span><br><span class="line">[REDDER_TO_DOM](range) &#123; // 私有函数</span><br><span class="line">    range.deleteContents()</span><br><span class="line">    range.insertNode(this.root)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // class elementWrapper </span><br><span class="line"></span><br><span class="line">  appendChild(component) &#123;</span><br><span class="line">    let range = document.createRange()</span><br><span class="line">      range.setStart(this.root, this.root.childNodes.length)</span><br><span class="line">      range.setEnd(this.root, this.root.childNodes.length)</span><br><span class="line">      range.deleteContents()</span><br><span class="line">      component[REDDER_TO_DOM](range)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改render函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function render(component, parentEle) &#123;</span><br><span class="line">  let range = document.createRange()</span><br><span class="line">  range.setStart(parentEle, 0)</span><br><span class="line">  range.setEnd(parentEle, parentEle.childNodes.length)</span><br><span class="line">  range.deleteContents()</span><br><span class="line">  component[REDDER_TO_DOM](range)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="重新绘制"><a href="#重新绘制" class="headerlink" title="重新绘制"></a>重新绘制</h2><h3 id="rerender"><a href="#rerender" class="headerlink" title="rerender"></a>rerender</h3><ul>
<li>保存range 用于重新绘制 this._range = range</li>
<li>从文档中移除range包含的内容</li>
<li>重新调用私有函数传入this._range</li>
<li>在Component 子类绑定事件中调用this.rerendeer触发重新调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// class Component</span><br><span class="line">[REDDER_TO_DOM](range) &#123; // 私有函数</span><br><span class="line">    // Range 接口表示一个包含节点与文本节点的一部分的文档片段。可将文本插入到指定位置</span><br><span class="line">    this._range = range</span><br><span class="line">    this.render()[REDDER_TO_DOM](range)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rerender() &#123;</span><br><span class="line">    this._range.deleteContents()</span><br><span class="line">    this[REDDER_TO_DOM](this._range)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加事件绑定"><a href="#添加事件绑定" class="headerlink" title="添加事件绑定"></a>添加事件绑定</h3><p>添加一个 this.state + 1 的onClick事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&#123;() =&gt; &#123;this.state.a++; this.rerender()&#125;&#125;&gt;add a ++&lt;/button&gt;s</span><br></pre></td></tr></table></figure>
<h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><p>由于当前的<code>element setAttribute</code>并没有对事件进行监听添加，所以需要对以on开头的进一步处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setAttribute(name, value) &#123;</span><br><span class="line">    if(name.match(/^on([\s\S]+)/)) &#123;</span><br><span class="line">      this.root.addEventListener(RegExp.$1.replace(/^[/s/S]/, val =&gt; val.toLowerCase()), value) // 转为小写</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.root.setAttribute(name, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在真正的React中，this.state change and rerender 的触发实际上是一个合成语句(setState)</p>
<h2 id="setState-1"><a href="#setState-1" class="headerlink" title="setState"></a>setState</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>setState 可以实现对象的合并</li>
<li>rerender也不需要再手动的去调用。</li>
</ul>
<h3 id="编写setState"><a href="#编写setState" class="headerlink" title="编写setState"></a>编写setState</h3><p>众所周知，React 数据更新是采用替换的形式去更新的。</p>
<ul>
<li>首先判断当前this.state 是否是一个对象 ?</li>
<li>case false: this.state = newState &amp;&amp; rerender() &amp;&amp; return</li>
<li>caase true: 递归遍历newState对象中的item是否存在于oldState?</li>
<li>step3 case false: oldState[item] = newState[item]</li>
<li>setp3 ccase true : 递归调用传入oldState[item] &amp;&amp; newState[item]</li>
<li>this.render()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setState(newState) &#123;</span><br><span class="line">    if(this.state === null || typeof this.state !== &apos;object&apos;) &#123;</span><br><span class="line">      // 不是一个对象时</span><br><span class="line">      this.state = newState</span><br><span class="line">      this.rerender()</span><br><span class="line">      return </span><br><span class="line">    &#125;</span><br><span class="line">    let merge = (oldState, newState) =&gt; &#123;</span><br><span class="line">      for(let item in newState) &#123;</span><br><span class="line">        if(oldState[item] === null || typeof oldState[item] !== &apos;object&apos;) &#123;</span><br><span class="line">          oldState[item] = newState[item]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          merge(oldState[item], newState[item])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    merge(this.state, newState)</span><br><span class="line">    this.rerender()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>MyComponent</code>绑定的事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&#123;() =&gt; &#123;this.setState(&#123;a: this.state.a + 1&#125;)&#125; &#125;&gt;add a ++&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>至此就完成了setState 函数的编写。</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>核心原理</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 常用命令</title>
    <url>/2025/02/17/vim/</url>
    <content><![CDATA[<p>记录一些必要的基本命令。常用命令也可在终端输入 vimtutor 查看教程。</p>
<a id="more"></a>
<h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul>
<li><code>h</code> 光标向左移动；</li>
<li><code>l</code> 光标向右移动；</li>
<li><code>j</code> 光标向下移动；</li>
<li><code>k</code> 光标向上移动；</li>
<li><code>w</code> 光标向右移动一个单词；</li>
<li><code>0</code> 将光标移动到行首；</li>
<li><code>CTRL f</code> 向下翻页；</li>
<li><code>CTRL b</code> 向上翻页；</li>
<li><code>CTRL d</code> 向上翻半页；</li>
<li><code>CTRL u</code> 向上翻半页；</li>
</ul>
<h2 id="vim-的进入和退出"><a href="#vim-的进入和退出" class="headerlink" title="vim 的进入和退出"></a>vim 的进入和退出</h2><ul>
<li><code>:q! &lt;回车&gt;</code> 不保存退出；</li>
<li><code>wq &lt;回车&gt;</code> 保存退出；</li>
</ul>
<h2 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除 "></a>删除 <a id="delete"></a></h3><ul>
<li><code>x</code> 删除单个字符；</li>
<li><code>dw</code> 可从光标出删除至一个单词的末尾，就是删除一个单词，不包含它的第一个字符；</li>
<li><code>d$</code> 从当前光标删除到行末， 及删除光标后的全部内容；</li>
<li><code>de</code> 从当前光标删除至单词末尾，包括最后一个字符；</li>
<li><code>dd</code> 删除整行</li>
</ul>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li>按 <code>i</code> 可插入文本；</li>
<li>按 <code>a</code> 可在光标后插入文本；</li>
</ul>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><ul>
<li>按 <code>A</code>可在当前段末添加文本；</li>
<li>按 <code>a</code>可在当前光标后添加文本；</li>
</ul>
<h2 id="使用计数指定动作"><a href="#使用计数指定动作" class="headerlink" title="使用计数指定动作"></a>使用计数指定动作</h2><p>在指令前输入数字会使它重复那么多次。</p>
<h3 id="计数移动"><a href="#计数移动" class="headerlink" title="计数移动"></a>计数移动</h3><ul>
<li>输入<code>2w</code>会使光标向右移动两个单词；</li>
<li>输入<code>3e</code>使光标向右移动到第三个单词的末尾；</li>
</ul>
<h3 id="计数删除"><a href="#计数删除" class="headerlink" title="计数删除"></a>计数删除</h3><p>命令同<a href="#delete">文本编辑-删除</a>，在命令中插入一个数字以删除更多；</p>
<p>如 <code>d2w</code> 删除两个单词、<code>d2d</code> 删除 2 行</p>
<h2 id="撤销类命令"><a href="#撤销类命令" class="headerlink" title="撤销类命令"></a>撤销类命令</h2><p>输入 <code>u</code>撤销最后执行的命令，<code>U</code>撤销对整行的修改, 欲撤消以前的撤消命令，恢复以前的操作结果,输入 <code>CTRL - R</code></p>
<h2 id="复制-置入类命令"><a href="#复制-置入类命令" class="headerlink" title="复制/置入类命令"></a>复制/置入类命令</h2><ul>
<li>输入 <code>p</code> 将最后一次删除的内容置入光标之后;</li>
<li>输入 <code>y</code> 复制文本，使用 <code>p</code> 粘贴文本;<br>使用 <code>v</code> 进入可视模式，移动光标选中要复制的文本，按 <code>y</code> 复制， <code>p</code> 粘贴；</li>
</ul>
<h2 id="替换类命令"><a href="#替换类命令" class="headerlink" title="替换类命令"></a>替换类命令</h2><ul>
<li>输入<code>r 和一个字符</code>替换光标所在位置的字符</li>
<li>输入 <code>R</code> 可连续替换多个字符；</li>
<li>输入 <code>:s/old/new/g</code> 可以替换 old 为 new , <code>/g</code>为全行匹配；</li>
<li>替换两行之间出现的每个匹配串<ul>
<li><code>:#,#s/old/new/g</code> 其中 <code>#,#</code>代表的是替换操作的若干行中首位两行的行号；</li>
<li><code>:%s/old/new/g</code> 是替换整个文件中的每个匹配串；</li>
<li><code>:%s/old/new/gc</code> 会找到整个文件中的每个匹配串，并且对每个匹配串提示是否进行替换；</li>
</ul>
</li>
</ul>
<h2 id="更改类命令"><a href="#更改类命令" class="headerlink" title="更改类命令"></a>更改类命令</h2><p>输入 <code>ce</code> 改变文本直到一个单词的末尾</p>
<h3 id="c-number-motaion"><a href="#c-number-motaion" class="headerlink" title="c [number] motaion"></a>c [number] motaion</h3><p>number 表示数量， motaion 表示指令，如 <code>w</code> 代表单词， <code>$</code> 代表行末</p>
<h2 id="定位及文件状态"><a href="#定位及文件状态" class="headerlink" title="定位及文件状态"></a>定位及文件状态</h2><p><code>CTRL  G</code> 显示当前编辑文件中当前光标所在位置以及文件状态信息。输入 <code>G</code> 则直接跳转到文件的某一指定行。</p>
<p><code>:number</code> 跳转至指定行</p>
<h2 id="搜索-查找"><a href="#搜索-查找" class="headerlink" title="搜索/查找"></a>搜索/查找</h2><ul>
<li><p>输入 <code>/ 加任意字符</code>可在当前文件中查找该字符串，要回到之前的位置 按 <code>CTRL  0</code>，按 <code>n</code> 切换至下一个；</p>
</li>
<li><p>输入 <code>%</code> 可以查找配对的括号 )、]、} 将光标移动到( [ { 处,按 <code>%</code>可定位至配对的括号处；</p>
</li>
<li><code>:set hls is</code> 设置搜索匹配项高亮，<code>:nohlsearch</code> 移除高亮；</li>
<li><code>:set ic</code> 搜索忽略大小写；</li>
<li><code>:set noic</code> 禁用忽略大小写；</li>
</ul>
<h2 id="vim-内执行外部命令的方法"><a href="#vim-内执行外部命令的方法" class="headerlink" title="vim 内执行外部命令的方法"></a>vim 内执行外部命令的方法</h2><ul>
<li>输入 <code>:!</code> 然后接着输入一个外部命令可以执行该外部命令；</li>
</ul>
<h2 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h2><ul>
<li><code>:w FILENAME</code> 将当前文件保存至 FILENAME 里；</li>
<li><code>v [motion] :w FILENAME</code> 移动光标至目标行，按<code>v</code>，然后移动光标选中要复制的文本，按<code>:</code>会出现<code>&#39;&lt;,&#39;&gt;</code> 之后输入文件名，按回车即可将选中内容复制到新文件里。</li>
</ul>
]]></content>
      <categories>
        <category>千百度</category>
      </categories>
      <tags>
        <tag>大千世界</tag>
      </tags>
  </entry>
  <entry>
    <title>前端“四大手写”</title>
    <url>/2020/10/08/%E5%89%8D%E7%AB%AF%E2%80%9C%E5%9B%9B%E5%A4%A7%E6%89%8B%E5%86%99%E2%80%9D/</url>
    <content><![CDATA[<p>手写 bind、深拷贝、EventHub、Promise</p>
<a id="more"></a>
<h2 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN bind 释义链接</a></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>bind 用法不难，就是把新的 this 绑定到某个函数 func 上，并返回 func 的一个拷贝。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>function.bind(thisArg[, arg1[, arg2[, …]]])</p>
<h3 id="功能点"><a href="#功能点" class="headerlink" title="功能点"></a>功能点</h3><ul>
<li>改变原函数的 this 指向，即绑定上下文，返回原函数的拷贝</li>
<li>当<strong>绑定函数</strong>被调用时，bind 的额外参数将置于实参之前传递给被绑定的方法</li>
<li>注意，一个 <strong>绑定函数</strong> 也能使用 <strong>new</strong> 操作符创建对象,这种行为就像把原函数当成构造器，thisArg 参数无效。也就是 new 操作符修改 this 指向的优先级更高。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="只使用-ES6-语法"><a href="#只使用-ES6-语法" class="headerlink" title="只使用 ES6 语法"></a>只使用 ES6 语法</h4><ul>
<li>优点：因为可以使用 const 、… 操作符，代码简洁</li>
<li>缺点：兼容性稍差，不能兼容 IE 等古老浏览器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myBind(thisArg, ...args) &#123;</span><br><span class="line">  const fn = this; // 这里的fn就是调用bind的函数 func</span><br><span class="line">  return function(...args2) &#123;</span><br><span class="line">    return fn.apply(thisArg, ...args, ...args2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="兼容-IE"><a href="#兼容-IE" class="headerlink" title="兼容 IE"></a>兼容 IE</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind = function (thisArg) &#123;</span><br><span class="line">  var fn = this</span><br><span class="line"></span><br><span class="line">  if(typeof fn !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;non function!&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var slice = Array.prototype.slice</span><br><span class="line">  var arg1 = slice.call(arguments, 1)</span><br><span class="line">  console.log(&apos;arg1&apos;, arg1)</span><br><span class="line"></span><br><span class="line">  return function() &#123;</span><br><span class="line">  var arg2 = slice.call(arguments, 0)</span><br><span class="line">  console.log(&apos;arg2&apos;, arg2)</span><br><span class="line"></span><br><span class="line">  return fn.apply(thisArg, arg1.concat(arg2))&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(name) &#123;</span><br><span class="line">this.name = name</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123;&#125;</span><br><span class="line">var bar = foo.myBind(obj, &apos;Cinaiet&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind2 = function(thisArg) &#123;</span><br><span class="line">  var fn = this</span><br><span class="line">  if(typeof fn !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new Error(&apos;non function!&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  var slice = Array.prototype.slice</span><br><span class="line">  var arg = slice.call(arguments, 1)</span><br><span class="line"></span><br><span class="line">  function resFn() &#123;</span><br><span class="line">    var arg2 = slice.call(arguments, 0)</span><br><span class="line">    return fn.apply(</span><br><span class="line">      resFn.prototype.isPrototypeOf(this) ? this : thisArg,</span><br><span class="line">      arg.concat(arg2)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resFn.prototype = fn.prototype</span><br><span class="line"></span><br><span class="line">  return resFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><h3 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h3><ul>
<li>为什么要深拷贝？ 不希望数据被修改或数据只需要部分修改</li>
<li>如何实现深拷贝？ 简单需求用 JSON 反序列化，复杂需求用递归克隆</li>
</ul>
<h3 id="JSON-反序列化"><a href="#JSON-反序列化" class="headerlink" title="JSON 反序列化"></a>JSON 反序列化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  a: &apos;asd&apos;,</span><br><span class="line">  b: &apos;vvv&apos;,</span><br><span class="line">  c: &apos;ccc</span><br><span class="line">&#125;</span><br><span class="line">const b = JSON.parse(JSON.Stringify(obj))</span><br></pre></td></tr></table></figure>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>JSON value 不支持的类型，都拷贝不了。</li>
<li>undefined、函数、循环引用、正则等都不支持。</li>
</ul>
<h3 id="递归克隆"><a href="#递归克隆" class="headerlink" title="递归克隆"></a>递归克隆</h3><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><ol>
<li>对象分类</li>
<li>递归</li>
<li>用<strong>缓存</strong>对付<strong>环</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepClone(source, wm = new WeakMap()) &#123;</span><br><span class="line">  if(!isObject(source)) return source</span><br><span class="line">  // 判断是否拷贝过当前对象</span><br><span class="line">  if(wm.has(source)) return wm.get(source)</span><br><span class="line">  let res = Array.isArray(source) ? [] : &#123;&#125;</span><br><span class="line">  wm.set(source, res)</span><br><span class="line"></span><br><span class="line">  for(let key in source) &#123;</span><br><span class="line">    if(Object.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">      if(isObject(source[key])) &#123;</span><br><span class="line">        res[key] = deepClone(source[key], wm)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        res[key] = source[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function isObject(obj) &#123;</span><br><span class="line">  return Object.prototype.toString.call(obj) === &apos;[object Object]&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="延伸-深拷贝与浅拷贝的区别"><a href="#延伸-深拷贝与浅拷贝的区别" class="headerlink" title="延伸: 深拷贝与浅拷贝的区别"></a>延伸: 深拷贝与浅拷贝的区别</h3><p>浅拷贝: 只复制一层对象的属性，复制出来的数据，指向的数据内存地址是一样的，修改任意一个都会使复制出的数据同样发生变化。</p>
<p>浅拷贝: 不仅复制原对象的属性，还会将原对象属性所包含的对象也依次采用深复制的方法递归复制到新的对象上。</p>
<h2 id="手写-EventHub-发布订阅"><a href="#手写-EventHub-发布订阅" class="headerlink" title="手写 EventHub(发布订阅)"></a>手写 EventHub(发布订阅)</h2><h3 id="核心-1"><a href="#核心-1" class="headerlink" title="核心"></a>核心</h3><ol>
<li>on 发布监听</li>
<li>emit 负责遍历查找发布的 eventName 的方法</li>
<li>remove 负责移除 eventName 及事件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CreateEventHub&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.cache = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(eventName, fn) &#123; // 添加监听</span><br><span class="line">    this.cache[eventName] = this.cache[eventName] || []</span><br><span class="line">    this.cache[eventName].push(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(eventName, data) &#123; // 执行调用</span><br><span class="line">    (this.cache[eventName] || []).forEach(fn =&gt; fn(data))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  destry(eventName, fn) &#123;</span><br><span class="line">    this.cache[eventName] = this.cache[eventName] || []</span><br><span class="line">    const index = this.cache[eventName].indexOf(fn)</span><br><span class="line">    console.log(index)</span><br><span class="line">    if(index !== -1 ) &#123;</span><br><span class="line">      this.cache[eventName].splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const eh = new CreateEventHub()</span><br><span class="line">eh.on(&apos;eventName&apos;, func)</span><br></pre></td></tr></table></figure>
<h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><h3 id="核心-2"><a href="#核心-2" class="headerlink" title="核心"></a>核心</h3><ul>
<li>new Promise(fn) fn 只能为函数，且要立即执行</li>
<li>Promise.then(res, fail) 接收的 res 和 fail 也是函数，且会在 resole(reject)被调用时才会执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  this.state = PENDDING</span><br><span class="line">  this.success = undefined</span><br><span class="line">  this.fail = undefined</span><br><span class="line">  this.onFuilfilled = []</span><br><span class="line">  this.onRejected = []</span><br><span class="line">  var _this = this</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  function resolve(success) &#123;</span><br><span class="line">    if(_this.state === PENDDING) &#123;</span><br><span class="line">      _this.state = FUlFILLED</span><br><span class="line">      _this.success = success</span><br><span class="line">      _this.onFuilfilled.forEach(func =&gt; func(success))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reject(fail) &#123;</span><br><span class="line">    if(_this.state === PENDDING) &#123;</span><br><span class="line">      _this.state = REJECTED</span><br><span class="line">      _this.success = fail</span><br><span class="line">      _this.onRejected.forEach(func =&gt; func(fail))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try&#123;</span><br><span class="line">    fn(resolve, reject)</span><br><span class="line">  &#125; catch(err) &#123;</span><br><span class="line">    reject(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = function(onFuilfilled, onRejected) &#123;</span><br><span class="line">  if(this.state === FUlFILLED) &#123;</span><br><span class="line">    typeof onFuilfilled === &apos;function&apos; &amp;&amp; onFuilfilled(this.success)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(this.state === REJECTED) &#123;</span><br><span class="line">    typeof onRejected === &apos;function&apos; &amp;&amp; onRejected(this.fail)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(this.state === PENDDING) &#123;</span><br><span class="line">    this.onFuilfilled.push(onFuilfilled)</span><br><span class="line">    this.onRejected.push(onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>一行代码实现暗黑模式</title>
    <url>/2025/08/27/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>正常实现一个完善的暗黑模式主题通常需要维护两套颜色变量，并使用 JS 控制切换。</p>
<p>但有一种方法只需要一行 CSS 就能使网站加上一个暗黑模式的主题。</p>
<a id="more"></a>
<h3 id="一行-CSS-代码"><a href="#一行-CSS-代码" class="headerlink" title="一行 CSS 代码"></a>一行 CSS 代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  filter: invert(1) hue-rotate(180deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filter-的魔力"><a href="#filter-的魔力" class="headerlink" title="filter 的魔力"></a>filter 的魔力</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter" target="_blank" rel="noopener">filter</a>属性通常是将模糊或颜色偏移等图形效果应用于元素。</p>
<p>它就像是给整个网页加上了一层滤镜。上述代码中使用了两个滤镜函数。</p>
<h4 id="invert"><a href="#invert" class="headerlink" title="invert"></a>invert<percent></percent></h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert" target="_blank" rel="noopener">invert</a> 用来反转输入图像，<percent>值为 100% 则图像完全反转。</percent></p>
<h4 id="hue-rotate"><a href="#hue-rotate" class="headerlink" title="hue-rotate"></a>hue-rotate<angle></angle></h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate" target="_blank" rel="noopener">hue-rotate</a>用来翻转输入图像，<angle>值设定图像会被调整的色环角度值。</angle></p>
<p>这个方法虽然简单但并非完美。</p>
<p>如果所示:</p>
<p><img src="/images/filter-before.jpg" alt="原图"></p>
<p><img src="/images/filter-after.jpg" alt=" 使用filter过滤后的图"></p>
<p>因为是在 html 上直接添加的属性，所以导致 image、video、iframe 等内容也会被反转。</p>
<p>最简单快捷的修复方法，就是再将他们反转一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img, video, iframe &#123;</span><br><span class="line">  filter: invert(1) hue-rotate(180deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对特定的几个标签进行单独处理以后就可以在暗黑模式下正常显示。</p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>大千世界</category>
      </categories>
      <tags>
        <tag>大千世界</tag>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试工具-Mocha</title>
    <url>/2021/06/20/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-Mocha/</url>
    <content><![CDATA[<p>项目中如果有组件/库的使用频率是比较高的，那么编写测试用例的收益也是非常高的。</p>
<a id="more"></a>
<h2 id="测试工具-Mocha"><a href="#测试工具-Mocha" class="headerlink" title="测试工具 Mocha"></a>测试工具 Mocha</h2><p>Mocha是一个功能丰富的JavaScript测试框架，运行在Node.js和浏览器上，使异步测试变得简单和有趣。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install mocha -D</span><br></pre></td></tr></table></figure>
<p>Mocha 最早是一个针对Node.js的测试框架，所以调用方式上默认使用webpack/babel之前，他都不支持export import的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var assert = require(&apos;assert&apos;); // </span><br><span class="line">describe(&apos;Array&apos;, function() &#123; // describe 分组/分目录</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function() &#123;</span><br><span class="line">    it(&apos;should return -1 when the value is not present&apos;, function() &#123;</span><br><span class="line">      assert.equal([1, 2, 3].indexOf(4), -1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>assert 中包含一些断言，如equal 相等的断言。</p>
<p>it 中编写一些单元测试用例。</p>
<h3 id="编写一个加法测试用例"><a href="#编写一个加法测试用例" class="headerlink" title="编写一个加法测试用例"></a>编写一个加法测试用例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = add</span><br><span class="line"></span><br><span class="line">test/test.js</span><br><span class="line">var assert = require(&apos;assert&apos;); // assert 中有一些断言，如equal 相等的断言</span><br><span class="line">var add = require(&apos;./../index.js&apos;);describe(&quot;add func testing&quot;, function() &#123;</span><br><span class="line">  it(&apos; 1 + 2 should be 3&apos;, function() &#123;</span><br><span class="line">    assert.equal(add(1, 2), 3);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;-5 + 2 should be -3&quot;, function() &#123;</span><br><span class="line">    assert.equal(add(-5, 2), -3);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="支持-export-import-形式的引入"><a href="#支持-export-import-形式的引入" class="headerlink" title="支持 export import 形式的引入"></a>支持 export import 形式的引入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i @babel/core @babel/register -D</span><br></pre></td></tr></table></figure>
<p>node 后续运行时所需要 require 进来的扩展名为 <code>.es6</code>、<code>.es</code>、<code>.jsx</code>、 <code>.mjs</code> 和 <code>.js</code> 的文件将由 Babel 自动转换。</p>
<h4 id="添加-babelrc"><a href="#添加-babelrc" class="headerlink" title="添加.babelrc"></a>添加.babelrc</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;@babel/preset-env&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="改写为import-export形式"><a href="#改写为import-export形式" class="headerlink" title="改写为import export形式"></a>改写为import export形式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line">export function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// test/test.js</span><br><span class="line">var assert = require(&apos;assert&apos;); // assert 中有一些断言，如equal 相等的断言</span><br><span class="line">import &#123;add, mul&#125; from &apos;./../index.js&apos;</span><br><span class="line">describe(&quot;add func testing&quot;, function() &#123;</span><br><span class="line">  it(&apos; 1 + 2 should be 3&apos;, function() &#123;</span><br><span class="line">    assert.equal(add(1, 2), 3);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  it(&quot;-5 + 2 should be -3&quot;, function() &#123;</span><br><span class="line">    assert.equal(add(-5, 2), -3);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node_modules/.bin/mocha --require @babel/register</span><br></pre></td></tr></table></figure>
<h3 id="code-coverage"><a href="#code-coverage" class="headerlink" title="code coverage"></a>code coverage</h3><p>在实际的测试用例编写中，我们可能无法清晰的知道用例是否已经全部覆盖了编写的程序，所以需要code coverage来检查程序覆盖率。</p>
<h4 id="nyc"><a href="#nyc" class="headerlink" title="nyc"></a>nyc</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i nyc -D</span><br></pre></td></tr></table></figure>
<p>nyc 和bable之间相互是无法识别的，需要安装相互间的插件</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i @istanbuljs/nyc-config-babel babel-plugin-istanbul -D</span><br></pre></td></tr></table></figure>
<h4 id="添加-nycrc文件"><a href="#添加-nycrc文件" class="headerlink" title="添加.nycrc文件"></a>添加.nycrc文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;@istanbuljs/nyc-config-babel&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改-babelrc"><a href="#修改-babelrc" class="headerlink" title="修改.babelrc"></a>修改.babelrc</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;@babel/preset-env&quot;],</span><br><span class="line">  &quot;plugins&quot;: [&quot;istanbul&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="run-1"><a href="#run-1" class="headerlink" title="run"></a>run</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nyc mocha</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>大千世界</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Web性能优化策略</title>
    <url>/2021/01/18/%E6%B5%85%E8%B0%88Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>针对不同的业务场景应使用不同的优化策略。</p>
<a id="more"></a>
<h3 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h3><h4 id="首页一级页面，采用SSR或Native的渲染方式"><a href="#首页一级页面，采用SSR或Native的渲染方式" class="headerlink" title="首页一级页面，采用SSR或Native的渲染方式"></a>首页一级页面，采用SSR或Native的渲染方式</h4><ul>
<li>客户端(浏览器)加载HTML是采用串行的形式去加载(先加载HTML，再加载CSS、JS，加载完JS之后再执行JS、解析JS去Render页面)，比较耗时。所以一级页面渲染时可交由服务端，使用Server Render的形式去渲染。</li>
<li>native渲染，可选择使用React Native、Flutter等方式去渲染。</li>
</ul>
<h4 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h4><ul>
<li>如个人中心等页面样式较为固定的，在数据为加载前可采用预渲染的形式，如loading、骨架屏、等预渲染的形式去加载。</li>
</ul>
<h3 id="弱网优化"><a href="#弱网优化" class="headerlink" title="弱网优化"></a>弱网优化</h3><h4 id="客户端离线包"><a href="#客户端离线包" class="headerlink" title="客户端离线包"></a>客户端离线包</h4><p>在弱网环境下，如3G或2G网可采用客户端提供离线包的形式。在页面第一次加载完之后，缓存到客户端本地的磁盘里面，在下一次访问时直接从本地磁盘中获取</p>
<h4 id="PWA离线缓存技术"><a href="#PWA离线缓存技术" class="headerlink" title="PWA离线缓存技术"></a>PWA离线缓存技术</h4><p>请求页面资源之后，创建Service Worker缓存页面资源，再下一次访问时从Service Worker中获取。</p>
<h3 id="Webview优化"><a href="#Webview优化" class="headerlink" title="Webview优化"></a>Webview优化</h3><ul>
<li>打开webview的同时，并行的加载页面数据。</li>
<li>也可采用缓存webview的形式。</li>
</ul>
<h3 id="HTTP性能优化"><a href="#HTTP性能优化" class="headerlink" title="HTTP性能优化"></a>HTTP性能优化</h3><h4 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h4><p>抓数据源头，提升开发服务器自身的潜力。<br>利用Nginx反向代理能力实现动静分离，动态页面交给Tomcat、Django、Rails，图片、样式表等静态资源交给 Nginx。</p>
<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><h5 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h5><p>减少服务器和客户端只见那收发的数据量，在有限的带宽里传输更多的内容。<br>使用HTTP协议内置的“数据压缩”编码，不仅可以选择标准的gzip，还可以积极尝试使用心的压缩算法br，它有更好的压缩效果。</p>
<h5 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h5><p>DNS解析域名会消耗大量的时间，所以应当适当减少域名，限制在2-3个左右，减少解析完整域名所需的时间。</p>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p>重定向引发的延迟也很好，除非必要，应当尽可能不适用重定向，或只是用Web 服务器的“内部重定向”</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>客户端控制的强缓存策略</li>
</ul>
<h3 id="降低请求成本"><a href="#降低请求成本" class="headerlink" title="降低请求成本"></a>降低请求成本</h3><ul>
<li>HTTP DNS 由客户端控制，隔一段时间主动请求DNS获取域名IP，不走系统的DNS。</li>
<li>TCP/TLS 链接复用.（服务端升级到HTTP 2.0 ）尽量合并域名。</li>
</ul>
<h3 id="减少请求次数"><a href="#减少请求次数" class="headerlink" title="减少请求次数"></a>减少请求次数</h3><ol>
<li>Js、CSS打包到HTML中</li>
<li>Js控制图片异步加载或懒加载</li>
<li>小型图片使用data-uri</li>
</ol>
<h3 id="减少传输体积"><a href="#减少传输体积" class="headerlink" title="减少传输体积"></a>减少传输体积</h3><ol>
<li>尽量使用SVG/gradient 代替图片</li>
<li>根据机型网络状况控制图片的清晰度</li>
<li>对低清晰度的图片使用锐化来提升体验</li>
<li>设计上避免大型背景图</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>平行宇宙</category>
      </categories>
      <tags>
        <tag>平行宇宙</tag>
      </tags>
  </entry>
  <entry>
    <title>工具链-Yeoman</title>
    <url>/2021/06/15/%E5%B7%A5%E5%85%B7%E9%93%BE-Yeoman/</url>
    <content><![CDATA[<p>Yeoman是一个通用的脚手架系统，允许创建任何类型的应用程序。它允许快速开始新项目，并简化现有项目的维护。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g yo // 权限不够的话需要加上sodo</span><br></pre></td></tr></table></figure>
<h2 id="编写生成器"><a href="#编写生成器" class="headerlink" title="编写生成器"></a>编写生成器</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir generator-toolchain &amp;&amp; cd generator-toolchain</span><br><span class="line">$ npm install yeoman-generator</span><br></pre></td></tr></table></figure>
<p><strong>注意: package.json 的名字需是generator-开头，否则Yeoman无法识别运行的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Generator = require(&apos;yeoman-generator&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = class extends Generator &#123;</span><br><span class="line">  // The name `constructor` is important here</span><br><span class="line">  constructor(args, opts) &#123;</span><br><span class="line">    // Calling the super constructor is important so our generator is correctly set up</span><br><span class="line">    super(args, opts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async method1() &#123;</span><br><span class="line">    // const answers = await this.prompt([</span><br><span class="line">    //   &#123;</span><br><span class="line">    //     type: &quot;input&quot;,</span><br><span class="line">    //     name: &quot;name&quot;,</span><br><span class="line">    //     message: &quot;Your project name&quot;,</span><br><span class="line">    //     default: this.appname // Default to current folder name</span><br><span class="line">    //   &#125;,</span><br><span class="line">    //   &#123;</span><br><span class="line">    //     type: &quot;confirm&quot;,</span><br><span class="line">    //     name: &quot;cool&quot;,</span><br><span class="line">    //     message: &quot;Would you like to enable the Cool feature?&quot;</span><br><span class="line">    //   &#125;</span><br><span class="line">    // ])</span><br><span class="line">    // this.log(&quot;app name&quot;, answers.name);</span><br><span class="line">    // this.log(&quot;cool feature&quot;, answers.cool);</span><br><span class="line"></span><br><span class="line">    await this.fs.copyTpl(</span><br><span class="line">      this.templatePath(&apos;t.html&apos;),</span><br><span class="line">      this.destinationPath(&apos;public/index.html&apos;),</span><br><span class="line">      &#123; title: &apos;Templating with Yeoman&apos; &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Yeoman 会顺次的执行class里面的方法</li>
<li>npm link 会将本地的模块link到npm的标准模块中去</li>
</ul>
<h3 id="Vue-脚手架生成器"><a href="#Vue-脚手架生成器" class="headerlink" title="Vue 脚手架生成器"></a>Vue 脚手架生成器</h3>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/2025/08/25/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>散列表其实就是数组的一种扩展。用的是数组下标支持随机访问数据的特性。</p>
<a id="more"></a>
<p>假设一个班级有 30 个学生，如何快速查找到每一个名字对应的人？</p>
<p>我们把这 30 个学生，按照学号把编号 1 的学生信息放到数组下标为 1 的位置，以次类推；当我们需要查找编号为 k 的学生时，只需要将数组下标为 k 的元素取出来就可以了。</p>
<p>如果学号前面还有班级信息用六位数表示，如 050301 表示五年级三班 01 号学生。这个时候查找学生就不能直接使用学号作为下标，但我们可以截取学号后两位用来作为下标来存储学生信息实现学号与数组中个人信息的的对应。</p>
<p>其中，学生的学号我们叫做<strong>键(key)</strong>，用来标识一个学生。把六位数的学号转化为下标的方法叫做<strong>散列函数</strong>，而用散列函数计算得到的值就叫做<strong>散列值(哈希值)</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hash(key) &#123;</span><br><span class="line">  return key.substring(key.length - 2, key.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><ol>
<li>散列函数计算得到的散列值是一个非负整数;<br>因为数组下标是从 0 开始的，所以散列函数生成的散列值也要是非负整数。</li>
<li>如果 key1 == key2,那么 hash(key1) == hash(key2);<br>相同的 key 经过散列函数得到的散列值也应该是相同的。</li>
<li>如果 key1 ≠ key2,那么 hash(key1) ≠ hash(key2);<br>在实际情况中，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的，即无法避免<strong>散列冲突</strong>，而且数组的存储空间有限，也会加大散列冲突的概率。</li>
</ol>
<h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>如果出现了散列冲突，我们就重新探测一个空闲位置将其插入。</p>
<h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>和线性探测很像，线性探测每次探测步长是 1，（如下标序列 hash(key) + 0, hash(key) + 1, …）而二次探测的步长是原来的二次方(如下标序列 hash(key) + 0, hash(key) + 1²， hash(key) + 0 + 2²)。</p>
<h4 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h4><p>双重散列不仅使用一个散列函数，当计算得到的存储位置已经被占用时，再用第二个散列函数，直到找到空闲的存储位置。</p>
<h4 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h4><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会提高。一般情况下，为了保证散列表的操作效率，我们会尽可能保证散列表中有一定比例的空闲槽位。用<strong>装载因子</strong>表示空位的多少。</p>
<h5 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h5><p>装载因子 = 填入表中的元素个数 / 散列表的长度</p>
<p>装载因子越大，说明空闲越少，冲突越多，散列表的性能会下降。</p>
<h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>在链表中每个位置都会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。</p>
]]></content>
      <categories>
        <category>大千世界</category>
      </categories>
      <tags>
        <tag>大千世界</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个发布系统</title>
    <url>/2021/07/04/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>使用nodejs实现一个简单的发布系统。</p>
<a id="more"></a>
<p>本文并没有从零到一构建一个完整的发布系统，仅是抛砖引玉的一个<strong>demo版本</strong></p>
<h3 id="引入HTTP模块"><a href="#引入HTTP模块" class="headerlink" title="引入HTTP模块"></a>引入HTTP模块</h3><h4 id="编写一个简单的server"><a href="#编写一个简单的server" class="headerlink" title="编写一个简单的server"></a>编写一个简单的server</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line"></span><br><span class="line">http.createServer(function(requst, response) &#123;</span><br><span class="line">  console.log(requst)</span><br><span class="line">  response.end(&apos;hello word&apos;)</span><br><span class="line">&#125;).listen(8082)</span><br></pre></td></tr></table></figure>
<h4 id="编写一个简单的request"><a href="#编写一个简单的request" class="headerlink" title="编写一个简单的request"></a>编写一个简单的request</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line"></span><br><span class="line">let requst  = http.request(&#123;</span><br><span class="line">  hostname: &apos;127.0.0.1&apos;, // 发布服务器的host</span><br><span class="line">  port: 8082</span><br><span class="line">&#125;, response =&gt; &#123;</span><br><span class="line">  console.log(response)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// http是一个流式数据的写入方式</span><br><span class="line">requst.end() // 发出请求</span><br></pre></td></tr></table></figure>
<h3 id="node-js-的流"><a href="#node-js-的流" class="headerlink" title="node.js 的流"></a>node.js 的流</h3><p><a href="http://nodejs.cn/api/stream.html" target="_blank" rel="noopener">node.js stream 官方文档</a></p>
<p><strong>流主要可以分成两个部分</strong></p>
<ol>
<li><p>可读的流 readable</p>
<ol>
<li><p><code>&#39;close&#39;</code> 事件</p>
<ul>
<li>当流或其底层资源（比如文件描述符）被关闭时触发 <code>&#39;close&#39;</code> 事件。 该事件表明不会再触发其他事件，也不会再发生操作。   2. <code>&#39;data&#39;</code> 事件</li>
<li>当流将数据块传送给消费者后触发。</li>
<li>对于一个流来说，接收某个文件流时是逐步的读取这个文件的数据出来的，根据流的定义，我们不关心这个文件每次读取了多少出来，所以<code>data</code>可能会被一次或者多次的调用</li>
</ul>
</li>
<li><p><code>&#39;end&#39;</code> 事件</p>
<ul>
<li><code>&#39;end&#39;</code> 事件只有在数据被完全消费掉后才会触发。</li>
</ul>
</li>
</ol>
</li>
<li><p>可写的流  writeable</p>
<ol>
<li><strong>write()</strong> 写入数据到流，并在数据被完全处理之后调用 <code>callback</code>。 如果发生错误，则 <code>callback</code> 可能被调用也可能不被调用。 为了可靠地检测错误，可以为 <code>&#39;error&#39;</code> 事件添加监听器。 <code>callback</code> 会在触发 <code>&#39;error&#39;</code> 之前被异步地调用。</li>
</ol>
</li>
</ol>
<h3 id="发送文件到服务"><a href="#发送文件到服务" class="headerlink" title="发送文件到服务"></a>发送文件到服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">let file = fs.createReadStream(&apos;./package.json&apos;)</span><br><span class="line"></span><br><span class="line">file.on(&apos;data&apos;, chunk =&gt; &#123;</span><br><span class="line">  console.log(chunk.toString())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">file.on(&apos;end&apos;, chunk =&gt; &#123;</span><br><span class="line">  console.log(&apos;read finished&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="服务端接收到文件之后写入指定文件"><a href="#服务端接收到文件之后写入指定文件" class="headerlink" title="服务端接收到文件之后写入指定文件"></a>服务端接收到文件之后写入指定文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http.createServer(function(requst, response) &#123;</span><br><span class="line">  console.log(requst.headers)</span><br><span class="line"></span><br><span class="line">  let outFile = fs.createWriteStream(&apos;./index.html&apos;)</span><br><span class="line">  requst.on(&apos;data&apos;, chunk =&gt; &#123;</span><br><span class="line">    outFile.write(chunk)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  requst.on(&apos;end&apos;, chunk =&gt; &#123;</span><br><span class="line">    outFile.end()</span><br><span class="line">    response.end(&apos;success&apos;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;).listen(8082)</span><br></pre></td></tr></table></figure>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ol>
<li>将server 改装成一个服务系统，用于接收和写入文件即是一个完整的发布服务。</li>
<li>当前只写到传输一个指定文件，未扩展写入多个文件/文件夹</li>
</ol>
<p>to be continued…</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>大千世界</category>
      </categories>
      <tags>
        <tag>大千世界</tag>
      </tags>
  </entry>
  <entry>
    <title>激情的消费</title>
    <url>/2019/04/29/%E6%BF%80%E6%83%85%E7%9A%84%E6%B6%88%E8%B4%B9/</url>
    <content><![CDATA[<center>不管生活是贫穷还是富裕，吃完饭，都可以来根烟。</center>

<a id="more"></a>
<hr>
<h5 id="正少年"><a href="#正少年" class="headerlink" title="正少年"></a>正少年</h5><p>前段时间许嵩2019年巡回演唱会北京场的演唱会门票预售了。是的，年少时喜欢的歌手是许嵩，结果抢票的时候，眼看着预售的倒计时变成抢票，然后进入选票页面变成缺货登记，2s不到的时间。一股焦躁与烦闷瞬间涌上心头，这特么假的吧，许嵩的歌曲虽然是大流行向，<font color="#ccc" size="3">小声哔哔但他的音乐也算小众吧，而且他也是走不出录音棚的那种，当然了，现在比以前好太多太多了。</font>而且他的粉基本上学生居多，怎么门票2s中就没了。假的吧，营销吧。玩儿呐？</p>
<p>诚然，我也清楚的知道那些只是自己没抢到票的牢骚。但满怀欣喜之后巨大失望落差产生的不甘以及不满的情绪怎么都挥散不去。</p>
<p>几日之后看到厦门某粉丝见面会的现场录播。感觉跟15年时歌友会现场差不太多，也因为工作过忙，年少追星激情消费之后，虽抱有遗憾，但也不曾后悔。</p>
<p>##### </p>
]]></content>
      <categories>
        <category>平行宇宙</category>
      </categories>
      <tags>
        <tag>大千世界</tag>
      </tags>
  </entry>
  <entry>
    <title>编写一个简易的webpack</title>
    <url>/2021/01/19/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84webpack/</url>
    <content><![CDATA[<p>simplepack</p>
<a id="more"></a>
<h3 id="编写前储备知识"><a href="#编写前储备知识" class="headerlink" title="编写前储备知识"></a>编写前储备知识</h3><h4 id="AST-abstract-syntax-tree"><a href="#AST-abstract-syntax-tree" class="headerlink" title="AST(abstract syntax tree)"></a>AST(abstract syntax tree)</h4><p>抽象语法树，或者叫语法树。是源代码的抽象语法结构的树状变现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。</p>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li><p>模板引擎<br>常见的模板引擎的实现方式有两种</p>
<ol>
<li>正则匹配</li>
<li>使用AST将模板引擎转换为字符串流、分析、render</li>
</ol>
</li>
<li>ES6 转ES5</li>
<li>TS转JS</li>
</ul>
<p><a href="https://esprima.org/demo/parse.html#" target="_blank" rel="noopener">在线Demo</a></p>
<h4 id="webpack的模块机制"><a href="#webpack的模块机制" class="headerlink" title="webpack的模块机制"></a>webpack的模块机制</h4><p><em>webpack打包之后的源码此处不再po</em></p>
<hr>
<ul>
<li>webpack打包之后函数是一个匿名闭包(立即执行)函数.</li>
<li>匿名函数中接收一个参数，该参数是一个数组，数组中的每一项为模块初始化函数</li>
<li>__webpack_require 用于加载模块，返回module.export</li>
<li>通过WEBPACK_REQUIRE_METHOD(0)启动程序</li>
</ul>
<h3 id="技术点分析"><a href="#技术点分析" class="headerlink" title="技术点分析"></a>技术点分析</h3><h4 id="ES6转换为ES5"><a href="#ES6转换为ES5" class="headerlink" title="ES6转换为ES5"></a>ES6转换为ES5</h4><ul>
<li>使用 babylon 生成AST</li>
<li>通过babel-core 将AST重新生成ES5代码</li>
</ul>
<h4 id="分析模块之间的依赖关系"><a href="#分析模块之间的依赖关系" class="headerlink" title="分析模块之间的依赖关系"></a>分析模块之间的依赖关系</h4><ul>
<li>通过babel-traverse 的importDeclaration 方法获取依赖属性</li>
</ul>
<h4 id="生成的文件能在浏览器中运行"><a href="#生成的文件能在浏览器中运行" class="headerlink" title="生成的文件能在浏览器中运行"></a>生成的文件能在浏览器中运行</h4><h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><p><a href="https://github.com/Cinaiet/simplepack" target="_blank" rel="noopener">代码地址</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/2021/06/06/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>一个简单的四则运算的解释器</p>
<a id="more"></a>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><ol>
<li>词法分析</li>
<li>语法分析</li>
<li>语义分析</li>
<li>生成中间代码</li>
<li>优化</li>
<li>生成目标代码</li>
</ol>
<p>其中，1~3只跟语言的语法有关，跟机器目标无关，所以又被称为前端，指对程序代码的分析和理解的过程。</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>如同读文章一样，文章是由一个个中文单词组成的。在程序中也一样，只不过这里不叫单词，叫“语法记号”（Token）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function main( age = 30) &#123;</span><br><span class="line">      const age = 30</span><br><span class="line">      const target = 5 + 5 * 5</span><br><span class="line">      let ret = &apos;&apos;</span><br><span class="line">      if(age &gt;= target) &#123;</span><br><span class="line">        ret = &apos;hello old man&apos;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ret = &apos;hello young man&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      return ret</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码，我们会先识别出const，let,if else 等关键字，age、target等标识符(变量)，+，=，&gt;=等操作符，这些都是token。</p>
<p>词法分析大多数情况下是使用<strong>状态机</strong>来实现的释义详见<a href="https://blog.wangguanwei.com/2021/05/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">浏览器工作原理</a></p>
<h4 id="分析规则"><a href="#分析规则" class="headerlink" title="分析规则"></a>分析规则</h4><ul>
<li><strong>识别 age 这样的标识符。</strong>以字母开头后面跟数字/字符/下划线，遇到第一个不是数字/下划线/字符时结束；</li>
<li><strong>识别 &gt;= 这样的操作符。</strong> 当识别到 &gt; 字符时，会判断下一个字符是空格/ = / &gt; 用于区分是要进入 GT (Greater Than)/ 大于等于 (Greater Equal)/ 位运算</li>
<li><strong>识别30这样的数字字面量。</strong> 当遇到非数字字符时，结束当前字面量匹配。</li>
</ul>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>语法分析就是根据语法结构，构建出一棵<strong>抽象语法树</strong>。</p>
<p>如 “我喜欢聪明又勇敢的你”。句子中包含主谓宾三个部分。根据语法结构层层拆分出一个上下级节点有关联的语法树。</p>
<h4 id="构造语法树"><a href="#构造语法树" class="headerlink" title="构造语法树"></a>构造语法树</h4><p>首先构造根节点，代表整个程序，然后向下扫描Token构建子节点且绑定父节点。可以使用stack实现（递归下降算法）。</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析就是让计算机理解我们真实地意图。</p>
<p>如“我喜欢聪明又勇敢的你”。你是谁？需要结合文本上下文才能确定具体指代的谁。</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul>
<li>计算表达式的数据类型是否统一，是否需要做转换。</li>
<li>代码块内部和外部有相同名称的变量，要用哪个？</li>
<li>在统一作用域中，检查变量唯一性，不允许有两个同名的变量。</li>
</ul>
<p>回归标题，<code>5 + 5 * 5</code>，词法定义如下：</p>
<ul>
<li>Token<ul>
<li>Number 0~9的组合</li>
<li>操作符 +、-、*、/之一</li>
<li>whitespace</li>
<li>LineTerminator</li>
</ul>
</li>
</ul>
<h3 id="产生式"><a href="#产生式" class="headerlink" title="产生式"></a>产生式</h3><p>在计算机中指Tiger编译器将源程序经过词法分析（Lexical Analysis）和语法分析（Syntax Analysis）后得到的一系列符合文法规则（Backus-Naur Form，BNF）的语句</p>
<ul>
<li>用尖括号（&lt;, &gt;）括起来的名称来表示语法结构名</li>
<li>语法结构分成基础结构和需要用其他语法结构定义的复合结构<ul>
<li>基础结构称终结符</li>
<li>复合结构称非终结符</li>
</ul>
</li>
<li>引号和中间的字符表示终结符</li>
<li>可以有括号</li>
<li>*表示重复多次</li>
<li>| 表示 “或”</li>
<li><ul>
<li>表示至少一次</li>
</ul>
</li>
</ul>
<p>由于加减乘除有优先级，所以可以理解为加法是由若干个乘法表达式再由加号或者减号链接起来的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// BNF产生式</span><br><span class="line"></span><br><span class="line">&lt;Expression&gt; ::= </span><br><span class="line">    &lt;AdditiveExpression&gt;&lt;EOF&gt;</span><br><span class="line"></span><br><span class="line">&lt;AdditiveExpression&gt; ::= </span><br><span class="line">    &lt;MultiplicativeExpression&gt;</span><br><span class="line">    |&lt;AdditiveExpression&gt;&lt;+&gt;&lt;MultiplicativeExpression&gt;</span><br><span class="line">    |&lt;AdditiveExpression&gt;&lt;-&gt;&lt;MultiplicativeExpression&gt;</span><br><span class="line"></span><br><span class="line">&lt;MultiplicativeExpression&gt; ::= </span><br><span class="line">    &lt;Number&gt;</span><br><span class="line">    |&lt;MultiplicativeExpression&gt;&lt;*&gt;&lt;Number&gt;</span><br><span class="line">    |&lt;MultiplicativeExpression&gt;&lt;/&gt;&lt;Number&gt;</span><br></pre></td></tr></table></figure>
<h3 id="四则运算表达式运算"><a href="#四则运算表达式运算" class="headerlink" title="四则运算表达式运算"></a>四则运算表达式运算</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Expression(source)&#123;</span><br><span class="line">    if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;EOF&quot; ) &#123;</span><br><span class="line">        let node = &#123;</span><br><span class="line">            type:&quot;Expression&quot;,</span><br><span class="line">            children:[source.shift(), source.shift()]</span><br><span class="line">        &#125;</span><br><span class="line">        source.unshift(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">    AdditiveExpression(source);</span><br><span class="line">    return Expression(source);</span><br><span class="line">&#125;</span><br><span class="line">function AdditiveExpression(source)&#123;</span><br><span class="line">    if(source[0].type === &quot;MultiplicativeExpression&quot;) &#123;</span><br><span class="line">        let node = &#123;</span><br><span class="line">            type:&quot;AdditiveExpression&quot;,</span><br><span class="line">            children:[source[0]]</span><br><span class="line">        &#125;</span><br><span class="line">        source[0] = node;</span><br><span class="line">        return AdditiveExpression(source);</span><br><span class="line">    &#125; </span><br><span class="line">    if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;+&quot;) &#123;</span><br><span class="line">        let node = &#123;</span><br><span class="line">            type:&quot;AdditiveExpression&quot;,</span><br><span class="line">            operator:&quot;+&quot;,</span><br><span class="line">            children:[]</span><br><span class="line">        &#125;</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        MultiplicativeExpression(source);</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        source.unshift(node);</span><br><span class="line">        return AdditiveExpression(source);</span><br><span class="line">    &#125;</span><br><span class="line">    if(source[0].type === &quot;AdditiveExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;-&quot;) &#123;</span><br><span class="line">        let node = &#123;</span><br><span class="line">            type:&quot;AdditiveExpression&quot;,</span><br><span class="line">            operator:&quot;-&quot;,</span><br><span class="line">            children:[]</span><br><span class="line">        &#125;</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        MultiplicativeExpression(source);</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        source.unshift(node);</span><br><span class="line">        return AdditiveExpression(source);</span><br><span class="line">    &#125;</span><br><span class="line">    if(source[0].type === &quot;AdditiveExpression&quot;)</span><br><span class="line">        return source[0];</span><br><span class="line">    MultiplicativeExpression(source);</span><br><span class="line">    return AdditiveExpression(source);</span><br><span class="line">&#125;</span><br><span class="line">function MultiplicativeExpression(source)&#123;</span><br><span class="line">    if(source[0].type === &quot;Number&quot;) &#123;</span><br><span class="line">        let node = &#123;</span><br><span class="line">            type:&quot;MultiplicativeExpression&quot;,</span><br><span class="line">            children:[source[0]]</span><br><span class="line">        &#125;</span><br><span class="line">        source[0] = node;</span><br><span class="line">        return MultiplicativeExpression(source);</span><br><span class="line">    &#125; </span><br><span class="line">    if(source[0].type === &quot;MultiplicativeExpression&quot; &amp;&amp; source[1] &amp;&amp; source[1].type === &quot;*&quot;) &#123;</span><br><span class="line">        let node = &#123;</span><br><span class="line">            type:&quot;MultiplicativeExpression&quot;,</span><br><span class="line">            operator:&quot;*&quot;,</span><br><span class="line">            children:[]</span><br><span class="line">        &#125;</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        source.unshift(node);</span><br><span class="line">        return MultiplicativeExpression(source);</span><br><span class="line">    &#125;</span><br><span class="line">    if(source[0].type === &quot;MultiplicativeExpression&quot;&amp;&amp; source[1] &amp;&amp; source[1].type === &quot;/&quot;) &#123;</span><br><span class="line">        let node = &#123;</span><br><span class="line">            type:&quot;MultiplicativeExpression&quot;,</span><br><span class="line">            operator:&quot;/&quot;,</span><br><span class="line">            children:[]</span><br><span class="line">        &#125;</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        node.children.push(source.shift());</span><br><span class="line">        source.unshift(node);</span><br><span class="line">        return MultiplicativeExpression(source);</span><br><span class="line">    &#125;</span><br><span class="line">    if(source[0].type === &quot;MultiplicativeExpression&quot;)</span><br><span class="line">        return source[0];</span><br><span class="line"></span><br><span class="line">    return MultiplicativeExpression(source);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var source = [&#123;</span><br><span class="line">    type:&quot;Number&quot;,</span><br><span class="line">    value: &quot;5&quot;</span><br><span class="line">&#125;, </span><br><span class="line">&#123;</span><br><span class="line">    type:&quot;+&quot;,</span><br><span class="line">    value: &quot;+&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    type:&quot;Number&quot;,</span><br><span class="line">    value: &quot;5&quot;</span><br><span class="line">&#125;, </span><br><span class="line">&#123;</span><br><span class="line">    type:&quot;*&quot;,</span><br><span class="line">    value: &quot;*&quot;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    type:&quot;Number&quot;,</span><br><span class="line">    value: &quot;5&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    type:&quot;EOF&quot;</span><br><span class="line">&#125;];</span><br><span class="line">var ast = Expression(source);</span><br><span class="line"></span><br><span class="line">console.log(ast);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function evaluate(node) &#123;</span><br><span class="line">    if(node.type === &quot;Expression&quot;) &#123;</span><br><span class="line">        return evaluate(node.children[0])</span><br><span class="line">    &#125;</span><br><span class="line">    if(node.type === &quot;AdditiveExpression&quot;) &#123;</span><br><span class="line">        if(node.operator === &apos;-&apos;) &#123;</span><br><span class="line">            return evaluate(node.children[0]) - evaluate(node.children[2]);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.operator === &apos;+&apos;) &#123;</span><br><span class="line">            return evaluate(node.children[0]) + evaluate(node.children[2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return evaluate(node.children[0])</span><br><span class="line">    &#125;</span><br><span class="line">    if(node.type === &quot;MultiplicativeExpression&quot;) &#123;</span><br><span class="line">        if(node.operator === &apos;*&apos;) &#123;</span><br><span class="line">            return evaluate(node.children[0]) * evaluate(node.children[2]);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.operator === &apos;/&apos;) &#123;</span><br><span class="line">            return evaluate(node.children[0]) / evaluate(node.children[2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return evaluate(node.children[0])</span><br><span class="line">    &#125;</span><br><span class="line">    if(node.type === &quot;Number&quot;) &#123;</span><br><span class="line">        return Number(node.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const aaa = evaluate(ast)</span><br><span class="line">console.log(aaa)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>核心原理</tag>
      </tags>
  </entry>
  <entry>
    <title>解决跨域问题的几种方式</title>
    <url>/2017/07/23/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>首先，非常感谢<a href="http://blog.zhanghuiliang.cn" target="_blank" rel="noopener">阿亮</a>在这一问题的处理上教予我的多种解决方案，有不足之处，望指正。</p>
<p>关于ajax跨域问题，相信是老生常谈的话题了。处理跨域问题的方法也有很多。既然要说一种全新的解决跨域问题的方法，首先要说的就是<strong>什么是跨域，为什么会存在跨域的问题。</strong></p>
<a id="more"></a>
<h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>跨域问题之所以存在，是因为有同源策略的存在，所谓同源策略，就是协议、域名、端口号三者必须相同。</p>
<pre><code>- 举个栗子
- http:// www . google : 8080 / script/jquery.js
- http://（协议号）
- www    （子域名）
- google （主域名）
- 8080   （端口号）
</code></pre><p>这是一种约定，在各浏览器之间，执行脚本的时候检测脚本是来自哪一方，只有同源的脚本才能正常执行。这就是跨域问题的存在。</p>
<h3 id="跨域问题的几种解决办法及优劣"><a href="#跨域问题的几种解决办法及优劣" class="headerlink" title="跨域问题的几种解决办法及优劣"></a>跨域问题的几种解决办法及优劣</h3><h4 id="flash-URLLoader插件"><a href="#flash-URLLoader插件" class="headerlink" title="flash URLLoader插件"></a>flash URLLoader插件</h4><p>flash有一套自己的安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。</p>
<p><strong>缺点:</strong> 这种方法相比较来说比较古老，而且不能够实现iOS跨域。</p>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><pre><code>利用文本对象模型来解决跨域的问题。
</code></pre><h4 id="图像PING"><a href="#图像PING" class="headerlink" title="图像PING__"></a>图像PING__</h4><p>比如说<strong>img</strong>标签，它有一个src属性，该属性下的图片可以是一个HTTP:// … .jpg的图片，实际上这已经是跨域操作了，但该src下既然可以放一个图片，思维放大一些，是不是也可以 .html？ 或许会出现一个裂的图片格式，但再在脚本里用DOM createElement一个img元素，onerror抛出异常，onload加载出页面。（有兴趣的童鞋可以试一下，没毛病。）</p>
<p>同理，既然img标签可以，那么iframe，link，script这些标签是不是也可以实现呢？答案是肯定的。利用script标签，就有了下面要说的<strong>JSONP</strong>。</p>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>也许有同学会问了，因为同源策略，非同源的脚本文件是阻止加载的，那为什么还会有利用script脚本来解决跨域的？这页正是JSONP的秘密所在。</p>
<p>首先，JSONP的基本原理就是利用script的历史遗迹（没有跨域限制）来实现的。<br>要解决跨域问题时，在本站script中创建一个地址指向第三方的API网址，并提供一个回调函数来指向接收的数据，这样本站就可以解析callback函数传递并解析数据了。</p>
<p><strong>缺点 : </strong> 上述几种方法，都只能用于get请求不能用于post，且也不能传递cookie。</p>
<h4 id="Cors"><a href="#Cors" class="headerlink" title="Cors"></a>Cors</h4><p>通过设置access-Control-allow-origin.简单来说，就是将需要的请求放在请求头，使用自定义的HTTP头部让浏览器进行沟通，只需要处理onerror和onload来确定失败或是成功。请求头是多个的，所以可以有效的解决跨域问题。</p>
<p><strong>缺点 :</strong>  不能传递cookie。</p>
<pre><code>下面说的这种方法，个人感觉不但可以完美的解决跨域问题（或者说都不存在跨域问题）.
而且无论是get还是post请求都可以，当然了，cookie也是可以传递的。
</code></pre><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><pre><code>反向代理，是指以代理服务器来接收internet上的链接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求链接的客户端。

我用反向代理是借用的nginx服务器。下面就是服务器的配置了。
</code></pre><p><strong>注意代码缩进。</strong></p>
<pre><code>&gt;  location /ltf/{ #代理
    proxy_pass http://192.168.199.241:80/php-h5/v1.0/;
    proxy_redirect off;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
</code></pre>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义Hooks</title>
    <url>/2022/11/04/%E8%87%AA%E5%AE%9A%E4%B9%89Hooks/</url>
    <content><![CDATA[<p>要用好 React Hooks 有一点很重要，就是要能够从 Hooks 的角度去思考问题。在做功能开发时，首先问自己一个问题：<strong>这个功能中的哪些逻辑可以抽成独立的 Hooks</strong>。</p>
<a id="more"></a>
<p>之所以要抽离成独立的 hooks,会有助于代码模块化和解耦，便于后期维护。</p>
<h3 id="如何创建自定义-Hooks"><a href="#如何创建自定义-Hooks" class="headerlink" title="如何创建自定义 Hooks"></a>如何创建自定义 Hooks</h3><p>自定义 Hooks 的创建其实很简单，就是<strong>声明一个以 use 开头的函数</strong>，如 useCounter。<br>这个函数在形式上和普通的函数没有任何区别，可以接收入参，也可以有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useCounter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加</span></span><br><span class="line">  <span class="keyword">const</span> plus = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 减</span></span><br><span class="line">  <span class="keyword">const</span> minus = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count - <span class="number">1</span>);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reset = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(<span class="number">0</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    plus,</span><br><span class="line">    minus,</span><br><span class="line">    reset,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(useCounter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了这个hook 就可以在业务组件中使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// temp.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useCounter &#125; <span class="keyword">from</span> <span class="string">'@/components/useCustom'</span>;</span><br><span class="line"></span><br><span class="line">type TempCompType = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> TempComp: React.FC&lt;TempCompType&gt; = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, plus, minus, reset &#125; = useCounter();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ggg'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button onClick=&#123;plus&#125;&gt;plus&lt;/</span>Button&gt;</span><br><span class="line">        &lt;Button onClick=&#123;minus&#125;&gt;minus&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button onClick=&#123;reset&#125;&gt;reset&lt;/</span>Button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TempComp;</span><br></pre></td></tr></table></figure>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>单独抽离为 Hooks，可以更方便使得逻辑复用，也能让代码更加语义化，便于理解和维护。</strong></li>
<li>名字以 use 开头，这样可以使 React 知道这是一个 Hook</li>
<li>函数内部一定调用了其它的 Hooks,可以使内置 hooks，也可以是自定义 hooks。只有这样才能使组件刷新。</li>
</ul>
<h3 id="封装通用逻辑"><a href="#封装通用逻辑" class="headerlink" title="封装通用逻辑"></a>封装通用逻辑</h3><p>比如在日常开发中，<strong>发起异步请求并在页面上显示</strong>，是非常常见的需求，在这个过程中不仅要关心请求是否正确返回，也要兼顾 pendding 状态下页面上的 loading 呈现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// useAsync.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@params </span>asyncFn 接收一个发出接口请求的promise函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useAsync = <span class="function">(<span class="params">asyncFn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>); <span class="comment">// 页面loading状态</span></span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(<span class="literal">null</span>); <span class="comment">// 请求成功拿到的res</span></span><br><span class="line">  <span class="keyword">const</span> [err, setErr] = useState(<span class="literal">null</span>);  <span class="comment">// 请求失败拿到的error</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> execute = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>);</span><br><span class="line">    setData(<span class="literal">null</span>);</span><br><span class="line">    setErr(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> asyncFn()</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        setData(res.data);</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">        setErr(error);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [asyncFn]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; execute, loading, data, err &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// xxx.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useAsync &#125; <span class="keyword">from</span> <span class="string">'@/components/useAsync'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; querySysAiListService &#125; <span class="keyword">from</span> <span class="string">'./../../services/query'</span>;</span><br><span class="line"></span><br><span class="line">type TempCompType = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> TempComp:React.FC&lt;TempCompType&gt; = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;data, loading&#125; = useAsync()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        loading ? &lt;div&gt;loading...&lt;/div&gt; : &lt;div&gt;</span><br><span class="line">          &#123;data.map(item =&gt; &#123;</span><br><span class="line">            return (&lt;div&gt;item.name&lt;/div&gt;)</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上述例子可以看到，使用 useAsync <strong>可以很好的将组件中的某一部分分离出去，从而实现通用逻辑的重用。</strong></p>
<h3 id="拆分复杂组件"><a href="#拆分复杂组件" class="headerlink" title="拆分复杂组件"></a>拆分复杂组件</h3><p>当某个组件功能越来越复杂的时候，我们会发现组件代码会变的非常长，超过 500-1000 行，甚至更多，这个时候就会变的非常难维护。</p>
<p>所以<strong>保持每个函数的短小</strong>就成了函数组件的最佳实践。尽量将相关的逻辑做成独立的 Hooks,然后在函数组件中使用这些 Hooks,通过参数传递和返回值让 Hooks 之间完成交互。</p>
<p>注意：<strong>拆分 Hooks 的目的并一定是逻辑复用，也可以仅仅是业务逻辑的隔离</strong>。</p>
<p>举个例子，我们需要展示一个文章列表并且支持筛选。后端提供两个接口，分别获取文章列表和文章分类，根据文章类别展示文章列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 获取文章分类...</span></span><br><span class="line">  <span class="comment">// 获取文章列表...</span></span><br><span class="line">  <span class="comment">// 组合数据...</span></span><br><span class="line">  <span class="comment">// 根据条件筛选文章...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useCallback, useEffect, useMemo, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Select &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useAsync &#125; <span class="keyword">from</span> <span class="string">'@/components/useAsync'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; queryArticleSercice, queryCategriesService &#125; <span class="keyword">from</span> <span class="string">'./services/query'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useQueryArticle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    data: articleList,</span><br><span class="line">    execute,</span><br><span class="line">    err: articleErr,</span><br><span class="line">  &#125; = useAsync(</span><br><span class="line">    useCallback(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> queryArticleSercice();</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;, []),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> execute(), [execute]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    articleList,</span><br><span class="line">    articleErr,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useQueryCategries = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    data: categriesList,</span><br><span class="line">    execute,</span><br><span class="line">    err: categriesErr,</span><br><span class="line">  &#125; = useAsync(</span><br><span class="line">    useCallback(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> queryCategriesService();</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;, []),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> execute(), [execute]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    categriesList,</span><br><span class="line">    categriesErr,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useCombineList = <span class="function">(<span class="params">articleList, categriesList</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!articleList || !categriesList) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">return</span> articleList.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        category: categriesList.find(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub.id === item.category),</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [articleList, categriesList]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useFilterArticleList = <span class="function">(<span class="params">articleList, filterVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> articleList.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      item.category.name === filterVal;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [articleList, filterVal]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type TempCompType = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> TempComp: React.FC&lt;TempCompType&gt; = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取文章分类...</span></span><br><span class="line">  <span class="comment">// 获取文章列表...</span></span><br><span class="line">  <span class="comment">// 组合数据...</span></span><br><span class="line">  <span class="comment">// 根据条件筛选文章...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [filterVal, setFilterVal] = useState(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; articleList &#125; = useQueryArticle(); <span class="comment">// 获取文章列表</span></span><br><span class="line">  <span class="keyword">const</span> &#123; categriesList &#125; = useQueryCategries(); <span class="comment">// 获取文章分类</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> combineList = useCombineList(articleList, categriesList); <span class="comment">// 组合数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ret = useFilterArticleList(combineList, filterVal);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> categriesList.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        label: item.name,</span><br><span class="line">        value: item.value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [categriesList]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!ret) <span class="keyword">return</span> <span class="string">"loading dom..."</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Select</span><br><span class="line">        value=&#123;filterVal&#125;</span><br><span class="line">        onChange=&#123;(value) =&gt; setFilterVal(value)&#125;</span><br><span class="line">        options=&#123;options&#125;</span><br><span class="line">        placeholder=<span class="string">"选择分类"</span></span><br><span class="line">      &gt;&lt;<span class="regexp">/Select&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;ret.length &amp;&amp;</span></span><br><span class="line"><span class="regexp">          ret.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            return (</span></span><br><span class="line"><span class="regexp">              &lt;div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;span&gt;文章名称:&#123;item.name&#125;&lt;/</span>span&gt;</span><br><span class="line">                &lt;span&gt;文章分类:&#123;item.category.name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>div&gt;</span><br><span class="line">            );</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TempComp;</span><br></pre></td></tr></table></figure>
<p>这样我们就把一个较为复杂的 hooks 拆分为了一个个独立的 hooks。隔离了业务，语义也更明确。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
        <tag>重学React</tag>
      </tags>
  </entry>
  <entry>
    <title>Hooks的使用及思考</title>
    <url>/2022/11/03/Hooks%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="为什么要用-Hooks"><a href="#为什么要用-Hooks" class="headerlink" title="为什么要用 Hooks"></a>为什么要用 Hooks</h2><p>其实在类组件时代时，已经有了函数组件的雏形。但是有一个局限，就是函数组件无法存在内部状态，必须是纯函数，而且无法提供完整的生命周期。<strong>故使用了 Class 作为组件。</strong></p>
<hr>
<a id="more"></a>
<h3 id="使用-Class-组件的缺点"><a href="#使用-Class-组件的缺点" class="headerlink" title="使用 Class 组件的缺点"></a>使用 Class 组件的缺点</h3><ul>
<li><strong>没有用到 Class 的继承特性。</strong>当使用 class 组件作为载体时，会发现<strong>React 组件之间是不会互相继承的。</strong> 如创建了一个 Button 组件,再创建组件 DropdownButton 时不会继承 Button。</li>
<li><strong>因为所有 UI 都是由状态驱动的，因此很少会在外部去调用一个类的实例方法。</strong> 因为 Class 组件的所有方法都是在内部函数或者被作为生命周期调用的。</li>
</ul>
<h3 id="Hooks-的诞生"><a href="#Hooks-的诞生" class="headerlink" title="Hooks 的诞生"></a>Hooks 的诞生</h3><p>函数和对象不同，函数不能够在多次执行之间还能保存状态，所以就需要一个函数之外的空间来保存这个状态（如 15.x 版本时使用 Class），并且要能检测其状态的变化，从而能触发函数组件的重新渲染。</p>
<p>也就是说需要一个机制，把外部的数据绑定到函数的执行。当数据变化时，函数能够重新自动执行。</p>
<p>这个机制，就是 Hooks.</p>
<p>Hook 就是”钩子”的意思。在 React 中，Hooks 就是<strong>把某个目标结果钩到某个可能会变化的数据源或事件源上，当数据或事件发生变化时，产生这个目标结果的代码会重新执行，产生更新。</strong></p>
<h3 id="Hooks-优点"><a href="#Hooks-优点" class="headerlink" title="Hooks 优点"></a>Hooks 优点</h3><ul>
<li>简化逻辑复用<br>如根据浏览器的宽度，重新调整布局。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getSize = () =&gt; &#123;</span><br><span class="line">  return window.innerWidth &gt; 1000 ? &quot;large&quot; : &quot;small&quot;;</span><br><span class="line">&#125;</span><br><span class="line">const useWindowSize = () =&gt; &#123;</span><br><span class="line">  const [size, setSize] = useState(getSize());</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">  const handler = () =&gt; &#123;</span><br><span class="line">      setSize(getSize())</span><br><span class="line">    &#125;;</span><br><span class="line">    window.addEventListener(&apos;resize&apos;, handler);</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      window.removeEventListener(&apos;resize&apos;, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const Demo = () =&gt; &#123;</span><br><span class="line">  const size = useWindowSize();</span><br><span class="line">  if (size === &quot;small&quot;) return &lt;SmallComponent /&gt;;</span><br><span class="line">  else return &lt;LargeComponent /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而在类组件中，我们就需要实现一个高阶函数去判断 size 值，然后走不同的业务逻辑。</p>
<ul>
<li>有助于关注分离</li>
</ul>
<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>useState 让函数组件具有维持状态的能力。</p>
<ol>
<li>useState(params) 的参数 params 是创建 state 时的初始值，可以是任意类型，bool,string,number, obj 等。</li>
<li>useState()的返回值，是有着两个元素的数组，第一个用于读取当前定义的 state 的值，第二个用来设置当前 state 的值。</li>
<li>如果要创建多个 state，则需要多次调用 useState。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [loading, setLoading] = useState(false)</span><br><span class="line">const [age, setAge] = useState(&apos;18&apos;)</span><br><span class="line">const [arr, setArr] = useState([&#123;temp： 1&#125;])</span><br></pre></td></tr></table></figure>
<h3 id="state-的最佳实践"><a href="#state-的最佳实践" class="headerlink" title="state 的最佳实践"></a>state 的最佳实践</h3><p><strong>state 不要保存可以通过计算得到的值。一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂。</strong></p>
<ul>
<li>从 URL 中获取到的值，不建议读取出来之后放 state 里。</li>
<li>从 cookie、localStorage 等获取到的值，建议每次使用时直接读取，不建议放入 state 里。</li>
<li>从 props 传递过来的值，不能直接使用，需要经过计算或转换之后才能在 UI 上展示，不建议直接放到 state 里。</li>
</ul>
<h2 id="useEffect-执行副作用"><a href="#useEffect-执行副作用" class="headerlink" title="useEffect 执行副作用"></a>useEffect 执行副作用</h2><p>useEffect(callback, dependencies)接受两个参数。</p>
<p>@callback 为要执行的函数<br>@dependencies 可选依赖项，如果不指定，那么 callback 就会在每次函数组件执行完之后执行。如果指定了，则只有依赖项中的值发生变化时候 callback 才会执行。</p>
<p>对应到 Class 组件，useEffect 涵盖了 <code>ComponentDidMount</code> <code>componentDidUpdate</code> <code>componentWillUnmount</code>三个生命周期方法。</p>
<h3 id="useEffect-模拟生命周期"><a href="#useEffect-模拟生命周期" class="headerlink" title="useEffect 模拟生命周期"></a>useEffect 模拟生命周期</h3><h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h4><p>当 useEffect 的第二个参数为空时，就是函数组件加载完成时执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    // do something...</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
<h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h4><p>当 useEffect 的第二个参数有值时，即监听依赖项中的值发生变化时，会触发 callback.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    // 当id发生变化时会重新触发该函数</span><br><span class="line">    // do something...</span><br><span class="line">&#125;, [id])</span><br></pre></td></tr></table></figure>
<h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h4><p>当 useEffect(callback) callback 中有返回函数时，将会用于组件销毁时做一些清理的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TempCom:React.FC = () =&gt; &#123;</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        // do anything...</span><br><span class="line"></span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">             //  组件销毁时重新 do something...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四种不同的时机执行一个回调产生的副作用"><a href="#四种不同的时机执行一个回调产生的副作用" class="headerlink" title="四种不同的时机执行一个回调产生的副作用"></a>四种不同的时机执行一个回调产生的副作用</h4><ol>
<li>useEffect(() =&gt; {}) 每次 render 后执行 callback</li>
<li>useEffect(() =&gt; {}, []) 仅第一次 render 后执行 callback</li>
<li>useEffect(() =&gt; {}, [deps]) 当 deps 发生变化后执行 callback</li>
<li>useEffect(() =&gt; {return () =&gt; {}}, []) 组件 unmount 后执行。</li>
</ol>
<h3 id="useEffect-最佳实践"><a href="#useEffect-最佳实践" class="headerlink" title="useEffect 最佳实践"></a>useEffect 最佳实践</h3><ol>
<li>在 useEffect 的回调函数中使用的变量，都必须在依赖项中声明；</li>
<li>不能出现在条件语句或循环中，也不能出现在 return 后；</li>
<li>只能在函数组件或自定义 Hooks 中使用。</li>
</ol>
<h2 id="useCallback-缓存回调函数"><a href="#useCallback-缓存回调函数" class="headerlink" title="useCallback 缓存回调函数"></a>useCallback 缓存回调函数</h2><p>在函数组件中，每一次 UI 的变化都需要重新执行整个函数来完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function CounterComp () &#123;</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    const countPlus = setCount(count + 1)</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;button onClick=&#123;countPlus&#125;&gt;Add  &#123;count&#125;&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，在 button 上添加了一个<code>countPlus</code>事件，用来让计数器加 1.但是因为<code>countPlus</code>事件是定义在函数组件内部，所以在函数组件每次渲染时无法重用<code>countPlus</code>函数，而是每次都需要重新创建一个。<br>而每次接收到新创建的函数，都会让接收事件处理函数的组件重新渲染。</p>
<p><strong>只有当 count 发生变化时，我们才需要重新定一个回调函数。</strong> 而这正是<strong>useCallback</strong> Hook 的作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// tempComp.tsx</span><br><span class="line"></span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const TempComp: React.FC&lt;any&gt; = (props) =&gt; &#123;</span><br><span class="line">  console.log(&apos;temp component----&gt;&gt;&gt;&gt;&apos;, props);</span><br><span class="line">  const &#123; clickEvent &#125; = props;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick=&#123;clickEvent&#125;&gt;number&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default React.memo(TempComp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parent.tsx</span><br><span class="line"></span><br><span class="line">import React, &#123;useState, useCallback&#125; from &apos;react&apos;</span><br><span class="line">import TempComp from &apos;./TempComp&apos;</span><br><span class="line"></span><br><span class="line">const ParentComp:React.FC&lt;any&gt; =() =&gt; &#123;</span><br><span class="line">      const [count, setCount] = useState&lt;number&gt;(1);</span><br><span class="line"></span><br><span class="line">const clickEvent = useCallback(() =&gt; &#123;</span><br><span class="line">    setCount(count + 1);</span><br><span class="line">&#125;, [count]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return (&lt;&gt;</span><br><span class="line">    &lt;TempComp clickEvent=&#123;clickEvent&#125;&gt;&lt;/TempComp&gt;</span><br><span class="line"></span><br><span class="line">&lt;/&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="useCallback-最佳实践"><a href="#useCallback-最佳实践" class="headerlink" title="useCallback 最佳实践"></a>useCallback 最佳实践</h3><ul>
<li>useCallback 需与<strong>React.memo</strong>配合使用。</li>
</ul>
<h2 id="useMemo-缓存计算的结果"><a href="#useMemo-缓存计算的结果" class="headerlink" title="useMemo 缓存计算的结果"></a>useMemo 缓存计算的结果</h2><p>如果某个数据是通过其它数据计算得到的，那么只有当依赖的数据发生变化时，才应该重新进行计算。</p>
<p>useMemo(callback, deps)</p>
<ul>
<li>@callback 回调函数</li>
<li>@deps arrary 要监听的值，当 deps 发生改变时会重新触发 callback</li>
</ul>
<p>举个例子，对于某个用户列表，根据搜索条件展示过滤后的用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; useMemo, useEffect &#125; from &apos;React&apos;</span><br><span class="line"></span><br><span class="line">const FilterComp:React.FC&lt;any&gt; = () =&gt; &#123;</span><br><span class="line">    const [userList， setUserList] = useState([])</span><br><span class="line">    const [filterVal, setFilterVal] = useState(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        fetch(&apos;query/user/list&apos;).then(res =&gt; &#123;</span><br><span class="line">            setUserList(res.data.userList)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line">    let filterList = []</span><br><span class="line"></span><br><span class="line">    if(userList.length) &#123;</span><br><span class="line">    // 此处无论组件因为什么原因刷新重新执行，都会触发重新计算</span><br><span class="line">        filterList = userList.filter(item =&gt; &#123;</span><br><span class="line">            return item.name.includes(filterVal)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; value=&#123;filterVal&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            filterList.length &amp;&amp; filterList.map(item =&gt; &#123;</span><br><span class="line">                return (&lt;div&gt;&#123;item.name&#125;&lt;/div&gt;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，组件如果需要重新渲染的话，只需要 filterVal 或 userList 发生变化之后再重新计算渲染。<strong>使用 useMemo,可以避免不必要的重复计算和渲染。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filterList = useMemo(() =&gt; &#123;</span><br><span class="line">    return userList.filter(item =&gt; &#123;</span><br><span class="line">        item.name.includes(filterVal)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, [filterVal, userList])</span><br></pre></td></tr></table></figure>
<h3 id="useMemo-和-useCallback-的区别"><a href="#useMemo-和-useCallback-的区别" class="headerlink" title="useMemo 和 useCallback 的区别"></a>useMemo 和 useCallback 的区别</h3><ul>
<li>useMemo 缓存的结果是回调函数中 return 回来的值，主要用于缓存计算结果的值。</li>
<li>useCallback 缓存的结果是函数，主要用于函数缓存。因为函数组件任何 state 的变化，都会触发整个组件的更新，而有的函数是没必要更新的，缓存起来避免资源浪费。需配合 React.memo 一起使用。</li>
</ul>
<h2 id="useRef-在多次渲染之间共享数据"><a href="#useRef-在多次渲染之间共享数据" class="headerlink" title="useRef 在多次渲染之间共享数据"></a>useRef 在多次渲染之间共享数据</h2><h3 id="共享值"><a href="#共享值" class="headerlink" title="共享值"></a>共享值</h3><p>我们可以把 useRef 看做是在函数组件外创建一个容器控件，在这个容器控件上通过设置 current 属性值，从而在函数组件的多次渲染间共享这个值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React , &#123;useState, useEffect, useRef, useCallback&#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">const DelayTimer:React.FC&lt;any&gt; = () =&gt; &#123;</span><br><span class="line">    cont [time, setTime] = useState&lt;number&gt;(0);</span><br><span class="line">    // 定义一个timer容器存储跨组件变量</span><br><span class="line">    let timer = useRef(null)</span><br><span class="line"></span><br><span class="line">    const startTimeHandle = useCallback(() =&gt; &#123;</span><br><span class="line">        timer.current = setInterval(() =&gt; &#123;</span><br><span class="line">            setTime((time) =&gt; time +1)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line">    const endTimeHandle = useCallback(() =&gt; &#123;</span><br><span class="line">        clearInterval(timer.current)</span><br><span class="line">        timer.current = null</span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;startTimeHandle&#125;&gt;start&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;endTimeHandle&#125;&gt;end&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一般情况下，useRef 保存的数据是和 UI 的渲染无关的，因此在 ref 的值发生变化时是不会触发组件的重新渲染。</strong></p>
<h3 id="保存-DOM-节点的引用"><a href="#保存-DOM-节点的引用" class="headerlink" title="保存 DOM 节点的引用"></a>保存 DOM 节点的引用</h3><p>在 React 中，绝大多数时候我们不需要关心真实的 DOM 是如何渲染和修改的。但是在某些场景下，我们需要获得真实 DOM 的引用。所以<strong>结果 React ref 属性和 useRef，我们就可以获得真实的 DOM 节点。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fucntion InputFocusComp() &#123;</span><br><span class="line">    let inputRef = useRef(null)</span><br><span class="line"></span><br><span class="line">    const focusInput = useCallback(() =&gt; &#123;</span><br><span class="line">        inputRef.current.focus()</span><br><span class="line">    &#125;, [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;input type=&quot;text&quot; ref=&#123;inputRef&#125;  /&gt;</span><br><span class="line">        &lt;button onClick=&#123;focusInput&#125;&gt;点击input 框对焦&lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="useContext-定义全局状态"><a href="#useContext-定义全局状态" class="headerlink" title="useContext 定义全局状态"></a>useContext 定义全局状态</h2><p>React 组件之间的状态(数据)传递只有一种方式，<code>props</code>。这就意味着只能在父子组件之间进行传递。<br>如果要跨层次或者组件之间要进行数据的共享，就需要用到 useContext Hook.</p>
<p>React 提供了一个 Context 机制，能够让所有在某个组件开始的组件树上创建一个 Context。这样这个组件树上的所有组件，就都能访问和修改这个 Context 了。</p>
<p><code>const val = useContent(MyContext)</code></p>
<h3 id="createContext-initVal"><a href="#createContext-initVal" class="headerlink" title="createContext(initVal)"></a>createContext(initVal)</h3><p>使用<code>React.createContext</code>可以从某个组件为根组件的组件树上创建一个 Context</p>
<p><code>const MyContext = React.createContext(initVal)</code></p>
<p>官方示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: &quot;#000000&quot;,</span><br><span class="line">    background: &quot;#eeeeee&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: &quot;#ffffff&quot;,</span><br><span class="line">    background: &quot;#222222&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 创建一个 Theme 的 Context</span><br><span class="line"></span><br><span class="line">const ThemeContext = React.createContext(themes.light);</span><br><span class="line">function App() &#123;</span><br><span class="line">  // 整个应用使用 ThemeContext.Provider 作为根组件</span><br><span class="line">  return (</span><br><span class="line">    // 使用 themes.dark 作为当前 Context</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;/ThemeContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在 Toolbar 组件中使用一个会使用 Theme 的 Button</span><br><span class="line">function Toolbar(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在 Theme Button 中使用 useContext 来获取当前的主题</span><br><span class="line">function ThemedButton() &#123;</span><br><span class="line">  const theme = useContext(ThemeContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;button style=&#123;&#123;</span><br><span class="line">      background: theme.background,</span><br><span class="line">      color: theme.foreground</span><br><span class="line">    &#125;&#125;&gt;</span><br><span class="line">      I am styled by theme context!</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;ThemeContext.Provider value={themes.dark}&gt;</code>接收的参数可以为一个 state 值，通过修改 state 值就可以实现动态切换 Context 的值了。并且所有用到这个 Context 的地方都会自动刷新。</p>
<h3 id="useContext-实践"><a href="#useContext-实践" class="headerlink" title="useContext 实践"></a>useContext 实践</h3><p>虽然 Context 提供了一个方便在多个组件之间共享数据的机制。但是它相当于在 React 中定义了一个全局变量，会使得调试和复用变得复杂和困难。</p>
<h2 id="Hooks-使用规则"><a href="#Hooks-使用规则" class="headerlink" title="Hooks 使用规则"></a>Hooks 使用规则</h2><ul>
<li>只能在函数组件的顶级作用域中使用；只能在函数组件或其他 Hooks 中使用。<br>顶级作用域，就是<strong>Hooks 不能用在循环、条件判断或者嵌套函数内执行，必须是顶层。</strong>同时 <strong>Hooks 在组件的多次渲染之间，必须按顺序被执行。</strong></li>
<li>避免重复定义回调函数</li>
</ul>
<hr>
<p><em><code>20221111补充：</code></em></p>
<h3 id="保持状态的一致性"><a href="#保持状态的一致性" class="headerlink" title="保持状态的一致性"></a>保持状态的一致性</h3><p>在 Hooks 的使用过程中我们应当尽可能使用最优、最合理的方式去管理应用状态。</p>
<h4 id="保证状态最小化"><a href="#保证状态最小化" class="headerlink" title="保证状态最小化"></a>保证状态最小化</h4><p>不要把 State 当做变量用。<strong>在保证 State 完整性的同时，也应保证它的最小化。</strong></p>
<p>举个栗子。我们要实现一个对订单列表进行关键字搜索的功能。我们可能需要一个搜索框和一个订单列表。</p>
<p>按照 React 状态驱动 UI 的思想，我们页面上可能需要三个状态：</p>
<ol>
<li>订单列表的数据：可能来自于某个接口请求；</li>
<li>搜索关键字： 用户输入；</li>
<li>搜索结果： 根据搜索关键字过滤原始数据。</li>
</ol>
<p>故代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const OrderListFilter = function (data) &#123;</span><br><span class="line">  // 搜索关键字</span><br><span class="line">  const [filterVal, setFilterVal] = useState(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">  // 过滤后展示的数据，默认为原始数据</span><br><span class="line">  const [filterList, setFilterList] = useState(data);</span><br><span class="line"></span><br><span class="line">  const handleFilter = useCallback(</span><br><span class="line">    (evt) =&gt; &#123;</span><br><span class="line">      const temp = evt.target.value;</span><br><span class="line">      setFilterVal(temp);</span><br><span class="line">      setFilterList(</span><br><span class="line">        filterList.filter((item) =&gt; &#123;</span><br><span class="line">          return item.title.includes(temp);</span><br><span class="line">        &#125;),</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    [filterVal],</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; value=&#123;filterVal&#125; onChange=&#123;handleFilter&#125; /&gt;</span><br><span class="line">      &#123;filterList.length</span><br><span class="line">        ? filterList.map((item) =&gt; &#123;</span><br><span class="line">            return &lt;div&gt;item.title&lt;/div&gt;;</span><br><span class="line">          &#125;)</span><br><span class="line">        : null&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，使用了两个 state 去保存过滤后的结果。但其实这个 state 是多余的。因为<strong>过滤后的结果数据可以使用计算属性 useMemo 缓存起来。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const OrderListFilter = function (data) &#123;</span><br><span class="line">  // 搜索关键字</span><br><span class="line">  const [filterVal, setFilterVal] = useState(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">  const filterList = useMemo(() =&gt; &#123;</span><br><span class="line">    return data.filter(item =&gt; &#123;</span><br><span class="line">      return item.title.includes(filterVal)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  const handleFilter = useCallback(</span><br><span class="line">    (evt) =&gt; &#123;</span><br><span class="line">      const temp = evt.target.value;</span><br><span class="line">      setFilterVal(temp);</span><br><span class="line">      setFilterList(</span><br><span class="line">        filterList.filter((item) =&gt; &#123;</span><br><span class="line">          return item.title.includes(temp);</span><br><span class="line">        &#125;),</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    [filterVal, data],</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; value=&#123;filterVal&#125; onChange=&#123;handleFilter&#125; /&gt;</span><br><span class="line">      &#123;filterList.length</span><br><span class="line">        ? filterList.map((item) =&gt; &#123;</span><br><span class="line">            return &lt;div&gt;item.title&lt;/div&gt;;</span><br><span class="line">          &#125;)</span><br><span class="line">        : null&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就可以只使用一个 state 来使得组件最简化。<br>所以我们在定义一个新的状态之前，都要再三拷问自己：<strong>这个状态是必须的吗？是否能通过计算得到？</strong></p>
<h4 id="避免中间状态，保持数据源唯一"><a href="#避免中间状态，保持数据源唯一" class="headerlink" title="避免中间状态，保持数据源唯一"></a>避免中间状态，保持数据源唯一</h4>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
        <tag>重学React</tag>
      </tags>
  </entry>
  <entry>
    <title>Js创建对象</title>
    <url>/2019/05/10/Js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><strong>前言</strong>  五一假期和<a href="http://blog.zhanghuiliang.cn" target="_blank" rel="noopener">阿亮</a>约耍，闲聊时说起了Js创建对象的几种方式，顿觉虎躯一震，是时候抽个时间整理下这个东西了。但对于我这种懒人来说，随便一个理由都能是我没时间写东西的借口。还好，有阿亮这个勤劳的人儿。<a href="http://blog.zhanghuiliang.cn/2019/05/05/js%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">原文出处</a></p>
<a id="more"></a>
<hr>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>创建一个对象最简单的方法莫过于使用字面量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var animalA = &#123;</span><br><span class="line">	name: &apos;animal&apos;,</span><br><span class="line">	age: 1,</span><br><span class="line">	relations: [],</span><br><span class="line">	run: function () &#123;</span><br><span class="line">		console.log(&apos;run&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们创建了一个animalA对象，他具有三个属性，一个方法。这种创建对象的方法因为简单，所以也是较为常用的一种方法，不过一次只能创建出一个对象，也就是这里的animalA，如果要再次创建一个同样结构的animalB就需要重复写一遍后面的字面量，创建过程不能重用。</p>
<hr>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式是使用一个函数来封装对象的创建过程，每次创建对象是就通过对工厂方法的调用来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createAnimal(name, age) &#123;</span><br><span class="line">	var animal = &#123;&#125;;</span><br><span class="line">	animal.name = name;</span><br><span class="line">	animal.age = age;</span><br><span class="line">	animal.relations = [];</span><br><span class="line">	animal.run = function () &#123;</span><br><span class="line">		console.log(&apos;run&apos;);</span><br><span class="line">	&#125;;</span><br><span class="line">	return animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = createAnimal(&apos;animalA&apos;, 1);</span><br><span class="line">var animalB = createAnimal(&apos;animalB&apos;, 2);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor, animalB.constructor); // Object() &#123;&#125;, Object() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们定义了一个createAnimal函数，每次调用即可返回一个具有3个属性，一个方法的对象。工厂模式规避了字面量方式创建相似对象时比较繁琐的问题，但是他没有产生对象类型标示，通过打印animalA和animalB的constructor可以发现输出的都是Object。</p>
<hr>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>在js中，可以通过函数名前添加new操作符来创建对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal (name, age) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.relations = [];</span><br><span class="line">	this.run = function () &#123;</span><br><span class="line">		console.log(&apos;run&apos;);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&apos;animalA&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;animalB&apos;, 2);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Animal() &#123;&#125;</span><br><span class="line">console.log(animalA.run === animalB.run); // false</span><br></pre></td></tr></table></figure>
<p>使用new操作符调用函数时，运行环境会创建一个新对象，然后将构造函数的作用域赋给新对象（this也就指向这个新对象），运行函数，在函数运行结束后如果没有显式的return值，就会将创建的这个新对象作为返回值返回。</p>
<p>使用构造函数可以重用创建过程，创建的对象具有相同的类型标识（constructor），不过我们对比初始化出的两个实例的run方法会发现它们并不相等，也就是说每次每个实例对象都独立拥有一个自己的run方法，这显然是不够经济且不符合我们对它们的一致性的期望。</p>
<hr>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>js函数具有一个prototype属性，使用函数名前加new操作符创建的实例内部会有一个[[prototype]]指针指向构造函数的prototype属性,访问实例的属性时会先对实例自身进行查找，如果查找不到会继续查找实例的[[prototype]]，查找仍然失败就继续查找[[prototype]]的[[prototype]]，依此规则持续进行直到查找成功或失败。所以，将属性放在函数的prototype属性上可以实现实例之间共享数据的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal() &#123;&#125;</span><br><span class="line">Animal.prototype.name = &apos;&apos;;</span><br><span class="line">Animal.prototype.age = 0;</span><br><span class="line">Animal.prototype.relations = [];</span><br><span class="line">Animal.prototype.run = function() &#123;</span><br><span class="line">	console.log(&quot;run&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal();</span><br><span class="line">var animalB = new Animal();</span><br><span class="line"></span><br><span class="line">console.log(animalA instanceof Animal); // true</span><br><span class="line">console.log(animalA.run === animalB.run); // true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&apos;fish&apos;);</span><br><span class="line">console.log(animalA.relations); // [&apos;fish&apos;]</span><br></pre></td></tr></table></figure>
<p>使用原型模式由于所创建的实例的[[prototype]]都指向的是Animal.prototype，所以可以看到他避免了构造函数模式两次创建的实例的run函数不相等的问题，但是原型上的其他引用类型的属性也被共用，因此导致了一个实例更改了原型中引用类型的数据，其他实例访问数据也会变化。</p>
<hr>
<h3 id="组合构造函数和原型模式"><a href="#组合构造函数和原型模式" class="headerlink" title="组合构造函数和原型模式"></a>组合构造函数和原型模式</h3><p>仅使用构造函数实例间不能重用函数，仅使用原型模式重用的函数的同时也会导致引用类型的值的重用，因此不难想象我们可以组合使用两者。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.relations = [];</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.run = function () &#123;</span><br><span class="line">	console.log(&apos;run&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;cat&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.run === animalB.run);// true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&apos;fish&apos;);</span><br><span class="line">console.log(animalA.relations); // []</span><br></pre></td></tr></table></figure></p>
<p>组合使用了构造函数模式和原型模式后，解决了对象类型标示问题，可以重用constructor和其他函数,这是一个典型的对象创建的范例。</p>
<hr>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>构造函数模式和原型模式组合使用后确实是一种不错的实践方式，不过在为构造函数的原型添加函数的代码在构造函数之外，这自然是给人一种封装不足的感觉，我们可以通过在构造函数内部,对函数原型是否已经赋值的判断来动态的添加原型方法,从而实现进一步的封装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.relations = [];</span><br><span class="line">	if (!Animal.prototype.run) &#123;</span><br><span class="line">		Animal.prototype.run = function () &#123;</span><br><span class="line">			console.log(&apos;run&apos;);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;cat&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Animal() &#123;&#125;</span><br><span class="line">console.log(animalA.run === animalB.run);// true</span><br><span class="line">console.log(animalA.relations); // []</span><br><span class="line">animalB.relations.push(&apos;fish&apos;);</span><br><span class="line">console.log(animalA.relations); // []</span><br></pre></td></tr></table></figure>
<p>通过代码可以看到，我们将在原型上添加函数的代码移至函数内部，通过最初的一次判断来确定为原型添加函数的逻辑只会在构造函数第一次被调用时执行。动态原型模式可以理解为是组合构造函数和原型模式的另一种写法。</p>
<hr>
<h3 id="寄生构造函数"><a href="#寄生构造函数" class="headerlink" title="寄生构造函数"></a>寄生构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">	var animal = &#123;&#125;;</span><br><span class="line">	animal.name = name;</span><br><span class="line">	animal.age = age;</span><br><span class="line">	animal.relations = [];</span><br><span class="line">	animal.run = function () &#123;</span><br><span class="line">		console.log(&apos;run&apos;);</span><br><span class="line">	&#125;;</span><br><span class="line">	return animal;</span><br><span class="line">&#125;</span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">var animalB = new Animal(&apos;cat&apos;, 1);</span><br><span class="line"></span><br><span class="line">console.log(animalA.constructor); // Object() &#123;&#125;</span><br><span class="line">console.log(animalA instanceof Animal); // false</span><br></pre></td></tr></table></figure>
<p>寄生构造函数除了使用new操作符调用和把函数叫做构造函数外，看起来跟工厂模式没有任何区别。寄生构造函数模式创建的实例与构造函数的原型属性之间没有关系，所以实例的constructor并不指向构造函数，也无法使用instanceof来判断实例的类型。正常情况下不推荐使用，除非你要为已有类型扩展功能（装潢模式）,比如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SpecialArray() &#123;</span><br><span class="line">	var array = new Array();</span><br><span class="line">	array.push.apply(array, arguments);</span><br><span class="line">	array.toPipedString = function () &#123;</span><br><span class="line">		return this.join(&quot;|&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">	return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var colors = new SpecialArray(&apos;red&apos;, &apos;blue&apos;, &apos;grey&apos;);</span><br><span class="line">console.log(colors.toPipedString()); // red|blue|grey</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>Douglas Crockford发明了JavaScript中的稳妥对象的概念，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象适用于一些安全的环境中（禁止使用new和this），稳妥构造函数和寄生构造函数类似，但有亮点不同，一是新创建对象的实例方法中不使用this，二是不使用new操作符调用构造函数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Animal(name, age) &#123;</span><br><span class="line">	var animal = &#123;&#125;;</span><br><span class="line">	animal.run = function () &#123;</span><br><span class="line">		console.log(name + &apos; run&apos;);</span><br><span class="line">	&#125;;</span><br><span class="line">	return animal;</span><br><span class="line">&#125;</span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">animalA.run();</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>ES6中新添加了class关键字，可以通过class来定义类，通过对类进行实例化来创建对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">	constructor(name, age) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	run() &#123;</span><br><span class="line">		console.log(&apos;run&apos;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static hello() &#123;</span><br><span class="line">		console.log(&apos;hello&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof Animal); // function</span><br><span class="line">var animalA = new Animal(&apos;dog&apos;, 1);</span><br><span class="line">console.log(typeof animalA); // object</span><br><span class="line">console.log(animalA.constructor); // class Animal1&#123;&#125;</span><br><span class="line">console.log(animalA instanceof Animal); // true</span><br></pre></td></tr></table></figure>
<p>使用class关键字后面跟类名，跟大括号，在大括号中名为constructor的函数就是构造函数，实例属性可以在constructor中进行初始化。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>如果当时</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript语句及表达式</title>
    <url>/2020/06/17/JavaScript%E8%AF%AD%E5%8F%A5%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>在 JavaScript 标准中，语句分成了两种：声明和语句。</p>
<a id="more"></a>
<h3 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h3><p>可以理解为，语句块就是一对大括号。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    var x = 100;</span><br><span class="line">    var y = 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>语句块的意义和好处在于：让我们可以把多行语句视为同一行语句，这样if、for 等语句定义起来就比较简单了。<br>需要注意的是，语句块会产生作用域。如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    let x = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x); // 报错</span><br></pre></td></tr></table></figure></p>
<p>这里let声明的变量，只在语句块作用域中有效，所以在语句块外部访问x变量会报错。</p>
<h3 id="空语句"><a href="#空语句" class="headerlink" title="空语句"></a>空语句</h3><p>空语句就是一个独立的分号，实际上没什么大用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure></p>
<p>空语句的存在仅仅是从语言设计完备性的角度考虑，允许插入多个分号而不抛出错误。</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(true) &#123;</span><br><span class="line">    console.log(&apos;asd&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 语句的作用是，在满足条件时执行它的内容语句，这个语句可以是一个语句块，这样就可以实现有条件地执行多个语句了。<br>if 语句还有 else 结构，用于不满足条件时执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a = 20;</span><br><span class="line">if(a &lt; 10) &#123;</span><br><span class="line">  console.log(&apos;a &lt; 10&apos;)</span><br><span class="line">&#125; else if(a &lt; 20) &#123;</span><br><span class="line">  console.log(&apos;a &lt; 20&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&apos;a &gt;= 10&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示三个互斥的分支，分别在满足不同的条件时执行。</p>
<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a  = 20;</span><br><span class="line">switch(a) &#123;</span><br><span class="line">  case 10: </span><br><span class="line">    // ... </span><br><span class="line">    break;</span><br><span class="line">  case 20:</span><br><span class="line">    / ... </span><br><span class="line">    break;</span><br><span class="line">  case 30:</span><br><span class="line">    / ... </span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="while-循环和-do-while-循环"><a href="#while-循环和-do-while-循环" class="headerlink" title="while 循环和 do while 循环"></a>while 循环和 do while 循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// while</span><br><span class="line">let a = 100;</span><br><span class="line">while(a--) &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// do while</span><br><span class="line">let b = 101;</span><br><span class="line">do &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;while(a &lt; 100)</span><br></pre></td></tr></table></figure>
<p>注意，这里 do while 循环无论如何至少会执行一次。</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  // do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><p>for in 循环枚举对象的属性，这里体现了属性的 enumerable 特征。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let o = &#123;a: 1, b: 2&#125;</span><br><span class="line">Object. defineProperty(o, &apos;c&apos;, &#123;enumerable: false, value: 3&#125;)</span><br><span class="line">for(let p in o)</span><br><span class="line">    console.log(p)</span><br></pre></td></tr></table></figure></p>
<p>上一段代码中，定义了一个对象o，并且给它添加了一个不可枚举属性c，之后用for in 循环枚举它的属性，输出的只有a和b。<br>如果我们定义 c 这个属性时，enumerable 为 true，则 for in 循环中也能枚举到它。</p>
<h4 id="for-of-循环和-for-await-of-循环"><a href="#for-of-循环和-for-await-of-循环" class="headerlink" title="for of 循环和 for await of 循环"></a>for of 循环和 for await of 循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(let e of [1, 2, 3, 4, 5])</span><br><span class="line">    console.log(e)</span><br></pre></td></tr></table></figure>
<p>它背后的机制实际上是iterator.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let o = &#123;  </span><br><span class="line">    [Symbol.iterator]:() =&gt; (&#123;</span><br><span class="line">        _value: 0,</span><br><span class="line">        next()&#123;</span><br><span class="line">            if(this._value == 10)</span><br><span class="line">                return &#123;</span><br><span class="line">                    done: true</span><br><span class="line">                &#125;</span><br><span class="line">            else return &#123;</span><br><span class="line">                value: this._value++,</span><br><span class="line">                done: false</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">for(let e of o)</span><br><span class="line">    console.log(e)</span><br></pre></td></tr></table></figure></p>
<p>上一段代码中展示了如何为一个对象添加 iterator。但是，在实际操作中，我们一般不需要这样定义 iterator，我们可以使用 generator function。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* foo()&#123;</span><br><span class="line">    yield 0;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">&#125;</span><br><span class="line">for(let e of foo())</span><br><span class="line">    console.log(e)</span><br></pre></td></tr></table></figure>
<p>此外，JavaScript 还为异步生成器函数配备了异步的 for of。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sleep(duration) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        setTimeout(resolve,duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async function* foo()&#123;</span><br><span class="line">    i = 0;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        await sleep(1000);</span><br><span class="line">        yield i++;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for await(let e of foo())</span><br><span class="line">    console.log(e)</span><br></pre></td></tr></table></figure>
<p>上一段代码定义了一个异步生成器函数，异步生成器函数每隔一秒生成一个数字，这是一个无限的生成器。<br>接下来，我们使用 for await of 来访问这个异步生成器函数的结果，我们可以看到，这形成了一个每隔一秒打印一个数字的无限循环。<br>但是因为我们这个循环是异步的，并且有时间延迟，所以，这个无限循环的代码可以用于显示时钟等有意义的操作。</p>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>return 语句用于函数中，它终止函数的执行，并且指定函数的返回值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">  return &apos;a&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="break-语句和-continue-语句"><a href="#break-语句和-continue-语句" class="headerlink" title="break 语句和 continue 语句"></a>break 语句和 continue 语句</h3><p>break 语句用于跳出循环语句或者 switch 语句，continue 语句用于结束本次循环并继续循环。</p>
<h3 id="try-语句和-throw-语句"><a href="#try-语句和-throw-语句" class="headerlink" title="try 语句和 throw 语句"></a>try 语句和 throw 语句</h3><p>try 语句和 throw 语句用于处理异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    throw new Error(&quot;error&quot;);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    console.log(&quot;finally&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，throw 用于抛出异常，但是单纯从语言的角度，我们可以抛出任何值，也不一定是异常逻辑，但是为了保证语义清晰，不建议用 throw 表达任何非异常逻辑。</p>
<p>try 语句用于捕获异常，用 throw 抛出的异常，可以在 try 语句的结构中被处理掉：try 部分用于标识捕获异常的代码段，catch 部分则用于捕获异常后做一些处理，而 finally 则是用于执行后做一些必须执行的清理工作。</p>
<p>catch 结构会创建一个局部的作用域，并且把一个变量写入其中，需要注意，在这个作用域，不能再声明变量 e 了，否则会出错。</p>
<p>在 catch 中重新抛出错误的情况非常常见，在设计比较底层的函数时，常常会这样做，保证抛出的错误能被理解。</p>
<p>finally 语句一般用于释放资源，它一定会被执行，即使在 try 中出现了 return，finally 中的语句也一定要被执行。</p>
<h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>var 声明语句是古典的 JavaScript 中声明变量的方式。而现在，在绝大多数情况下，let 和 const 都是更好的选择。</p>
<h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><p>新设计的变量声明语法。</p>
<p>相较于var声明的优点:</p>
<ul>
<li>在重复声明变量时会报错，避免变量名冲突。</li>
<li>定义变量之前调用会报错。</li>
</ul>
<h3 id="class-声明"><a href="#class-声明" class="headerlink" title="class 声明"></a>class 声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最基本的用法只需要 class关键字，加一对大括号。它的声明特征跟 const 和 let 类似，都是作用于块级作用域。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明的关键字是 function</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">function * a() &#123;&#125;</span><br><span class="line"></span><br><span class="line">async function* b() &#123;</span><br><span class="line">  await a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function* b()&#123;</span><br><span class="line">    await a(3000);</span><br><span class="line">    yield 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带 * 的函数是 generator。生成器函数可以理解为返回一个序列的函数，它的底层是 iterator 机制。</p>
<p>async 函数是可以暂停执行，等待异步操作的函数，它的底层是 Promise 机制。异步生成器函数则是二者的结合。</p>
<h3 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h3><p>一般来说，我们的表达式语句要么是函数调用，要么是赋值，要么是自增、自减，否则表达式计算的结果没有任何意义。<br>但是从语法上，并没有这样的限制，任何合法的表达式都可以当做表达式语句使用。</p>
<h4 id="PrimaryExpression-主要表达式"><a href="#PrimaryExpression-主要表达式" class="headerlink" title="PrimaryExpression 主要表达式"></a>PrimaryExpression 主要表达式</h4><p>任何表达式加上圆括号，都被认为是 Primary Expression</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(a + b)</span><br></pre></td></tr></table></figure>
<h4 id="MemberExpression-成员表达式"><a href="#MemberExpression-成员表达式" class="headerlink" title="MemberExpression 成员表达式"></a>MemberExpression 成员表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a.b;</span><br><span class="line">a[&quot;b&quot;];</span><br><span class="line">new.target;</span><br><span class="line">super.b;</span><br></pre></td></tr></table></figure>
<p>前面两种用法都很好理解，就是用标识符的属性访问和用字符串的属性访问。而 new.target 是个新加入的语法，用于判断函数是否是被 new 调用，super 则是构造函数中，用于访问父类的属性的语法。</p>
<h4 id="NewExpression-NEW-表达式"><a href="#NewExpression-NEW-表达式" class="headerlink" title="NewExpression NEW 表达式"></a>NewExpression NEW 表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Cls()</span><br></pre></td></tr></table></figure>
<h4 id="CallExpression-函数调用表达式"><a href="#CallExpression-函数调用表达式" class="headerlink" title="CallExpression 函数调用表达式"></a>CallExpression 函数调用表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a.b(c);</span><br><span class="line">super();</span><br></pre></td></tr></table></figure>
<h4 id="LeftHandSideExpression-左值表达式"><a href="#LeftHandSideExpression-左值表达式" class="headerlink" title="LeftHandSideExpression 左值表达式"></a>LeftHandSideExpression 左值表达式</h4><p>左值表达式就是可以放到等号左边的表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a() = b ;</span><br><span class="line">a().c = b;</span><br></pre></td></tr></table></figure>
<h4 id="AssignmentExpression-赋值表达式"><a href="#AssignmentExpression-赋值表达式" class="headerlink" title="AssignmentExpression 赋值表达式"></a>AssignmentExpression 赋值表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = b;</span><br></pre></td></tr></table></figure>
<h4 id="更新表达式-UpdateExpression"><a href="#更新表达式-UpdateExpression" class="headerlink" title="更新表达式 UpdateExpression"></a>更新表达式 UpdateExpression</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- a;</span><br><span class="line">++ a;</span><br><span class="line">a --</span><br><span class="line">a ++</span><br></pre></td></tr></table></figure>
<p>更新表达式会改变一个左值表达式的值。分为前后自增，前后自减一共四种。</p>
<h4 id="一元运算表达式-UnaryExpression"><a href="#一元运算表达式-UnaryExpression" class="headerlink" title="一元运算表达式 UnaryExpression"></a>一元运算表达式 UnaryExpression</h4><p>它的特点就是一个更新表达式搭配了一个一元运算符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete a;</span><br><span class="line">typeof a;</span><br></pre></td></tr></table></figure>
<h4 id="乘方表达式-ExponentiationExpression"><a href="#乘方表达式-ExponentiationExpression" class="headerlink" title="乘方表达式 ExponentiationExpression"></a>乘方表达式 ExponentiationExpression</h4><p>乘方表达式也是由更新表达式构成的。它使用**号。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">++i ** 30</span><br><span class="line">2 ** 30 //正确</span><br><span class="line">-2 ** 30 //报错</span><br></pre></td></tr></table></figure></p>
<h4 id="乘法表达式-MultiplicativeExpression"><a href="#乘法表达式-MultiplicativeExpression" class="headerlink" title="乘法表达式 MultiplicativeExpression"></a>乘法表达式 MultiplicativeExpression</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a * b;</span><br><span class="line"></span><br><span class="line">// 乘法表达式有三种运算符</span><br><span class="line">*</span><br><span class="line">/</span><br><span class="line">%</span><br><span class="line">// 它们分别表示乘、除和取余。它们的优先级是一样的，所以统一放在乘法运算表达式中。</span><br></pre></td></tr></table></figure>
<h4 id="加法表达式-AdditiveExpression"><a href="#加法表达式-AdditiveExpression" class="headerlink" title="加法表达式 AdditiveExpression"></a>加法表达式 AdditiveExpression</h4><p>加法表达式是由乘法表达式用加号或者减号连接构成的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a + b - c;</span><br></pre></td></tr></table></figure></p>
<h4 id="移位表达式-ShiftExpression"><a href="#移位表达式-ShiftExpression" class="headerlink" title="移位表达式 ShiftExpression"></a>移位表达式 ShiftExpression</h4><p>移位表达式由加法表达式构成，移位是一种位运算，分成三种：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&lt; 向左移位</span><br><span class="line">&gt;&gt; 向右移位</span><br><span class="line">&gt;&gt;&gt; 无符号向右移位</span><br></pre></td></tr></table></figure></p>
<p>移位运算把操作数看做二进制表示的整数，然后移动特定位数。所以左移 n 位相当于乘以 2 的 n 次方，右移 n 位相当于除以 2 取整 n 次。</p>
<h4 id="关系表达式-RelationalExpression"><a href="#关系表达式-RelationalExpression" class="headerlink" title="关系表达式 RelationalExpression"></a>关系表达式 RelationalExpression</h4><p>移位表达式可以构成关系表达式，这里的关系表达式就是大于、小于、大于等于、小于等于等运算符号连接，统称为关系运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;=</span><br><span class="line">&gt;=</span><br><span class="line">&lt;</span><br><span class="line">&gt;</span><br><span class="line">instanceof </span><br><span class="line">in</span><br></pre></td></tr></table></figure>
<p>需要注意，这里的 &lt;= 和 &gt;= 关系运算，完全是针对数字的，所以 &lt;= 并不等价于 &lt; 或 ==。</p>
<h4 id="相等表达式-EqualityExpression"><a href="#相等表达式-EqualityExpression" class="headerlink" title="相等表达式 EqualityExpression"></a>相等表达式 EqualityExpression</h4><p>在语法上，相等表达式是由关系表达式用相等比较运算符（如 ==）连接构成的。所以我们可以像下面这段代码一样使用，而不需要加括号。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a instanceof &quot;object&quot; == true</span><br></pre></td></tr></table></figure></p>
<p>相等表达式由四种运算符和关系表达式构成</p>
<ul>
<li>===</li>
<li>!==</li>
<li>==</li>
<li>!=</li>
</ul>
<p>虽然标准中写的==十分复杂，但是归根结底，类型不同的变量比较时==运算只有三条规则:</p>
<ul>
<li>undefined 与 null 相等；</li>
<li>字符串和 bool 都转为数字再比较；</li>
<li>对象转换成 primitive 类型再比较。</li>
<li>即使字符串与 boolean 比较，也都要转换成数字</li>
<li>对象如果转换成了 primitive 类型跟等号另一边类型恰好相同，则不需要转换成数字。</li>
</ul>
<h4 id="位运算表达式"><a href="#位运算表达式" class="headerlink" title="位运算表达式"></a>位运算表达式</h4><p>位运算表达式含有三种：</p>
<ul>
<li>按位与表达式 BitwiseANDExpression</li>
<li>按位异或表达式 BitwiseANDExpression</li>
<li>按位或表达式 BitwiseORExpression。</li>
</ul>
<p>按位与表达式由按位与运算符（&amp;）连接按位异或表达式构成，按位与表达式把操作数视为二进制整数，然后把两个操作数按位做与运算。</p>
<p>按位异或表达式由按位异或运算符（^）连接按位与表达式构成，按位异或表达式把操作数视为二进制整数，然后把两个操作数按位做异或运算。异或两位相同时得 0，两位不同时得 1。</p>
<p>异或运算有个特征，那就是两次异或运算相当于取消。所以有一个异或运算的小技巧，就是用异或运算来交换两个整数的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let a = 102, b = 324;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line">console.log(a, b)</span><br></pre></td></tr></table></figure>
<p>按位或表达式由按位或运算符（|）连接相等表达式构成，按位或表达式把操作数视为二进制整数，然后把两个操作数按位做或运算。</p>
<h4 id="逻辑与表达式和逻辑或表达式"><a href="#逻辑与表达式和逻辑或表达式" class="headerlink" title="逻辑与表达式和逻辑或表达式"></a>逻辑与表达式和逻辑或表达式</h4><p>逻辑与表达式由按位或表达式经过逻辑与运算符连接构成，逻辑或表达式则由逻辑与表达式经逻辑或运算符连接构成。</p>
<p>这里需要注意的是，这两种表达式都不会做类型转换，所以尽管是逻辑运算，但是最终的结果可能是其它类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false || 1</span><br><span class="line">1 &amp;&amp; 2</span><br></pre></td></tr></table></figure>
<h4 id="条件表达式-ConditionalExpression"><a href="#条件表达式-ConditionalExpression" class="headerlink" title="条件表达式 ConditionalExpression"></a>条件表达式 ConditionalExpression</h4><p>条件表达式由逻辑或表达式和条件运算符构成，条件运算符又称三目运算符，它有三个部分，由两个运算符?和:配合使用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a = 2, b = 3;</span><br><span class="line">const c = a === 2 ? a : b;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>Js继承</title>
    <url>/2019/05/10/Js%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p><strong>前言</strong>  js语言是一种面向对象的语言，所谓的封装、继承、多态等特征js也都具备，这篇文章中我们就来探讨一下js中的继承有哪些实现方式。</p>
<a id="more"></a>
<p>如果有java、c++、oc等语言的基础的话会有一种观念，继承是基于与类的，需要说明的是js中的继承并不是基于类来实现的，而是基于原型的，尽管在ES6中有了class关键字，但在运行时中还是基于原型链来实现的。</p>
<hr>
<h3 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h3><p>在js中创建对象典型是通过new操作符来调用构造函数，得到的实例中会有一个[[prototype]]的私有属性，这个私有属性是一个构造函数的prototype属性的一个引用。查找实例属性时会先在自身查找，然后再去查找[[prototype]]，直到查找成功或[[prototype]]为空。这就是原型的基本原理。在ES6之前我们都是通过对构造函数和原型来达到继承的效果。以下我们来列举一下大概会有多少种继承的实践。</p>
<hr>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>我们知道了对一个对象进行属性查找时如果在自身查找不到时会去原型中进行查找，如果仍然查找不到的话又会继续查找原型的原型，如此反复直至查找成功或没有更深层次的原型可供查找，基于这种原理，我们可以通过将被继承类型的实例作为子类型的原型即是一种实现继承的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">    this.flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function () &#123;</span><br><span class="line">    return this.flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    this.subflag = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承了 Super</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype .getSubValue = function () &#123;</span><br><span class="line">    return this.subflag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">console.log(instance1.getSuperValue()); // true</span><br><span class="line">console.log(instance1.getSubValue()); // false</span><br><span class="line"></span><br><span class="line">console.log(instance1 instanceof SubType); // true</span><br><span class="line">console.log(instance1 instanceof SuperType);// true</span><br><span class="line">console.log(instance1 instanceof Object); // true</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line">console.log(SuperType.prototype.isPrototypeOf(instance1));// true</span><br><span class="line">console.log(SubType.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line"></span><br><span class="line">console.log(instance1.constructor); // [Function: SuperType]</span><br></pre></td></tr></table></figure>
<p>根据上面代码可以看出通过将子类型的构造函数的prototype设置为父类型实例，实例化的子类型可以同时拥有子类型和父类型的属性，也就是说我们通过这种方式实现了继承，不过这种继承有一些缺点,原型链中有引用类型的属性时，该属性会被所有实例所共用，这就会造成如果有任何一个实例如果更改了原型中的应用类型的值就会影响到其他实例；再者就是在构造子类型实例时，无法向超类的构造函数中传递参数。</p>
<hr>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>js函数有一个call方法，调用时指定的第一个参数为函数的作用域对象，其后参数会作为调用函数的参数进行传递，使用构造函数模式定义的构造函数内部我们会将要定义的属性赋值给作用域对象（this），基于上面两点，我们可以在子类型的构造函数中使用父类型的call函数，把当前的this作为第一个参数传入，以此来获得父类型的属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    //继承 SuperType</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Bill&quot;, 22); </span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">console.log(instance1.name); // Bill</span><br><span class="line">console.log(instance1.age); // 22</span><br><span class="line">console.log(instance1.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;black&apos; ]</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(&quot;Annie&quot;, 24);</span><br><span class="line">console.log(instance2.name); // Annie</span><br><span class="line">console.log(instance2.age); // 24</span><br><span class="line">console.log(instance2.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos; ]</span><br><span class="line">console.log(instance2.sayName); // undefined</span><br><span class="line"></span><br><span class="line">var super1 = new SuperType();</span><br><span class="line">console.log(super1.sayName); // [Function]</span><br></pre></td></tr></table></figure>
<p>这种方法的优点是，父类型中的引用类型的属性,并不被所有实例所公用，不会有有互相串改数据的问题；在构造子类型的实例时,可以向超类的构造函数中传递参数。不过如果父类型中的函数是定义在父类型实例中的话（典型的构造函数模式就是这样），子类型个实例之间无法复用函数，如果父类型中的函数是定义在父类型原型上的，子类型中根本就继承不到，因为子类型中实例的[[prototype]]是指向子类型的构造函数的prototype的，在子类型实例中没有指向父类型prototype的指针，所以也就没继承到。</p>
<hr>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合原型链和借用构造函数两者的优点，使用原型链来继承父类型中的原型属性进行继承，使用构造函数对父类型的实例属性进行继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    //继承 SuperType</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Bill&quot;, 22);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">instance1.sayName(); // Bill</span><br><span class="line">instance1.sayAge(); // 22</span><br><span class="line">console.log(instance1.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;black&apos; ]</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(&quot;Annie&quot;, 24);</span><br><span class="line">instance2.sayName(); // Annie</span><br><span class="line">instance2.sayAge(); // 24</span><br><span class="line">console.log(instance2.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos; ]</span><br><span class="line"></span><br><span class="line">console.log(instance1 instanceof Object); // true</span><br><span class="line">console.log(instance1 instanceof SuperType); // true</span><br><span class="line">console.log(instance1 instanceof SubType); // true</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line">console.log(SuperType.prototype.isPrototypeOf(instance1)); // true</span><br><span class="line">console.log(SubType.prototype.isPrototypeOf(instance1)); // true</span><br></pre></td></tr></table></figure>
<p>组合了两种模式之后，避免了原型链和借用构造函数的缺陷,融合了他们的优点。成为JS中最常用的继承方式。仅有一点小不足就是调用了两次父类的构造函数,在子类的prototype上面创建了不必要的、多余的属性</p>
<hr>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>原型式继承的原理是将一个对象直接作为新对象的原型，使用这种模式创建的对象并没有自定义的类型，只是实现了在原有对象的基础上进行了扩展。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Bill&quot;,</span><br><span class="line">    friends: [&quot;Annie&quot;, &quot;Frank&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var antherPerson = object(person);</span><br><span class="line">antherPerson.name = &quot;Greg&quot;;</span><br><span class="line">antherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person.name); // Bill</span><br><span class="line">console.log(person.friends); // [ &apos;Annie&apos;, &apos;Frank&apos;, &apos;Rob&apos; ]</span><br><span class="line"></span><br><span class="line">console.log(antherPerson.name); // Greg</span><br><span class="line">console.log(antherPerson.friends); // [ &apos;Annie&apos;, &apos;Frank&apos;, &apos;Rob&apos; ]</span><br></pre></td></tr></table></figure>
<p>这种模式确实可以创建出基于其他对象的实例，不过在原型链中有引用类型的属性时，该属性会被所有实例所共用;还有一个问题就是在构造子类型的实例时，无法向父类型的构造函数中传递参数。</p>
<p>在ES5中新增了Object.create函数，该函数规范了原型式继承的，该函数接收两个参数，原型对象以及一个可选的为新对象定义额外属性的属性描述符对象（和Object.defineProperties方法第二个参数一样）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var antherPerson2 = Object.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &quot;Frank&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">antherPerson2.friends.push(&quot;Shelby&quot;);</span><br><span class="line">console.log(antherPerson2.name); // Frank</span><br><span class="line">console.log(antherPerson2.friends); // [ &apos;Annie&apos;, &apos;Frank&apos;, &apos;Rob&apos;, &apos;Shelby&apos; ]</span><br><span class="line">console.log(antherPerson.friends); // [ &apos;Annie&apos;, &apos;Frank&apos;, &apos;Rob&apos;, &apos;Shelby&apos; ]</span><br></pre></td></tr></table></figure>
<p>总体来说，有了Object.create函数可以是我们更加便捷的使用原型式继承，不过由于引用类型的值会被所有新创建的实例所用，这种模式个人感觉使用时还是需要比较谨慎。</p>
<hr>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是将原型式继承使用一个工厂函数将构建过程封装起来，在工程函数中可以为创建的新对象添加所需的新的属性，最后返回新对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createAnother(original) &#123;</span><br><span class="line">    function object(o) &#123;</span><br><span class="line">        function F() &#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        return new F();</span><br><span class="line">    &#125;</span><br><span class="line">    var clone = object(original);</span><br><span class="line">    // var clone = Object.create(original);</span><br><span class="line"></span><br><span class="line">    clone.sayName = function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Person(name, friends) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.friends = friends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&quot;Bill&quot;, [&quot;Annie&quot;, &quot;Frank&quot;]);</span><br><span class="line"></span><br><span class="line">var anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line">anotherPerson.sayName(); // Greg</span><br><span class="line"></span><br><span class="line">var anotherPerson1 = createAnother(person);</span><br><span class="line">console.log(anotherPerson.sayName == anotherPerson1.sayName); // false</span><br></pre></td></tr></table></figure>
<p>这种模式相对于原型模式封装程度更高一点，使用这种模式创建的实例之间不能复用函数，效率会降低。</p>
<hr>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承是最常用的继承方式，不过他会调用两次父类型的构造函数，形成在实例自身和原型上分别形成一份属性，寄生组合式继承利用构造函数来继承实例属性，通过引用一份父类型引用来获得原型链。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    var prototype = Object(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    //继承 SuperType</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line"></span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = function () &#123;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Bill&quot;, 22);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line"></span><br><span class="line">instance1.sayName(); // Bill</span><br><span class="line">instance1.sayAge(); // 22</span><br><span class="line">console.log(instance1.colors); // [ &apos;red&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;black&apos; ]</span><br></pre></td></tr></table></figure></p>
<p>寄生组合式继承避免了调用两次父类型的构造函数，避免在子类的prototype上面创建不必要、多余的属性，是ES6之前最理想的继承范式。</p>
<hr>
<h3 id="class-extends"><a href="#class-extends" class="headerlink" title="class extends"></a>class extends</h3><p>在ES6之前继承只能通过上面介绍的方法，使用函数，原型，各种组合的手段才能实现较为理想的继承方式，在ES6中js给出了class和extends操作符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SuperType &#123;</span><br><span class="line">	constructor(name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	sayName() &#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubType extends SuperType &#123;</span><br><span class="line">	constructor(name, age) &#123;</span><br><span class="line">		// 相当于SuperType.call(this, name);</span><br><span class="line">		super(name);</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sayAge() &#123;</span><br><span class="line">		console.log(this.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance1 = new SubType(&apos;Bill&apos;, 25);</span><br><span class="line">instance1.sayName(); // Bill</span><br><span class="line">instance1.sayAge(); // 25</span><br></pre></td></tr></table></figure>
<p>在定义SubType时要通过extends指明要继承的父类型，在子类型定义中可是使用super关键字来指示父类型，在constructor中调用super()函数向父类型构造函数传参,这是一个和寄生组合式等价的实现方式,在书写上和语义上都比ES5中要清晰很多，所以建议在实践中应该尽量使用class的extends关键字来实现继承。</p>
<hr>
<h3 id="以上"><a href="#以上" class="headerlink" title="以上"></a>以上</h3><p>根据懒人定律以及拿来主义原则，<a href="http://blog.zhanghuiliang.cn/2019/05/07/js%E7%BB%A7%E6%89%BF/" target="_blank" rel="noopener">原文出处</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>如果当时</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环</title>
    <url>/2020/06/14/for%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>语句，是 JavaScript 中组织代码的基础语法组件，包括函数声明等等在内的六种声明，其实都被归为“语句”的范畴。<br>所以，理解“语句”在 JavaScript 中的语义是重中之重。</p>
<a id="more"></a>
<p>尽管如此，实际上要了解的也无非是顺序、分支、循环这三种执行逻辑而已，相比于它们，其它语句在语义上的复杂性通常不值一提。而这三种逻辑中尤其复杂的就是循环。</p>
<h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>在ES6之后，JavaScript实现了块级作用域。因此，现在绝大多数语句都基于这一作用域的概念来实现。<br>然而，事实上正好相反。<br>真正的状况是，绝大多数 JavaScript 语句都并没有自己的块级作用域。从语言设计的原则上来看，越少作用域的执行环境调度效率也就越高，执行时的性能也就越好。</p>
<p>基于这个原则，switch语句被设计为有且仅有一个作用域，无论它有多少个 case 语句，其实都是运行在一个块级作用域环境中的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = 100, c = &apos;a&apos;;</span><br><span class="line">switch (c) &#123;</span><br><span class="line">  case &apos;a&apos;: </span><br><span class="line">    console.log(x); // ReferenceError</span><br><span class="line">    break;</span><br><span class="line">  case &apos;b&apos;:</span><br><span class="line">    let x = 200;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，switch 语句内是无法访问到外部变量x的，即便声明变量x的分支case ‘b’永远都执行不到，但它里面的x却已经声明了，并且导致case ‘a’中的代码无法访问到外部的<code>x = 100</code>。这是因为所有分支都处在同一个块级作用域中（case ‘a’ 和 case ‘b’使用了同一个闭包），所以任意分支的声明都会给该作用域添加这个标识符，从而覆盖了全局的变量x。</p>
<p>一些简单的、显而易见的块级作用域包括：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">// 例1</span><br><span class="line">try &#123;</span><br><span class="line">  // 作用域1</span><br><span class="line">&#125;</span><br><span class="line">catch (e) &#123; // 表达式e位于作用域2</span><br><span class="line">  // 作用域2</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">  // 作用域3</span><br><span class="line">&#125;</span><br><span class="line">// 例2</span><br><span class="line">//（注：没有使用大括号）</span><br><span class="line">with (x) /* 作用域1 */; // &lt;- 这里存在一个块级作用域</span><br><span class="line">// 例3, 块语句</span><br><span class="line">&#123;</span><br><span class="line">  // 作用域1</span><br></pre></td></tr></table></figure></p>
<p>除了这三个语句和“一个特例”之外，所有其它的语句都是没有块级作用域的。例如if条件语句的几种常见书写形式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (x) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">// or</span><br><span class="line">if (x) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些语法中的“块级作用域”都是一对大括号表示的“块语句”自带的，与上面的“例 3”是一样的，而与if语句本身无关。</p>
<h3 id="循环语句中的块"><a href="#循环语句中的块" class="headerlink" title="循环语句中的块"></a>循环语句中的块</h3><p>并不是所有的循环语句都有自己的块级作用域，例如 while 和 do…while 语句就没有。而且，也不是所有 for 语句都有块级作用域。在 JavaScript 中，有且仅有：</p>
<blockquote>
<p> for (&lt;let/const&gt; …) …</p>
</blockquote>
<p>这个语法有自己的块级作用域。当然，这也包括相同设计的for await和for .. of/in ..。</p>
<blockquote>
<p>for await (&lt;let/const&gt; x of …) …<br>for (&lt;let/const&gt; x … in …) …<br>for (&lt;let/const&gt; x … of …) …</p>
</blockquote>
<p>在es6中，其实for只要写大括号就代表着块级作用域。所以只要写大括号，不管用let 还是 var，一定是会创建相应循环数量的块级作用域。<br>如果不用大括号，在for中使用了let，也会创建相应循环数量的块级作用域。</p>
<h3 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h3><p>所有在语句内可以存在的东西只有四种：表达式、其它语句、标识符声明（取决于声明语句或其它的隐式声明的方式），以及一种特殊的语法元素，称为“标签（例如标签化语句，或 break 语句指向的目标位置）”。</p>
<p>所谓“块级作用域”，本质上只包括一组标识符。因此，只有当存在潜在标识符冲突的时候，才有必要新添加一个作用域来管理它们。例如函数，由于函数存在“重新进入”的问题，所以它必须有一个作用域来管理“重新进入之前”的那些标识符。这个东西被称为“闭包”。</p>
<blockquote>
<p>NOTE: 在语言设计时，有三种需求会促使语句构建自己的作用域，标识符管理只是其中之一。其它两种情况，要么是因为在语法上支持多语句（例如 try…catch…finally 语句），要么是语句所表达的语义要求有一个块，例如“块语句{ }”在语义上就要求它自己是一个块级作用域。</p>
</blockquote>
<h3 id="特例中的特例"><a href="#特例中的特例" class="headerlink" title="特例中的特例"></a>特例中的特例</h3><p>“var 声明”是特例中的特例。</p>
<p>这一特性来自于 JavaScript 远古时代的作用域设计。在早期的 JavaScript 中，并没有所谓的块级作用域，那个时候的作用域设计只有“函数内”和“函数外”两种，如果一个标识符不在任何（可以多层嵌套的）函数内的话，那么它就一定是在“全局作用域”里。</p>
<p>而在这个时代，变量也就只有“var 声明”的变量。由于作用域只有上面两个，所以任何一个“var 声明”的标识符，要么是在函数内的，要么就是在全局的，没有例外。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var x = ...)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>按照早期的设计，变量x是不应该出现在for 语句所在的”块级作用域中的。</p>
<p>它应该出现其外层的某个函数作用域，或者全局作用域中。这种越过当前语法范围，而在更外围的作用域中登记名字行为就称为“提升“。</p>
<ul>
<li>所有”var 声明“和函数声明的标识符都登记为 varNames，使用“变量作用域”管理；</li>
<li>其它情况下的标识符 / 变量声明，都作为 lexicaNames 登记，使用“词法作用域”管理。</li>
</ul>
<blockquote>
<p>NOTE: 考虑到对传统 JavaScript 的兼容，函数内部的顶层函数名是提升到变量作用域中来管理的。 &gt; &gt; NOTE: 我通常会将“在变量声明语句前使用该变量”也称为一种提升效果（Hoisting effect)，但这种说法不见于 ECMAScript 规范。ES 规范将这种“提前使用”称为“访问一个未初始化的绑定（uninitialized mutable/immutable binding）”。而所谓“var 声明能被提前使用”的效果，事实上是“var 变量总是被引擎预先初始化为 undefined”的一种后果。</p>
</blockquote>
<p>所以，语句for (&lt;const/let&gt; x …) …语法中的标识符x是一个词法名字，应该由for语句为它创建一个（块级的）词法作用域来管理之。</p>
<h3 id="第二个作用域"><a href="#第二个作用域" class="headerlink" title="第二个作用域"></a>第二个作用域</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var x = 100;</span><br><span class="line">for (let x = 102; x &lt; 105; x++)</span><br><span class="line">  console.log(&apos;value:&apos;, x);  // 显示“value: 102~104”</span><br><span class="line">console.log(&apos;outer:&apos;, x); // 显示“outer: 100”</span><br></pre></td></tr></table></figure>
<p>因为for语句的这个块级作用域的存在，导致循环体内访问了一个局部的x值（循环变量），而外部的（outer）变量x是不受影响的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">for (let x = 102; x &lt; 105; x++)</span><br><span class="line">  let x = 200;</span><br></pre></td></tr></table></figure>
<p>如果循环体（单个语句）允许支持新的变量声明，那么为了避免它影响到循环变量，就必须为它再提供另一个块级作用域。在这里，JavaScript 是不允许声明新的变量的。上述的示例会抛出一个异常，提示“单语句不支持词法声明”：</p>
<blockquote>
<p> SyntaxError: Lexical declaration cannot appear in a single-statement context</p>
</blockquote>
<p>这个语法错误并不常见，因为很少有人会尝试构建这样的特殊代码。然而事实上，它是一个普遍存在的语法禁例。如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// if语句中的禁例</span><br><span class="line">if (false) let x = 100;</span><br><span class="line">// while语句中的禁例</span><br><span class="line">while (false) let x = 200;</span><br><span class="line">// with语句中的禁例</span><br><span class="line">with (0) let x = 300</span><br></pre></td></tr></table></figure></p>
<p>所以，现在可以确定：循环语句（对于支持“let/const”的 for 语句来说）“通常情况下”只支持一个块级作用域。更进一步地说，在上面的代码中，我们并没有机会覆盖 for 语句中的“let/const”声明。</p>
<p>但是对于下面这个例子来说，“只有一个块级作用域”就不够了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">for (let i in x) ...;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，“let i …”在语义上就需要被执行多次——因为在静态结构中它的多次迭代都作用于同一个语法元素。而你是知道的，let 语句的变量不能重复声明的。所以，这里就存在了一个冲突：“let/const”语句的单次声明（不可覆盖）的设计，与迭代多次执行的现实逻辑矛盾了。</p>
<p>这个矛盾的起点，就是“只有一个块级作用域”。所以，在 JavaScript 引擎实现“支持 <em>let/const</em> 的 for 语句”时，就在这个地方做了特殊处理：为循环体增加一个作用域。</p>
<p>这样一来，“let i”就可以只执行一次，然后将“i in x”放在每个迭代中来执行，这样避免了与“let/const”的设计冲突。</p>
<h3 id="for-循环的代价"><a href="#for-循环的代价" class="headerlink" title="for 循环的代价"></a>for 循环的代价</h3><p>块语句在每个迭代中都会都会创建一次它自己的块级作用域副本。这个循环体越大，支持的层次越多，那么这个环境的创建也就越频繁，代价越高昂。再加上可以使用函数闭包将环境传递出去，或交给别的上下文引用，这里的负担就更是雪上加霜了。</p>
<p>也就是所谓“循环与函数递归在语义上等价”。所以在事实上，上述这种 for 循环并不比使用函数递归节省开销。在函数调用中，这里的循环变量通常都是通过函数参数传递来处理的。因而，那些支持“let/const”的 for 语句，本质上也就与“在函数参数界面中传递循环控制变量的递归过程”完全等价，并且在开销上也是完全一样的。</p>
<p>因为每一次函数调用其实都会创建一个新的闭包——也就是函数的作用域的一个副本。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>核心原理</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack基础用法</title>
    <url>/2020/03/14/webpack%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>webpack 的基础用法之核心概念</p>
<a id="more"></a>
<h3 id="entry-入口文件"><a href="#entry-入口文件" class="headerlink" title="entry 入口文件"></a>entry 入口文件</h3><h4 id="单入口文件"><a href="#单入口文件" class="headerlink" title="单入口文件"></a>单入口文件</h4><p>entry是一个字符串<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;xxx.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="多入口文件"><a href="#多入口文件" class="headerlink" title="多入口文件"></a>多入口文件</h4><p>entry是一个对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: &apos;index.js&apos;,</span><br><span class="line">    search: &apos;search.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>output 用来告诉webpack如何将编译后的文件，输出到磁盘</p>
<h4 id="单入口文件-1"><a href="#单入口文件-1" class="headerlink" title="单入口文件"></a>单入口文件</h4><p>只需指定output 的filename及path两个参数即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;&apos;path)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;xxx.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.join(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;production&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多入口文件-1"><a href="#多入口文件-1" class="headerlink" title="多入口文件"></a>多入口文件</h4><p>在output中没有多入口文件说法，而是通过占位符来确保输出的文件名称唯一<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;&apos;path)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: &apos;index.js&apos;,</span><br><span class="line">    search: &apos;search.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    path: path.join(__dirname, dist)</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;production&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p>webpack 开箱即用只支持JS和JSON两种文件类型。需要通过loaders去支持其他文件类型并将它们转化成有效的模块，并且可以添加到依赖图中。<br>loader本身是一个函数，接受源文件作为参数，返回转换的结果。</p>
<h4 id="常见的loader"><a href="#常见的loader" class="headerlink" title="常见的loader"></a>常见的loader</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>babel-loader</td>
<td>转换es6、es7等新特性语法</td>
</tr>
<tr>
<td>css-loader</td>
<td>支持.css文件的加载和解析</td>
</tr>
<tr>
<td>less-loader</td>
<td>将less文件转换为css</td>
</tr>
<tr>
<td>ts-loader</td>
<td>将TS转换为JS</td>
</tr>
<tr>
<td>file-loader</td>
<td>进行图片、字体等的打包</td>
</tr>
<tr>
<td>raw-loader</td>
<td>将文件以字符串的形式导入</td>
</tr>
<tr>
<td>thread-loader</td>
<td>多进程打包js和css</td>
</tr>
</tbody>
</table>
<h4 id="loader-的用法"><a href="#loader-的用法" class="headerlink" title="loader 的用法"></a>loader 的用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">   ... // entry output 等省略</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">          test: &apos;/\.txt$/&apos;, // test 指定匹配规则</span><br><span class="line">          use: &apos;raw-loader&apos; // use 指定使用的loader名称</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="例1-解析ES6"><a href="#例1-解析ES6" class="headerlink" title="例1:  解析ES6"></a>例1:  解析ES6</h4><p>需要使用babel-loader 去解析，babel-loader又依赖于babel,所以项目中需要使用.babelrc文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 安装解析ES6依赖</span><br><span class="line">$ npm i @babel/core @babel/preset-env @babel-loader -D</span><br></pre></td></tr></table></figure>
<p>项目中新增.babelrc文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// .babelrc</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot; : [ // 一系列plugins的集合  </span><br><span class="line">    &quot;@babel/preset-env&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改webpack.config.js </span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ... // 省略entry output </span><br><span class="line">  mode: &apos;production&apos;,</span><br><span class="line">  module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            use: &apos;babel-loader&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ rm -rf dist  // 清理当前dist目录</span><br><span class="line">$ npm run build // 打包编译查看效果</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="例2-解析React-JSX"><a href="#例2-解析React-JSX" class="headerlink" title="例2: 解析React JSX"></a>例2: 解析React JSX</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i react react-dom @bebel/preset-react -D</span><br><span class="line"> // search.js</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDom from &apos;react-dom&apos;</span><br><span class="line"></span><br><span class="line">class Search extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;Search Text &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">  &lt;Search /&gt;,</span><br><span class="line">document.getElementById(&apos;root&apos;)</span><br><span class="line">)</span><br><span class="line">$ npm run build</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="例3-解析css-、less"><a href="#例3-解析css-、less" class="headerlink" title="例3 : 解析css 、less"></a>例3 : 解析css 、less</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 解析 css</span><br><span class="line">// 下载 css-loader 用于加载css文件，并且转换成commonJs对象</span><br><span class="line">// 下载 style-loader 将样式通过style标签，插入到head中</span><br><span class="line">// less-loader 将css 转换成css</span><br><span class="line">$ npm i css-loader style-loader less less-loader -D</span><br><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ... // 省略entry output </span><br><span class="line">  mode: &apos;production&apos;,</span><br><span class="line">  module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            use: &apos;babel-loader&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.css$/,</span><br><span class="line">            use: [ &apos;style-loader&apos;, &apos;css-loader&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>需注意，loader是链式调用，执行方式是从右到左，所以在css应先css-loader解析css，然后传递给style-loader</strong></p>
<hr>
<h3 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h3><p>插件用于bundle文件的优化，资源管理和环境变量注入。<br>作用于整个构建过程。<br>可以理解为 loaders没办法做的事情，通过plugins来完成，如在打包前，手动删除打包目录，可用plugins来完成。</p>
<h4 id="常见的plugins"><a href="#常见的plugins" class="headerlink" title="常见的plugins"></a>常见的plugins</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CommonChunkPlugin</td>
<td>讲chunks相同的模块代码，提取成公共js</td>
</tr>
<tr>
<td>CleanWebpackPlugin</td>
<td>清理构建目录</td>
</tr>
<tr>
<td>CopyWebpackPlugin</td>
<td>将文件或文件夹拷贝到构建的输出目录</td>
</tr>
<tr>
<td>ExtractTextWebpackPlugin</td>
<td>将css从bundle文件里提取成一个独立的css文件</td>
</tr>
<tr>
<td>HtmlWebpackPlugin</td>
<td>创建html文件去承载输出的bundle</td>
</tr>
<tr>
<td>UglifyjsWebpackPlugin</td>
<td>压缩JS</td>
</tr>
<tr>
<td>ZipWebpackPlugin</td>
<td>将打包出的资源生成一个zip包</td>
</tr>
</tbody>
</table>
<h3 id="mode-环境"><a href="#mode-环境" class="headerlink" title="mode 环境"></a>mode 环境</h3><p>mode用来指定当前当前的构建环境是 production、development、none。<br>webpack 4之前没有这个概念，使用mode的好处是可以使用webpack的内置函数。如设置成development，将在开发阶段启动用于开发时使用的参数配置。</p>
<h4 id="mode函数的内置功能"><a href="#mode函数的内置功能" class="headerlink" title="mode函数的内置功能"></a>mode函数的内置功能</h4><table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>development</td>
<td>设置process.env.NODE_ENV 的值为 development，开启NameChunksPlugin和NameModulesPlugin.</td>
</tr>
<tr>
<td>production</td>
<td>开启FlagDependenUsagePlugin , FlagIncludedChunksPlugin , ModuleConcatenationPlugin等</td>
</tr>
<tr>
<td>none</td>
<td>不开启任何优化选项</td>
</tr>
</tbody>
</table>
<h3 id="文件监听"><a href="#文件监听" class="headerlink" title="文件监听"></a>文件监听</h3><p>文件监听，是在源码发生变化时，自动重新构建出新的输出文件</p>
<h4 id="webpack的两种监听方式"><a href="#webpack的两种监听方式" class="headerlink" title="webpack的两种监听方式"></a>webpack的两种监听方式</h4><ol>
<li>启动webpack时，带上 –watch 参数 。美中不足是每次都需要手动刷新浏览器。</li>
<li>在配置webapack.config.js 中设置watch:true<h4 id="文件监听的原理"><a href="#文件监听的原理" class="headerlink" title="文件监听的原理"></a>文件监听的原理</h4></li>
</ol>
<ul>
<li>轮询判断文件的最后编辑时间是否发生变化</li>
<li>某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等待一段时间(aggregateTimeout)，若其它文件也有发生变化，则会将变化的文件列表一起去构建，生成到bundle中。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.export = &#123;</span><br><span class="line">  watch: true // 默认为false 不开启</span><br><span class="line">  watchOptions: &#123; // 只有开启了监听模式，watchOptions 才有意义</span><br><span class="line">    ignored: /node_modules/, // 默认为空，不监听的文件或文件夹，支持正则匹配</span><br><span class="line">    aggregateTimeout: 300, // 监听到变化后，会等300ms再去执行，默认为300ms</span><br><span class="line">    poll: 1000, // 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒询问1000次</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="webpack-dev-server-热更新"><a href="#webpack-dev-server-热更新" class="headerlink" title="webpack-dev-server 热更新"></a>webpack-dev-server 热更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// pageage.json </span><br><span class="line">scripts: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">&#125;</span><br><span class="line">$ npm i webpack-dev-server -D</span><br><span class="line"></span><br><span class="line">// webpack.config.js</span><br><span class="line">const webapck = require(&apos;webpack&apos;)</span><br><span class="line">module.export = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123; // webpack服务基础目录</span><br><span class="line">    contentBase: &apos;./dist&apos;,</span><br><span class="line">    hot: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure>
<h4 id="webpack原理分析"><a href="#webpack原理分析" class="headerlink" title="webpack原理分析"></a>webpack原理分析</h4><p>首先了解几个概念：</p>
<ul>
<li>webpack Compile: 将Js编译成Bundle</li>
<li>HMR Server: 将热更新的文件传输给 HMR Runtime</li>
<li>Bundle Server : 提供文件在浏览器端的访问</li>
<li>HMR Runtime: 会被更新到浏览器，更新文件的变化</li>
<li>bundle.js ： 构建输出的文件</li>
</ul>
<h4 id="热更新的过程"><a href="#热更新的过程" class="headerlink" title="热更新的过程"></a>热更新的过程</h4><p>热更新有两个过程。</p>
<ol>
<li>文件的启动阶段<br>将初始代码经文件系统进行编译, 使用webpack Compile进行打包，打包好的bundle.js传输给bundle Server（服务器） ,bundle Server以server的方式让浏览器访问到。</li>
<li>代码更新阶段<br>文件系统(代码)更新后，使用webpack Compile 打包，传输给HMR Server, HMR Server(服务端)将发生变化的文件告知HMR Runtime(浏览器端)，通常以JSON数据的形式进行传输，HMR Runtime 更新代码，实现不刷新更新。</li>
</ol>
<h3 id="文件指纹"><a href="#文件指纹" class="headerlink" title="文件指纹"></a>文件指纹</h3><p>打包后输出的文件名后缀。</p>
<h4 id="文件指纹的生成"><a href="#文件指纹的生成" class="headerlink" title="文件指纹的生成"></a>文件指纹的生成</h4><ul>
<li><strong>Hash</strong> 和整个项目的构建有关，只要项目文件有更改，整个构建项目的hash值就会更改。</li>
<li><strong>Chunkhash</strong> 和webpack打包的chunk有关，不同的entry会生成不同的Chunkhash</li>
<li><strong>Contenthash</strong> 根据文件内容更新hash，文件内容不变，Contenthash不变。<strong>注：js 没有contenthash。</strong></li>
</ul>
<h4 id="js文件指纹设置"><a href="#js文件指纹设置" class="headerlink" title="js文件指纹设置"></a>js文件指纹设置</h4><p>设置output的filename,使用chunkhash<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.export = &#123;</span><br><span class="line">   // ... </span><br><span class="line">  output: &apos;[filename][chunkhash:8].js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="css文件指纹设置"><a href="#css文件指纹设置" class="headerlink" title="css文件指纹设置"></a>css文件指纹设置</h4><p>一般情况下，若项目中配置使用了style-loader和css-loader,会将编译好的css，使用style-loader插入到head中，没有独立的css文件，所以需要借用MiniCssExtractPlugin将style-loader 中的css提取为一个独立的文件，使用contenthash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">   plugins: [</span><br><span class="line">     new MiniCssExtractPlugin(&#123; filename: `[name][contenthash:8].js` &#125;)</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图片文件指纹设置"><a href="#图片文件指纹设置" class="headerlink" title="图片文件指纹设置"></a>图片文件指纹设置</h4><p>设置file-loader的name使用[hash]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">// webpack.config.js</span><br><span class="line">module.export = &#123;</span><br><span class="line">  // ..</span><br><span class="line">  module: &#123;</span><br><span class="line">    rule: [</span><br><span class="line">      test: /\.(svg|png|jpeg|gif)$/,</span><br><span class="line">      use: [</span><br><span class="line">        loader: &apos;file-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: &apos;img/[name][hash:8].[ext]&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<table>
<thead>
<tr>
<th>占位符名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ext</td>
<td>资源后缀名</td>
</tr>
<tr>
<td>name</td>
<td>文件名称</td>
</tr>
<tr>
<td>path</td>
<td>文件相对路径</td>
</tr>
<tr>
<td>folder</td>
<td>文件所在的文件夹</td>
</tr>
<tr>
<td>contenthash</td>
<td>文件内容的hash, 默认md5生成</td>
</tr>
<tr>
<td>hash</td>
<td>文件内容的hash, 默认md5生成</td>
</tr>
<tr>
<td>emoji</td>
<td>一个随机的指代文件内容的emoji</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><h4 id="JS代码压缩"><a href="#JS代码压缩" class="headerlink" title="JS代码压缩"></a>JS代码压缩</h4><p>webpack4中内置了 uglifyjs-webpack-plugin 不需要再做处理了。</p>
<h4 id="css代码压缩"><a href="#css代码压缩" class="headerlink" title="css代码压缩"></a>css代码压缩</h4><p>使用optimize-css-assets-webpack-plugin，同时使用 cssnano（css预处理器）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i optimize-css-assets-webpack-plugin cssnano -D</span><br><span class="line">// webpack.prod.js</span><br><span class="line">const OptimizeCssAssetsWebpackPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)</span><br><span class="line">modele.export = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new OptimizeCssAssetsWebpackPlugin(&#123;</span><br><span class="line">      assetNameRegExp: /\.css$/,</span><br><span class="line">      assetProcessor: require(&apos;cssnano&apos;)</span><br><span class="line">   &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="html代码压缩"><a href="#html代码压缩" class="headerlink" title="html代码压缩"></a>html代码压缩</h4><p>使用html-webpack-plugin设置压缩参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i html-webpack-plugin -D</span><br><span class="line">// webpack.prod.js</span><br><span class="line">const OptimizeCssAssetsWebpackPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)</span><br><span class="line">modele.export = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, &apos;search.html&apos;), // 模板所在位置</span><br><span class="line">      filename: &apos;search.html&apos;, // 打包后文件名</span><br><span class="line">      chunks: &apos;search&apos;, // 使用的chunk</span><br><span class="line">      inject: true, // 自动注入css,js</span><br><span class="line">      minify: &#123;</span><br><span class="line">        html5: true,</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        preserveLineBreaks: false,</span><br><span class="line">        minifyCSS: true,</span><br><span class="line">        minifyJS: true,</span><br><span class="line">        removeComments: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack进阶语法</title>
    <url>/2020/03/18/webpack%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>webpack进阶语法</p>
<a id="more"></a>
<h3 id="自动清理构建目录产物"><a href="#自动清理构建目录产物" class="headerlink" title="自动清理构建目录产物"></a>自动清理构建目录产物</h3><h4 id="修改build构建命令"><a href="#修改build构建命令" class="headerlink" title="修改build构建命令"></a>修改build构建命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 修改build构建方式命令</span><br><span class="line">$ rm -rf ./dist &amp;&amp; webpack </span><br><span class="line">$ ramraf ./dist &amp;&amp; webpack</span><br></pre></td></tr></table></figure>
<h4 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h4><p>引入该插件之后，构建前会先删除output指定的文件目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i clean-webpack-plugin -D</span><br><span class="line">// webpack.prod.js</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;)</span><br><span class="line">module.export = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new CleanWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动补齐css3前缀"><a href="#自动补齐css3前缀" class="headerlink" title="自动补齐css3前缀"></a>自动补齐css3前缀</h3><p>css3使用不同的前缀，兼容不同浏览器内核。</p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>内核</th>
<th>前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>IE、</td>
<td>Trident</td>
<td>-ms</td>
</tr>
<tr>
<td>fireFox</td>
<td>Geko</td>
<td>-moz</td>
</tr>
<tr>
<td>欧朋</td>
<td>presto</td>
<td>-o</td>
</tr>
<tr>
<td>Chrome</td>
<td>Webkit</td>
<td>-webkit</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 例</span><br><span class="line">.box &#123;</span><br><span class="line">  -moz-border-radius: 10px;</span><br><span class="line">  -webkit-border-radius: 10px;</span><br><span class="line">  -o-border-radius: 10px;</span><br><span class="line">  border-radius: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PostCss插件-autoPrefixer自动补齐css前缀"><a href="#PostCss插件-autoPrefixer自动补齐css前缀" class="headerlink" title="PostCss插件 autoPrefixer自动补齐css前缀"></a>PostCss插件 autoPrefixer自动补齐css前缀</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在解析css的loader中添加 postcss-loader</span><br><span class="line">&#123;</span><br><span class="line">  loader: &apos;postcss-loader&apos;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    plugins: () =&gt; &#123;</span><br><span class="line">      require(&apos;autoprefixer&apos;)(&#123;</span><br><span class="line">        // 兼容最后两个版本以上，用户&gt;1% ，iOS 7</span><br><span class="line">        overrideBrowserslist: [&apos;last 2 version&apos;, &apos;&gt; 1%&apos;, &apos;ios 7&apos;] </span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移动端css-px-转换成-rem"><a href="#移动端css-px-转换成-rem" class="headerlink" title="移动端css px 转换成 rem"></a>移动端css px 转换成 rem</h3><p>由于移动端设备屏幕宽度都不一样，所以需添加页面适配。</p>
<h4 id="media媒体查询"><a href="#media媒体查询" class="headerlink" title="@media媒体查询"></a>@media媒体查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media screen and(max-width: 480px) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>弊端： 需要写多套css去适配</p>
<h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>W3C对rem的定义: font-size of the root element</p>
<p><strong>rem 和px的区别</strong></p>
<ul>
<li>rem是相对单位</li>
<li>px 是绝对单位</li>
</ul>
<h4 id="px2rem-loader"><a href="#px2rem-loader" class="headerlink" title="px2rem-loader"></a>px2rem-loader</h4><ol>
<li>使用px2rem-loader ，页面渲染时计算根元素的font-size</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i px2rem-loader -D</span><br><span class="line">$ npm i lib-flexible -S</span><br><span class="line">添加loader</span><br><span class="line">&#123;</span><br><span class="line">  loader: &apos;px2rem-loader&apos;,</span><br><span class="line">  opstions: &#123;</span><br><span class="line">    remUnit: 75, // rem 相对px的单位  1rem = 75px</span><br><span class="line">    remPrecesion: 8, // 保留小数位数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>利用手淘的lib-flexible<br>由于lib-flexible是内联静态资源，所以需要手动在html文件中导入。</li>
</ol>
<h3 id="静态资源内联"><a href="#静态资源内联" class="headerlink" title="静态资源内联"></a>静态资源内联</h3><h4 id="资源内联的意义"><a href="#资源内联的意义" class="headerlink" title="资源内联的意义"></a>资源内联的意义</h4><ol>
<li>代码层面<ul>
<li>页面框架的初始化脚本</li>
<li>上报相关打点</li>
<li>css内联避免页面闪动</li>
</ul>
</li>
<li>请求层面<ul>
<li>减少 http请求，</li>
<li>小图片或者字体内联(utl-loader)</li>
</ul>
</li>
</ol>
<h4 id="HTML内联"><a href="#HTML内联" class="headerlink" title="HTML内联"></a>HTML内联</h4><p>使用raw-loader<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在html head中新增</span><br><span class="line">&lt;script&gt;$&#123;require(&apos; raw-loader!babel-loader!. /meta.html&apos;)&#125;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="Js内联"><a href="#Js内联" class="headerlink" title="Js内联"></a>Js内联</h4><p>raw-loader 内联 JS<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在html head中新增</span><br><span class="line">&lt;script&gt;$&#123;require(&apos;raw-loader!babel-loader!../node_modules/lib-flexible&apos;)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="CSS-内联"><a href="#CSS-内联" class="headerlink" title="CSS 内联"></a>CSS 内联</h4><ol>
<li><p>借助 style-loader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123; module: &#123;</span><br><span class="line">rules: [</span><br><span class="line">&#123;</span><br><span class="line">  test: /\.scss$/, </span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &apos;style-loader&apos;, </span><br><span class="line">      options: &#123;</span><br><span class="line">        insertAt: &apos;top&apos;, // 样式插入到 &lt;head&gt;</span><br><span class="line">        singleton: true, //将所有的style标签合并成一个 &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;css-loader&quot;, &quot;sass-loader&quot;</span><br><span class="line">  ], &#125;,</span><br><span class="line">] &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>html-inline-css-webpack-plugin</p>
</li>
</ol>
<h3 id="多页面应用打包-MPA"><a href="#多页面应用打包-MPA" class="headerlink" title="多页面应用打包(MPA)"></a>多页面应用打包(MPA)</h3><ol>
<li>更改项目文件目录<ul>
<li>index<ul>
<li>index.js</li>
<li>index.less</li>
</ul>
</li>
<li>search<ul>
<li>index.js</li>
<li>search.less</li>
</ul>
</li>
</ul>
</li>
<li>利用glob.sync 动态获取 entry和html-webpack-plugin的数量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编写函数</span><br><span class="line">const setMPA = () =&gt; &#123;</span><br><span class="line">  const entryFiles = glob.sync(path.join(__dirname, &apos;./src/*/index.js&apos;)) // [&apos;src/index/index.js&apos;]</span><br><span class="line"></span><br><span class="line">  const entry = &#123;&#125;</span><br><span class="line">  const htmlWebpackPlugins = []</span><br><span class="line">  Object.keys(entryFiles).map((keys) =&gt; &#123;</span><br><span class="line">    const entryFile = entryFiles[keys]</span><br><span class="line">    const match = entryFile.match(&apos;/src\/(.*)\/index\.js&apos;)</span><br><span class="line">    const pageName = match &amp;&amp; match[1]</span><br><span class="line">    entry[pageName] = entryFile</span><br><span class="line"></span><br><span class="line">    htmlWebpackPlugins.push(</span><br><span class="line">      new htmlWebpackPlugins(&#123;</span><br><span class="line">        template: path.join(__dirname, `./src/$&#123;pageName&#125;/index.js`),</span><br><span class="line">        filename: `$&#123;pageName&#125;.html`,</span><br><span class="line">        inject: true,</span><br><span class="line">        chunks: [pageName],</span><br><span class="line">        minify: &#123;</span><br><span class="line">          html5: true,</span><br><span class="line">          collapseWhitespace: true,</span><br><span class="line">          preserveLineBreaks: false,</span><br><span class="line">          minifyCSS: true,</span><br><span class="line">          minifyJS: true,</span><br><span class="line">          removeComments: false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      entry,</span><br><span class="line">      htmlWebpackPlugins</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins: [].concat(htmlWebpackPlugins)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><p>通过 source map 定位到源代码。<br>开发环境开启，线上环境关闭，不然会暴露业务代码。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul>
<li>eval: 使⽤用eval包裹模块代码 </li>
<li>source map: 产⽣生.map⽂文件 </li>
<li>cheap: 不不包含列列信息<br>inline: 将.map作为DataURI嵌⼊js中，不不单独⽣生成.map⽂文件 </li>
<li>module:包含loader的sourcemap</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.prod.js</span><br><span class="line"></span><br><span class="line">devtools: &apos;source-map&apos; // 或其他类型 inline ...</span><br></pre></td></tr></table></figure>
<h3 id="体积优化策略"><a href="#体积优化策略" class="headerlink" title="体积优化策略"></a>体积优化策略</h3><ul>
<li>Scope Hoisting</li>
<li>Tree-shaking</li>
<li>公共资源分离</li>
<li>图片压缩</li>
<li>动态polyfill</li>
</ul>
<h3 id="提取公共资源"><a href="#提取公共资源" class="headerlink" title="提取公共资源"></a>提取公共资源</h3><h4 id="分离基础库"><a href="#分离基础库" class="headerlink" title="分离基础库"></a>分离基础库</h4><p>如项目中使用react,react-dom,可以使用html-webpack- externals-plugin将 react、react-dom 基础 包通过 cdn 引⼊入，不打⼊入 bundle 中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.prod.js</span><br><span class="line">new htmlWebpackExternalPlugin(&#123;</span><br><span class="line">      externals: [</span><br><span class="line">        &#123;</span><br><span class="line">          module: &apos;react&apos;,</span><br><span class="line">          entry: &apos;https://11.url.cn/now/lib/16.2.0/react.min.js&apos;,</span><br><span class="line">          global: &apos;React&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          module: &apos;react-dom&apos;,</span><br><span class="line">          entry: &apos;https://11.url.cn/now/lib/16.2.0/react-dom.min.js&apos;,</span><br><span class="line">          global: &apos;ReactDOM&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">// index.js</span><br><span class="line">&lt;script src=&quot;https://11.url.cn/now/lib/16.2.0/react.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://11.url.cn/now/lib/16.2.0/react-dom.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">// 这里之所以在页面上引入cdn文件，是因为将html-externals-plugin写在了html-webpack-plugin之前，导致html-webpack-externals-plugin执行时找不到html插入对应的entry地址,所以还需手动引入。</span><br></pre></td></tr></table></figure></p>
<h4 id="利用SplitChunksPlugin"><a href="#利用SplitChunksPlugin" class="headerlink" title="利用SplitChunksPlugin"></a>利用SplitChunksPlugin</h4><p>webpack 4中的内置插件。<br>chunks 参数说明:</p>
<ul>
<li>async 异步引⼊入的库进⾏行行分离(默认)</li>
<li>initial 同步引⼊入的库进⾏行行分离</li>
<li>all 所有引⼊入的库进⾏行行分离(推荐)</li>
</ul>
<h5 id="分离基础包"><a href="#分离基础包" class="headerlink" title="分离基础包"></a>分离基础包</h5><p>test: 匹配出需要分离的包<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123; </span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          test: /(react|react-dom)/,</span><br><span class="line">          name: &apos;vendors&apos;, // 打出的包名</span><br><span class="line">	  chunks: &apos;all&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="分离公共文件"><a href="#分离公共文件" class="headerlink" title="分离公共文件"></a>分离公共文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123; </span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      minSize: 0, </span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          name: &apos;commons&apos;, // 打包出的文件名</span><br><span class="line">          chunks: &apos;all&apos; ,</span><br><span class="line">          minChunks: 2, // 至少使用的次数</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tree-shaking-摇数优化"><a href="#tree-shaking-摇数优化" class="headerlink" title="tree shaking (摇数优化)"></a>tree shaking (摇数优化)</h3><ul>
<li>概念: 1个模块可能有多个⽅法，只要其中的某个方法使⽤到了，则整个文件都会被打到 bundle ⾥面去，tree shaking 就是只把⽤到的⽅法打⼊ bundle ，没⽤用到的⽅法会在 uglify 阶段被擦除掉。</li>
<li>使⽤: webpack 默认⽀支持，在 .babelrc ⾥里里设置 modules: false 即可 · production mode的情况下默认开启</li>
<li>要求: 必须是 ES6 的语法，CJS 的⽅方式不不⽀支持</li>
<li>生产环境下，默认开启 tree-shaking<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4></li>
<li>DCE(Dead code elimination)<br>代码不会被执行，不可到达<br>代码执行的结果不会被⽤用到<br>代码只会影响死变量(只写不读)</li>
<li>利用 ES6 模块的特点: <ol>
<li>只能作为模块顶层的语句出现</li>
<li>import 的模块名只能是字符串串常量量</li>
<li>import binding 是 immutable的 </li>
<li>代码擦除: uglify 阶段删除⽆无⽤用代码<h4 id="删除无用的CSS"><a href="#删除无用的CSS" class="headerlink" title="删除无用的CSS"></a>删除无用的CSS</h4></li>
</ol>
</li>
<li><p>PurifyCss : 遍历代码，识别已经用到的css class<br>使用purgecss-webpack-plugin 和mini-css-extract-webpack-plugin 配合使用。</p>
</li>
<li><p>uncess : HTML需要通过jsdom加载，所有的样式通过postCss解析，通过document.querySelector来识别在HTML文件里面不存在的选择器。</p>
</li>
</ul>
<h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3><p>要求: 基于node库的imagemin或者tinypngAPI<br>使用: 配置image-webpack-loader<br>优点:</p>
<ol>
<li>支持定制选项</li>
<li>可以引入更多的第三方插件，如pngquant</li>
<li>可以处理多种图片格式</li>
</ol>
<h3 id="scope-hoisting"><a href="#scope-hoisting" class="headerlink" title="scope hoisting"></a>scope hoisting</h3><p>webpack 4 默认开启<br>构建后的代码，存在大量的闭包，会增大bundle文件，运行时创建的函数作用于变多，内存开销增大。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>将所有模块的代码按照引用顺序放到一个函数作用域里，然后适当的重命名一些变量防止重名。</p>
<h3 id="代码分割和动态import"><a href="#代码分割和动态import" class="headerlink" title="代码分割和动态import"></a>代码分割和动态import</h3><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>对于大的 Web 应⽤用来讲，将所有的代码都放在⼀个⽂件中显然是不不够有效的，特别是当某些代码块是在某些特殊的时候才会被使⽤到时。webpack 有一个功能就是将你的代码库分割成 chunks(语块)，当代码运⾏到需要它们的时候再进⾏加载。</p>
<h4 id="适用的场景"><a href="#适用的场景" class="headerlink" title="适用的场景"></a>适用的场景</h4><ul>
<li>抽离相同代码到⼀一个共享块</li>
<li>脚本懒加载，使得初始下载的代码更更⼩小<h4 id="懒加载Js的方式"><a href="#懒加载Js的方式" class="headerlink" title="懒加载Js的方式"></a>懒加载Js的方式</h4></li>
<li>CommonJS:require.ensure</li>
<li>ES6:动态 import(目前还没有原⽣生⽀支持，需要 babel 转换)</li>
</ul>
<h3 id="优化构建时命令行显示的日志"><a href="#优化构建时命令行显示的日志" class="headerlink" title="优化构建时命令行显示的日志"></a>优化构建时命令行显示的日志</h3><h4 id="统计信息-stats"><a href="#统计信息-stats" class="headerlink" title="统计信息 stats"></a>统计信息 stats</h4><p>常用的数据值</p>
<table>
<thead>
<tr>
<th>Preset</th>
<th>Alternative</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>errors-only</td>
<td>none</td>
<td>只在发生错误时输出</td>
</tr>
<tr>
<td>minimal</td>
<td>none</td>
<td>只在发生错误或新编译时输出</td>
</tr>
<tr>
<td>none</td>
<td>false</td>
<td>没有输出</td>
</tr>
<tr>
<td>normal</td>
<td>true</td>
<td>标准输出</td>
</tr>
<tr>
<td>verbose</td>
<td>none</td>
<td>全部输出</td>
</tr>
</tbody>
</table>
<h4 id="借助friendly-errors-webpack-plugin插件"><a href="#借助friendly-errors-webpack-plugin插件" class="headerlink" title="借助friendly-errors-webpack-plugin插件"></a>借助friendly-errors-webpack-plugin插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpack.prod.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  stats: &apos;errors-only&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建异常和中断处理"><a href="#构建异常和中断处理" class="headerlink" title="构建异常和中断处理"></a>构建异常和中断处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $? // 获取错误码 0 为成功，非0失败</span><br></pre></td></tr></table></figure>
<h4 id="捕获并处理构建异常"><a href="#捕获并处理构建异常" class="headerlink" title="捕获并处理构建异常"></a>捕获并处理构建异常</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.prod.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  function() &#123;</span><br><span class="line">      this.hooks.done.tap(&apos;done&apos;, (stats) =&gt; &#123; </span><br><span class="line">        if (stats.compilation.errors &amp;&amp;</span><br><span class="line">          stats.compilation.errors.length </span><br><span class="line">          &amp;&amp; process.argv.indexOf(&apos;- -watch&apos;) == -1)</span><br><span class="line">          &#123;</span><br><span class="line">            console.log(&apos;build error&apos;);</span><br><span class="line">            process.exit(1); </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;) </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析webpack"><a href="#分析webpack" class="headerlink" title="分析webpack"></a>分析webpack</h3><p>执行 npm run build 或npm run dev 等命令行时，实际是执行的node_modules/webpack/bin/webpack.js文件。</p>
<h4 id="分析webpack-js"><a href="#分析webpack-js" class="headerlink" title="分析webpack.js"></a>分析webpack.js</h4><ul>
<li>process.exitCode = 0;<br>表示程序正常执行返回，error为null，exitCode 为0</li>
<li>const runCommand = (command, args) =&gt; {…} 表示执行某个命令,如 npm install </li>
<li>const isInstalled = packageName =&gt; {…} 判断某个包是否存在。</li>
<li>const CLIs = […] webpack 中可用的cli,webpack-cli、webpack-command</li>
<li>const isInstalledClis = … 判断webpack的是够安装了以上两个cli</li>
<li>if (installedClis.length === 0) {…} 根据安装的数量进行处理</li>
</ul>
<p>webpack启动后，会找到webpack-cli文件,启动webpack-cli文件</p>
<h4 id="分析webpack-cli"><a href="#分析webpack-cli" class="headerlink" title="分析webpack-cli"></a>分析webpack-cli</h4><ul>
<li>引入yargs,对命令行进行定制</li>
<li>分析命令行参数,对各个参数进行转换,组成编译配置项</li>
<li>引用webpack,根据配置项进行编译和构建</li>
</ul>
<h4 id="webpack-cli-bin-cli-js分析"><a href="#webpack-cli-bin-cli-js分析" class="headerlink" title="webpack-cli/bin/cli.js分析"></a>webpack-cli/bin/cli.js分析</h4><ul>
<li>const { NON_COMPILITION_ARGS} = utils/contants.js const NON_COMPLITION_CMD = … 处理不需要编译的命令</li>
<li>…</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端梳理</title>
    <url>/2020/04/21/%E5%89%8D%E7%AB%AF%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>前端知识体系大体上可分为 JavaScript、HTML、CSS 以及浏览器的实现原理和 API</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JavaScript 的数据类型有 7 种语言类型 Undefined、Null、Boolean、String、Number、Symbol、Object。</p>
<h4 id="undefined-和-NULL"><a href="#undefined-和-NULL" class="headerlink" title="undefined 和 NULL"></a>undefined 和 NULL</h4><p>Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值，或者 void 运算来把任意一个表达式变成 undefined 值<br>Undefined 跟 Null 有一定的表意差别，Null 表示的是：“定义了但是为空”。<br>Null 类型也只有一个值，就是 null，它的语义表示空值，undefined 是一个变量，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。</p>
<h5 id="为什么有的编程规范要求用-void-0-代替-undefined？"><a href="#为什么有的编程规范要求用-void-0-代替-undefined？" class="headerlink" title="为什么有的编程规范要求用 void 0 代替 undefined？"></a>为什么有的编程规范要求用 void 0 代替 undefined？</h5><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>Boolean 类型有两个值， true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>用于表示文本数据类型。<br>String 有最大长度是 2^53 - 1。所谓最大长度，并不完全是字符数，因为 String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。</p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><ul>
<li>NaN</li>
<li>Infinity，无穷大</li>
<li>-Infinity，负无穷大</li>
</ul>
<h5 id="0-1-0-2-为什么不等于-0-3"><a href="#0-1-0-2-为什么不等于-0-3" class="headerlink" title="0.1 + 0.2 为什么不等于 0.3 ?"></a>0.1 + 0.2 为什么不等于 0.3 ?</h5><p>根据浮点数的定义，非整数的 Number 类型无法用 == （=== 也不行)来比较.<br>实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值.检查等式左右两边差的绝对值是否小于最小精度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log( 0.1 + 0.2 == 0.3)</span><br><span class="line">console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON)</span><br></pre></td></tr></table></figure>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑</p>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。<br>在 JavaScript 中，对象的定义是”属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。</p>
<h5 id="对象的特征"><a href="#对象的特征" class="headerlink" title="对象的特征"></a>对象的特征</h5><ul>
<li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。<br>一般而言，各种语言的对象唯一标识性都是用内存地址来体现的， 对象具有唯一标识的内存地址，所以具有唯一的标识。</li>
<li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li>
<li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。<br>在 JavaScript 中，将状态和行为统一抽象为属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o = &#123; // o 是一个对象</span><br><span class="line"></span><br><span class="line">        d: 1, // d 是对象o的一个属性</span><br><span class="line">        f() &#123; // 函数 f也是对象o的一个属性</span><br><span class="line">            console.log(this.d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象具有高度的动态性，因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o = &#123; a: 1 &#125;;</span><br><span class="line">    o.b = 2;</span><br><span class="line">    console.log(o.a, o.b); //1 2</span><br></pre></td></tr></table></figure>
<h5 id="对象的两类属性"><a href="#对象的两类属性" class="headerlink" title="对象的两类属性"></a>对象的两类属性</h5><p>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。</p>
<ul>
<li><p>数据属性<br>它比较接近于其它语言的属性概念。数据属性具有四个特征:</p>
<ol>
<li>value：就是属性的值。</li>
<li>writable：决定属性能否被赋值。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ol>
<p>在大多数情况下，我们只关心数据属性的值即可。</p>
</li>
<li><p>访问器（getter/setter）属性</p>
<ol>
<li>getter：函数或 undefined，在取属性值时被调用。</li>
<li>setter：函数或 undefined，在设置属性值时被调用。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ol>
<p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p>
</li>
</ul>
<h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><ul>
<li>原型系统的“复制操作”思路<ol>
<li>并不是真的去复制一个原型对象，而是使得新对象持有一个原型的引用。</li>
<li>切实地复制对象，从此两个对象再无关联</li>
</ol>
</li>
<li>Js 原型系统<ol>
<li>如果所有对象都有私有字段[[prototype]]，就是对象的原型。</li>
<li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</li>
</ol>
</li>
</ul>
<p>ES6 提供了一系列的内置函数，以便更为直接地访问操纵原型。三个方法分别为：</p>
<ol>
<li>Object.create 根据指定的原型创建新对象，原型可以是 null</li>
<li>Object.getPrototypeOf 获得一个对象的原型；</li>
<li>Object.setPrototypeOf 设置一个对象的原型。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cat = &#123;</span><br><span class="line">  say() &#123;</span><br><span class="line">    console.log(&apos;meow!&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  jump() &#123;</span><br><span class="line">    console.log(&apos;jump&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tiger = Object.create(cat, &#123;</span><br><span class="line">  say: &#123;</span><br><span class="line">    writable: true,</span><br><span class="line">    value: function()&#123;</span><br><span class="line">      console.log(&apos;roar!&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var otherCat = Object.create(cat)</span><br><span class="line">otherCat.say()</span><br><span class="line"></span><br><span class="line">var otherTiger = Object.create(tiger)</span><br><span class="line">otherTiger.say()</span><br><span class="line">otherTiger.jump()</span><br></pre></td></tr></table></figure>
<h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><p>new 运算接受一个构造器和一组调用参数，实际上做了几件事：</p>
<ol>
<li>以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象；</li>
<li>将 this 和调用参数传给构造器，执行；</li>
<li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li>
</ol>
<p>new 这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function c1()&#123;</span><br><span class="line">  // 直接在构造器中修改 this，给 this 添加属性</span><br><span class="line">  this.p1 = 1;</span><br><span class="line">  this.p2 = function () &#123;</span><br><span class="line">    console.log(this.p1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o1 = new c1()</span><br><span class="line">o1.p2()</span><br><span class="line"></span><br><span class="line">function c2() &#123;</span><br><span class="line">  // 修改构造器的 prototype 属性指向的对象，它是从这个构造器构造出来的所有对象的原型</span><br><span class="line">  this.prototype.p1 = 1;</span><br><span class="line">  this.prototype.p2 = function () &#123;</span><br><span class="line">    console.log(this.p1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o2 = new c2;</span><br><span class="line">o2.p2();</span><br></pre></td></tr></table></figure>
<h5 id="class"><a href="#class" class="headerlink" title="class"></a>class</h5><p>在此不再举例赘述，创建对象的方法详见 <a href="https://blog.wangguanwei.com/2019/05/10/Js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/#more" target="_blank" rel="noopener">Js 创建对象</a></p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>因为 JS 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。</p>
<h5 id="StringToNumber"><a href="#StringToNumber" class="headerlink" title="StringToNumber"></a>StringToNumber</h5><p>字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制。如 30、0b111、0o13、0xFF<br>此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示。如 1e3、-1e-2。</p>
<h5 id="NumberToString"><a href="#NumberToString" class="headerlink" title="NumberToString"></a>NumberToString</h5><p>在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。</p>
<h5 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h5><p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。</p>
<ul>
<li>Symbol<br>全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var symbolObject = (function() &#123;return this&#125;.call(Symbol(&quot;a&quot;)))</span><br><span class="line">console.log(typeof symbolObject); //object</span><br><span class="line">console.log(symbolObject instanceof Symbol); //true</span><br><span class="line">console.log(symbolObject.constructor == Symbol); //true</span><br></pre></td></tr></table></figure>
<h4 id="对象的分类"><a href="#对象的分类" class="headerlink" title="对象的分类"></a>对象的分类</h4><h5 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h5><p>由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。<br>如 Date,Boolean,String, Number …等</p>
<h4 id="用对象来模拟函数与构造器：函数对象与构造器对象"><a href="#用对象来模拟函数与构造器：函数对象与构造器对象" class="headerlink" title="用对象来模拟函数与构造器：函数对象与构造器对象"></a>用对象来模拟函数与构造器：函数对象与构造器对象</h4><h5 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h5><ul>
<li>固有对象<br>固有对象是由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。<br>固有对象在任何 JavaScript 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。</li>
<li>原生对象<br>我们把 JavaScript 中，能够通过语言本身的构造器创建的对象称作原生对象。</li>
</ul>
<h3 id="事件循环-EventLoop"><a href="#事件循环-EventLoop" class="headerlink" title="事件循环(EventLoop)"></a>事件循环(EventLoop)</h3><p>主线程从<strong>任务队列</strong>中读取事件，整个过程是循环不断的，所以这种整个的运行机制被称为事件循环。</p>
<p>在操作系统中，通常等待的行为就是一个时间循环。</p>
<h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>任务队列是一个<strong>事件</strong>的队列。</p>
<p>Js 的语言特性是单线程，也就是说，同一时间只能做一件事。意味着所有的事件都需要排队，前一个任务结束，才会执行下一个任务，如果前一个任务耗时很长，那么下一个任务就只能等着。</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>在 Js 中，事件分为<strong>宏观任务</strong>和<strong>微观任务</strong>。</p>
<h5 id="宏观任务"><a href="#宏观任务" class="headerlink" title="宏观任务"></a>宏观任务</h5><p>由宿主（如浏览器）发起的任务</p>
<h5 id="微观任务"><a href="#微观任务" class="headerlink" title="微观任务"></a>微观任务</h5><p>由 Js 引擎发起的任务</p>
<p>详见<a href="https://blog.wangguanwei.com/2019/12/06/async/#more" target="_blank" rel="noopener">Js 异步</a></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包可以理解为一个绑定了执行环境的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var addNum = (() =&gt; &#123;</span><br><span class="line">  var nums = 0</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    return nums += 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受干扰。直观的说就是形成一个不销毁的栈环境。</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="移位算表达式"><a href="#移位算表达式" class="headerlink" title="移位算表达式"></a>移位算表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&lt; 向左移位</span><br><span class="line">&gt;&gt; 向右移位</span><br><span class="line">&gt;&gt;&gt; 无符号向右移位</span><br></pre></td></tr></table></figure>
<p>移位运算可以把操作数看做二进制表示的整数，然后移动特定的位数。<br>左移 n 位就相当于乘以 2 的 n 次方，右移 n 位相当于除以 2 取整 n 次方。</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HTML 的功能主要由标签来承担，根据标签的不同作用可大致分为以下几类</p>
<h3 id="文档元信息"><a href="#文档元信息" class="headerlink" title="文档元信息"></a>文档元信息</h3><p>通常是出现在 head 标签中的元素，包含了描述文档自身的一些信息。如 title、meta、style、link、base。</p>
<h3 id="语义相关"><a href="#语义相关" class="headerlink" title="语义相关"></a>语义相关</h3><p>扩展了纯文本，表达文章结构、不同语言要素的标签。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>提供到文档内和文档外的链接</p>
<h3 id="替换型标签"><a href="#替换型标签" class="headerlink" title="替换型标签"></a>替换型标签</h3><p>引入声音、图片、视频等外部元素替换自身的一类标签</p>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>用于填写和提交信息的一类标签；</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表头、表尾、单元格等表格的结构。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="布局类"><a href="#布局类" class="headerlink" title="布局类"></a>布局类</h3><h4 id="正常流"><a href="#正常流" class="headerlink" title="正常流"></a>正常流</h4><h4 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h4><h3 id="绘制类"><a href="#绘制类" class="headerlink" title="绘制类"></a>绘制类</h3><h3 id="交互类"><a href="#交互类" class="headerlink" title="交互类"></a>交互类</h3><h2 id="浏览器实现原理"><a href="#浏览器实现原理" class="headerlink" title="浏览器实现原理"></a>浏览器实现原理</h2><p>解析原理： 解析、构建 DOM 树、计算 CSS、渲染、合成和绘制。</p>
<h2 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><h3 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h3><h3 id="架构与基础库"><a href="#架构与基础库" class="headerlink" title="架构与基础库"></a>架构与基础库</h3>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>初识区块链-什么是区块链</title>
    <url>/2023/01/31/%E5%88%9D%E8%AF%86%E5%8C%BA%E5%9D%97%E9%93%BE-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<p>区块链(blockchain)究竟是个什么技术？为什么会成为热点技术？它又解决了什么问题？</p>
<a id="more"></a>
<h2 id="区块链技术的革命性"><a href="#区块链技术的革命性" class="headerlink" title="区块链技术的革命性"></a>区块链技术的革命性</h2><p>说区块链必然要谈比特币，比特币是一种数字货币，有以下几个特性。</p>
<ol>
<li><strong>去中心化。</strong> 意味着没有中心服务器，不受某个人的控制。</li>
<li><strong>数据防篡改。</strong> 所有交易记录全量保存，并公开给所有人，而且还被加密和校验。</li>
<li><strong>固定的发行量。</strong> 不会出现类似于乱印钞票的现象。</li>
</ol>
<p>这些东西加在一起，就会使得那些想作弊的人很难作恶。<br>简单来说，相信区块链的人都相信，可以通过区块链技术来改变整个社会的组织形成–不再需要银行、中介、电商平台等中间机构，人们可以通过一个不受任何人控制和操作的 P2P 金融系统，进行完全自由和可信的交易。</p>
<h2 id="去中心化记账"><a href="#去中心化记账" class="headerlink" title="去中心化记账"></a>去中心化记账</h2><h3 id="传统中心化"><a href="#传统中心化" class="headerlink" title="传统中心化"></a>传统中心化</h3><p>假设有一个村落有百户居民，其中有一个德高望重的村长。村民们都把钱存到村长家，村长负责记账。如张三用 1000 买了李四家的牛，那么村长就把张三名下的存款减去 1000，李四家加上 1000。类似于银行存取款的操作，这种就是<strong>传统中心化</strong>的操作方式。</p>
<h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>去中心化的比特币交易流程如下。</p>
<ul>
<li>首先需要交易用户把交易传到网络上。</li>
<li>然后网络上有些机器叫做记账结点，它们通过比拼计算力的方式竞争记账权。也叫”挖矿“。</li>
<li>获得记账权的结点后，会把待记账的交易进行计算打包，并向全网广播。收到新的记账包的结点会对其进行验证，验证通过后加入自己的区块。</li>
</ul>
<p>德高望重的村长因为操劳过度归西去了。儿子狗蛋上任了，但是他粗心大意经常算错账，幸好村民们都有自己的小本本记着账。突然有一天狗蛋老婆偷偷给她七大姑八大姨加了好多钱，事情暴露后村民十分不满向狗蛋讨说法，现场一片混乱。<br>这个时候村民 <em>中本聪</em> 站出来了，他说我设计了一套系统，不依赖任何人记账。</p>
<h4 id="公开记账"><a href="#公开记账" class="headerlink" title="公开记账"></a>公开记账</h4><p>中本聪说我的系统稍微有一点麻烦。需要干以下几件事。</p>
<ol>
<li>每家每户发一个信鸽。就是 P2P 点对点的分布式网络。</li>
<li>每家每户发一个印章和一个扫描器。扫描器可以识别他人的交易是否真实有效。印章用于标识自己的身份代号。</li>
<li>每家每户都参与记账，不过不再记余额，而是记交易本身的内容。及记每一笔交易的付款人、收款人和付款金额。(Transaction)</li>
</ol>
<p>因为记录的每一笔交易都是有序产生的，所以为了保证大家的账本是一致的，增加一个广播机制。</p>
<h4 id="创建创世区块"><a href="#创建创世区块" class="headerlink" title="创建创世区块"></a>创建创世区块</h4><p>创世区块是全村生成公开账本的第一笔交易的第一个信封。</p>
<p>于是中本聪说我先生成第一个 Transaction，这个交易的付款人为空，收款人是村长，付款金额是 100W(全村的总资产)。<br>做好第一个信封以后，让村里所有人都复印一份。这个步骤也叫做<strong>同步区块</strong>，也就是全网都拿到这个信封，以及信封里的 Transaction。</p>
<h4 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h4><p>现在有了创世纪区块，假设张三在村长那存款余额为 10W，那么交易单就应该把 100W 分成两部分，一部分是 10W，一收款人是张三；另外 90W 是村长自己，这样就做成了一个 Transaction。</p>
<h4 id="打包-Transaction-挖矿"><a href="#打包-Transaction-挖矿" class="headerlink" title="打包 Transaction (挖矿)"></a>打包 Transaction (挖矿)</h4><p>现在有了 Transaction，但是还需要用信封把 Transaction 装起来，这个信封就是区块链中的”区块“，这个封装过程就是”<strong>打包交易。</strong>“</p>
<p>之所以要封装起来是为了让打包交易的人能在信封上署名，并且装配交易标号(区块 ID)，方便后续村民查询。</p>
<p>谁来打包呢？这个时候中本聪又说，随着咱村人口的增长，未来 100W 肯定不够，暂定 150W，多出来的这 50W，就当奖励那些装信封的人了，当然也不能给多，谁装一次给 2 个币。<br>但是你要想获得这个装信封的权利，得做一道难题，谁先把这个题做出来谁就给这笔 Transaction 装到信封里并且盖上自己的印章。</p>
<p>但是挖矿(做题)需要大规模的计算来找到一个符合系统要求的区块 ID。要找到符合条件的区块 ID 只能通过暴力穷举的方式，所以要付出大量系统计算和电力。</p>
<h4 id="广播交易"><a href="#广播交易" class="headerlink" title="广播交易"></a>广播交易</h4><p>广播是为了让全村都知道你这一刻产生了一个 Transaction，或者是装好了一个信封。</p>
<p>收到通知后，村民可以先验证信封上难题的答案是否正确，接着验里面的每一笔交易，最后还要验信封背面的内容，及上一个信封的摘要是否正确。因为上一个信封大家都已经确认过。所以可以有效的防止伪造作假。这就是区块链。</p>
<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>区块链中包含着一个个的区块，每个区块中记录者一组交易信息，然后每个区块也都会有一个 ID(或地址)，这些区块通过记录前一个区块的 ID 来形成一条链。</p>
<p>每个 ID 都是通过其内容生成的，只要内容有一丁点的变化这个 ID 就会完全不一样。<br>而且这个 ID 的内容中还包含上一个块的 ID，于是只要上一个块的内容变了，其(当前) ID 也要跟着变(不然就不合法了)。那么后一个区块的 ID 也要重新计算变成另一个，这样就会形成一个连锁效应，一个区块被改，后续的都得跟着改，提高了修改(伪造)成本。</p>
<h2 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h2><p>共识机制是区块链的核心组成要素之一。它决定了区块链的业务吞吐量、交易速度、不可篡改性、准入门槛等。</p>
<p>共识机制主要解决了两个问题。</p>
<ol>
<li><strong>谁有权利。</strong></li>
<li><strong>作弊问题。</strong></li>
</ol>
<p>在上文中心化记账中，采用分布式方式记账，所以大家面临的最大的问题就是谁有权利记账，以谁的记账数据为准，其次是如何避免记账者作弊。</p>
<p><strong>以谁的数据为准？</strong> 任何结点都可以修改自己所下载的账本，也就是说任何人都可以伪造账本。那么谁的账本才是对的？<strong>在去中心化的网络下，我们只能认为大多数人的账本数据是对的。因为在没有服务器的去中心化网络下，所谓的真理不过是大多数人认可同意的东西。</strong>所以只要控制了一半以上的结点，让这”大多数人“伪造同一份账本，那么就相当于整个账本被修改过来了。</p>
<p><strong>所谓大多数人？</strong> 在互联网的世界里，我们可以使用程序模拟出无穷多个“人”出来，根本分不清是人还是狗。</p>
<p><strong>如何避免中心化风险？</strong> 比如李四在第一次记账时篡改了部分数据，第二次还是他记账，还继续篡改，这样是很有可能形成假账的。</p>
<p>为了解决这些问题，比特币使用了 Proof Of Work 工作量证明机制，也就是”<strong>挖矿</strong>“</p>
<h3 id="PoW-工作量证明"><a href="#PoW-工作量证明" class="headerlink" title="PoW 工作量证明"></a>PoW 工作量证明</h3><p>在 PoW (Proof Of Work)机制中，计算资源(算力)是决定记账权的唯一因素，与之对应的，便是计算难度。</p>
<p>计算难度是区块链为了控制答案产生的速度。</p>
<p>通过提升计算难度来”极度消耗计算力“这种方式来提高成本，从而有效控制以下几个问题。</p>
<ol>
<li><strong> 修改变得几乎不可能</strong> 如果生成一个区块需要大量的且长时间的计算力，比如世界上最好的电脑集群下 10 分钟才能打包好一个 Transaction。那么当我们去修改数据内容的时候，其过程也是一样的。前面也有说过，篡改一个区块，就要修改后面所有的块。</li>
<li><strong> 能掌握 51%算力的人变得几乎不可能</strong> 除了伪造一个链的成本很高，还要控制大多数人的算力，这意味着需要巨额的资金支出，两个难度加起来，几乎不太可能。</li>
<li><strong> 解决分歧</strong> 一方面，大量的算力计算出答案，也就是区块 ID，已经有效降低了大家有意见冲突的可能。另一方面，就算出现了合法冲突的区块(如分支、分叉)。<strong>也就是多个合法的账本</strong> 而因为挖矿的成本太高，导致同时跟进多个账本是不可能的，所以矿工们只能赌跟其中一个。大多数人选择的那个分支的链越多，另一个也就作废了。</li>
</ol>
<h4 id="解决双花攻击"><a href="#解决双花攻击" class="headerlink" title="解决双花攻击"></a>解决双花攻击</h4><p>双花攻击是指一个币被花费了两次。这在任意的区块链系统中是不被允许的。</p>
<p>所有的记账结点都会遵循一下两个规则。</p>
<ol>
<li>一个币如果已经被花费，就会标为已花费，如果再次接收到这个币的花费请求，那么记账结点就会拒绝打包这次交易。</li>
<li>如果同时接收到了两个信封，这两个信封中装的两笔交易出现了一个币被花费了两次的情况，也就是<strong>分叉</strong> 那么一般会选择挖矿难度比较大的那个信封。</li>
</ol>
<p>规则一避免未确认的交易出现双花，规则二避免已确认的交易出现双花，及上文中说到的解决分歧。</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>大千世界</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工作原理</title>
    <url>/2021/05/15/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在浏览器中输入一个URL按回车之后发生了哪些事情？</p>
<a id="more"></a>
<ul>
<li>查看浏览器中是否有缓存存在。即查看浏览器中是否曾记录过当前的域名和IP</li>
<li>查看操作系统中是否有映射。 /etc/hosts</li>
<li>若没有就会将域名发送给LDNS本地域名服务器(如学校、或小区)</li>
<li>若LDNS无缓存，直接访问root DNS server 获取顶级的域名地址(如.com)</li>
<li>向顶级域名服务器访问获取返回权限域名服务器地址。如(baidu.com)</li>
<li>访问权限域名服务器访问获取到IP地址(如<a href="http://www.baidu.com)-" target="_blank" rel="noopener">www.baidu.com)-</a> 发起TCP三次握手建立连接</li>
<li>发送HTTP请求</li>
<li>服务器相应之后浏览器解析拿到的HTML代码，并请求HTML中的资源(图片、JS等）</li>
</ul>
<h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h2><p>整个过程就是由URL转换为bitmap的过程。</p>
<ol>
<li>从先发出请求到服务器，然后服务器返回 HTML</li>
<li>浏览器对HTML进行文本分析或编译，构建DOM树。</li>
<li>计算CSS属性，对DOM树上对应着哪些CSS规则，哪些规则会发生叠加，或者发生覆盖，将计算后的最终结果挂载到DOM树上，得到一个带样式的DOM树。</li>
<li>然后进行排版。即计算产生的盒子的位置及大小等等，计算出来。</li>
<li>最后渲染成位图(bitmap)，然后经过操作系统或硬件（显卡）驱动的API完成视图的显示。</li>
</ol>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><blockquote>
<p>有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。</p>
</blockquote>
<ul>
<li>每一个状态都是一个机器<ul>
<li>所有的这些机器接收的输入都是一致的，如制定接收为string，就不能接收一个obj</li>
</ul>
</li>
<li>每一个机器都知道下一个状态<ul>
<li>每个机器都有确定的下一个状态(Moore)</li>
<li>每个机器根据输入决定下一个状态。(Mealy)每个状态应该回到哪里，在编写程序时就已经决定好了</li>
</ul>
</li>
</ul>
<p>如自动门，有开和关两种状态，当读取到开门信号时，状态就会切换为open，当接收到close信号时，就会把状态切换成close。</p>
<h4 id="JS中实现一个Mealy状态机"><a href="#JS中实现一个Mealy状态机" class="headerlink" title="JS中实现一个Mealy状态机"></a>JS中实现一个Mealy状态机</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 每一个函数都是一个状态</span><br><span class="line">function state(input) &#123; // 函数的参数就是输入</span><br><span class="line">// 在函数中，可以自由编写处理每个input的逻辑</span><br><span class="line">   return next // 返回下一个状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">while(input) &#123;</span><br><span class="line">  state = state(input) // 使状态机接收输入并完成状态切换。把状态机的返回值作为下一个状态，使得state永远保持当前状态.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不使用状态机查找字符串IO"><a href="#不使用状态机查找字符串IO" class="headerlink" title="不使用状态机查找字符串IO"></a>不使用状态机查找字符串IO</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function match(state) &#123;</span><br><span class="line">      let foundI = false</span><br><span class="line">      for(let item of state) &#123;</span><br><span class="line">        if(item == &apos;I&apos;) &#123;</span><br><span class="line">          foundI = true</span><br><span class="line">        &#125; else if(foundI &amp;&amp; item == &apos;O&apos;) &#123;</span><br><span class="line">          return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          foundI = false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用状态机查找字符串IO"><a href="#使用状态机查找字符串IO" class="headerlink" title="使用状态机查找字符串IO"></a>使用状态机查找字符串IO</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function match(string) &#123;</span><br><span class="line">      let state = start</span><br><span class="line">      for(let item of string) &#123;</span><br><span class="line">        start = start(item)</span><br><span class="line">      &#125;</span><br><span class="line">      return state === end</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function start(str) &#123;</span><br><span class="line">      if(str === &apos;I&apos;) &#123;</span><br><span class="line">        return foundO</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return start</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function foundO(str) &#123;</span><br><span class="line">      if(str === &apos;O&apos;) &#123;</span><br><span class="line">        return end</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return start</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function end() &#123;</span><br><span class="line">      return end</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    match(&apos;BIOMIND&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="TCP-IP协议、HTTP"><a href="#TCP-IP协议、HTTP" class="headerlink" title="TCP/IP协议、HTTP"></a>TCP/IP协议、HTTP</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>灵活可扩展。如header里增加了content-type指定文件的编码类型，除了文本也可以传输图片以及音视频。</li>
<li>可靠传输。 继承了TCP可靠的特性。</li>
<li>应用层协议</li>
</ul>
<p>详见<a href="https://blog.wangguanwei.com/2020/03/29/web%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/#more" target="_blank" rel="noopener">web协议详解</a></p>
<h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// server.js</span><br><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line"></span><br><span class="line">http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  let body = []</span><br><span class="line">  req.on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class="line">    console.log(&apos;err&apos;, err)</span><br><span class="line">  &#125;).on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">    body.push(chunk.toString())</span><br><span class="line">  &#125;).on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">    body =  (Buffer.concat([ Buffer.from(body.toString()) ])).toString()</span><br><span class="line">    console.log(&quot;body&quot;, body)</span><br><span class="line">    res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/html&apos;&#125;)</span><br><span class="line">    res.end(&apos;hello world\n&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).listen(8088)</span><br><span class="line"></span><br><span class="line">console.log(&apos;server started&apos;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// client.js</span><br><span class="line">const net = require(&apos;net&apos;);</span><br><span class="line"></span><br><span class="line">class Request &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    this.method = props.method || &apos;GET&apos;,</span><br><span class="line">    this.host = props.host</span><br><span class="line">    this.port = props.port</span><br><span class="line">    this.path = props.path || &apos;/&apos;</span><br><span class="line">    this.body = props.body ||  &#123;&#125;</span><br><span class="line">    this.headers = props.headers || &#123;&#125;</span><br><span class="line">    if(!this.headers[&apos;Content-Type&apos;]) &#123;</span><br><span class="line">      this.headers[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(this.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;) &#123;</span><br><span class="line">      this.bodyText = JSON.stringify(this.body)</span><br><span class="line"></span><br><span class="line">    &#125;  else if(this.headers[&apos;Content-Type&apos;] === &apos;application/x-www-form-urlencoded&apos;) &#123;</span><br><span class="line">      this.bodyText = Object.keys(this.body).map(key =&gt; `key=$&#123;encodeURIComponent(this.body[key])&#125;`).join(&apos;&amp;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    this.headers[&apos;Content-length&apos;] = this.bodyText.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(connection) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      const parser = new ResponseParser</span><br><span class="line">      if(connection) &#123;</span><br><span class="line">        connection.write(this.toString())</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        connection = net.createConnection(&#123;</span><br><span class="line">          host: this.host,</span><br><span class="line">          port: this.port</span><br><span class="line">        &#125;, () =&gt; &#123;</span><br><span class="line">          connection.write(this.toString())</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      connection.on(&apos;data&apos;, (data) =&gt; &#123;</span><br><span class="line">        console.log(data.toString())</span><br><span class="line">        parser.recceive(data.toString())</span><br><span class="line">        if(parser.isFinished) &#123;</span><br><span class="line">          resolve(parser.response)</span><br><span class="line">          connection.end()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      connection.on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">        connection.end()</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return `$&#123;this.method&#125; $&#123;this.path&#125; HTTP/1.1\r</span><br><span class="line">$&#123;Object.keys(this.headers).map(key =&gt; `$&#123;key&#125;: $&#123;this.headers[key]&#125;`).join(&apos;\r\n&apos;)&#125;\r</span><br><span class="line">\r</span><br><span class="line">$&#123;this.bodyText&#125;`</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ResponseParser &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.WAITING_STATUS_LINE = 0</span><br><span class="line">    this.WAITING_STATUS_LINE_END = 1</span><br><span class="line">    this.WAITING_HEADER_NAME = 2</span><br><span class="line">    this.WAITING_HEADER_SPACE = 3</span><br><span class="line">    this.WAITING_HEADER_VALUE = 4</span><br><span class="line">    this.WAITING_HEADER_LINT_END = 5</span><br><span class="line">    this.WAITING_HEADER_BLOCK_END = 6</span><br><span class="line">    this.WAITING_BODY = 7</span><br><span class="line"></span><br><span class="line">    this.current = this.WAITING_STATUS_LINE</span><br><span class="line">    this.statusLine = &apos;&apos;</span><br><span class="line">    this.headers = &#123;&#125;</span><br><span class="line">    this.headerName = &apos;&apos;</span><br><span class="line">    this.headerVal = &apos;&apos;</span><br><span class="line">    this.bodyParser = null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get isFinished() &#123;</span><br><span class="line">    return this.bodyParser &amp;&amp; this.bodyParser.isFinished</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get response() &#123;</span><br><span class="line">    this.statusLine.match(/HTTP\/1.1 ([0-9]+) ([\s\S]+)/)</span><br><span class="line">    return &#123;</span><br><span class="line">      statusCode: RegExp.$1,</span><br><span class="line">      statusText: RegExp.$2,</span><br><span class="line">      headers: this.headers,</span><br><span class="line">      body: this.bodyParser.content.join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  recceive(str) &#123;</span><br><span class="line">    for(let i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">      this.reveiveChar(str.charAt(i)) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reveiveChar(char) &#123;</span><br><span class="line">    if(this.current === this.WAITING_STATUS_LINE) &#123;</span><br><span class="line">      if(char === &apos;\r&apos;) &#123;</span><br><span class="line">        this.current = this.WAITING_STATUS_LINE_END</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.statusLine += char</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.WAITING_STATUS_LINE_END) &#123;</span><br><span class="line">      if(char === &apos;\n&apos;) &#123;</span><br><span class="line">        this.current = this.WAITING_HEADER_NAME</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.WAITING_HEADER_NAME) &#123;</span><br><span class="line">      if(char === &apos;:&apos;) &#123;</span><br><span class="line">        this.current = this.WAITING_HEADER_SPACE</span><br><span class="line">      &#125; else if(char === &apos;\r&apos;) &#123;</span><br><span class="line">        this.current = this.WAITING_HEADER_BLOCK_END</span><br><span class="line">        if(this.headers[&apos;Transfer-Encoding&apos;] === &apos;chunked&apos;) &#123;</span><br><span class="line">          this.bodyParser = new TrunkedBodyParser()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.headerName += char</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.WAITING_HEADER_SPACE) &#123;</span><br><span class="line">      if(char === &apos; &apos;) &#123;</span><br><span class="line">        this.current = this.WAITING_HEADER_VALUE</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.WAITING_HEADER_VALUE) &#123;</span><br><span class="line">      if(char === &apos;\r&apos;) &#123;</span><br><span class="line">        this.current = this.WAITING_HEADER_LINT_END</span><br><span class="line">        this.headers[this.headerName] = this.headerVal</span><br><span class="line">        this.headerName = &apos;&apos;</span><br><span class="line">        this.headerVal = &apos;&apos;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.headerVal += char</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.WAITING_HEADER_LINT_END) &#123;</span><br><span class="line">      if(char === &apos;\n&apos;) &#123;</span><br><span class="line">        this.current = this.WAITING_HEADER_NAME</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.WAITING_HEADER_BLOCK_END) &#123;</span><br><span class="line">      if(char === &apos;\n&apos;) &#123;</span><br><span class="line">        this.current = this.WAITING_BODY</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.WAITING_BODY) &#123;</span><br><span class="line">      this.bodyParser.receiveChar(char)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TrunkedBodyParser &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.WAITING_LENGTH = 0</span><br><span class="line">    this.WAITING_LENGTH_LINE_END = 1</span><br><span class="line">    this.READING_THUNK = 2</span><br><span class="line">    this.WAITING_NEW_LINE = 3</span><br><span class="line">    this.WAITING_NEW_LINE_END = 4</span><br><span class="line">    this.length = 0</span><br><span class="line">    this.content = []</span><br><span class="line">    this.isFinished = false</span><br><span class="line">    this.current = this.WAITING_LENGTH</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receiveChar(char) &#123;</span><br><span class="line">    if(this.current === this.WAITING_LENGTH) &#123;</span><br><span class="line">      if(char === &apos;\r&apos;) &#123;</span><br><span class="line">        if(this.length === 0) &#123;</span><br><span class="line">          this.isFinished = true</span><br><span class="line">        &#125;</span><br><span class="line">        this.current = this.WAITING_LENGTH_LINE_END</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.length *= 16</span><br><span class="line">        this.length += parseInt(char, 16)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.WAITING_LENGTH_LINE_END) &#123;</span><br><span class="line">      if(char === &apos;\n&apos;) &#123;</span><br><span class="line">        this.current = this.READING_THUNK</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.READING_THUNK) &#123;</span><br><span class="line">      this.content.push(char)</span><br><span class="line">      this.length --;</span><br><span class="line">      if(this.length === 0) &#123;</span><br><span class="line">        this.current = this.WAITING_NEW_LINE</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.WAITING_NEW_LINE) &#123;</span><br><span class="line">      if(char === &apos;\r&apos;) &#123;</span><br><span class="line">        this.current = this.WAITING_NEW_LINE_END</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if(this.current === this.WAITING_NEW_LINE_END) &#123;</span><br><span class="line">      if(char === &apos;\n&apos;) &#123;</span><br><span class="line">        this.current = this.WAITING_LENGTH</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void async function() &#123;</span><br><span class="line">  let request = new Request(&#123;</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    host: &apos;localhost&apos;,</span><br><span class="line">    port: &apos;8088&apos;,</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      [&apos;X-Foo2&apos;]: &apos;customed&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    body: &#123;</span><br><span class="line">      name: &apos;Cinaiet&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  let response = await request.send()</span><br><span class="line"></span><br><span class="line">  console.log(response)</span><br><span class="line"></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h3 id="解析HTML"><a href="#解析HTML" class="headerlink" title="解析HTML"></a>解析HTML</h3><h4 id="HTML-词法分析"><a href="#HTML-词法分析" class="headerlink" title="HTML 词法分析"></a>HTML 词法分析</h4><ul>
<li>开始标签</li>
<li>结束标签</li>
<li>自封闭标签</li>
</ul>
<ol>
<li>判断标签起始位置是否为’&lt;’</li>
<li>判断下一个字符是否为’/‘，如果是则进入结束标签的计算，如果是字符串则+=当前的tagName</li>
<li>进入结束标签后，+=当前的tagName取到当前的tagName</li>
<li>若在tagName中匹配到空格、tab、禁止符、换行符等，则进入attribute标签匹配</li>
<li>若遇到空格或者’/‘等表示当前标签结束，进入endAttribute</li>
</ol>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>HTML的语法是由一个个的状态机去实现的。<br>详见<a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="noopener">HTML tokenizetion</a></p>
<ul>
<li>使用栈建立节点的父子关系构建DOM树</li>
<li>遇到开始标签时压入栈</li>
<li>遇到结束标签时出栈</li>
<li>自封闭节点不做处理或者理解为入栈后立即出栈</li>
<li>任何元素的父元素都是它入栈前的栈顶元素</li>
<li>文本节点与自封闭标签的处理类似</li>
<li>需要合并多个文本节点</li>
</ul>
<p>ele| inline | id | class | tagName|<br>| — | — | — | — | — |<br>| div div #id | 0 | 1 | 0| 2|<br>| div #my #id | 0 | 2 | 0|1 |<br>| div #id| 0 | 1 | 0 | 1 |</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">function specificity(selector) &#123;</span><br><span class="line">let p = [0, 0, 0, 0]</span><br><span class="line">const selectorParts = selector.split(&apos; &apos;)</span><br><span class="line">for(let part of selectorParts) &#123;</span><br><span class="line">if(part.charAt(0) == &apos;#&apos;) &#123;</span><br><span class="line">p[1] += 1</span><br><span class="line">&#125; else if(part.charAt(0) == &apos;.&apos;) &#123;</span><br><span class="line">p[2] +=1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">p[3] += 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function compare(sp1, sp2) &#123;</span><br><span class="line">if(sp1[0] - sp2[0]) &#123;</span><br><span class="line">return sp1[0] - sp2[0]</span><br><span class="line">&#125;</span><br><span class="line">if(sp1[1] - sp2[1])</span><br><span class="line">return sp1[1] - sp2[1]</span><br><span class="line">if(sp1[2] - sp2[2])</span><br><span class="line">return sp1[2] - sp2[2]</span><br><span class="line"></span><br><span class="line">return sp1[3] - sp2[3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>`</code></p>
<h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><ol>
<li>预处理，如px或者数字转为Number类型便于运算、宽高auto或者为空时，设置为null</li>
<li>flex布局的样式给其添加默认值，如align-item、flexWrap等。</li>
</ol>
]]></content>
      <categories>
        <category>平行宇宙</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器中实现可视化的四种方式</title>
    <url>/2021/09/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>简单来说，可视化就是将数据信息组织起来后，以图形的形式展示出来。<br>在 web 上，图形通常是通过浏览器来绘制的。其中负责绘制图形的部分是渲染引擎。渲染引擎绘制图形的方式，大体上有以下<code>4种</code>。</p>
<a id="more"></a>
<h3 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h3><p>使用 html + css 可以实现常规的图标展示。</p>
<h4 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* dataset = &#123; current: [15, 11, 17, 25, 37], total: [25, 26, 40, 45, 68], &#125; */</span><br><span class="line">    .bargraph &#123;</span><br><span class="line">      display: grid;</span><br><span class="line">      width: 150px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      padding: 10px;</span><br><span class="line">      transform: scaleY(3);</span><br><span class="line">      grid-template-columns: repeat(5, 20%);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bargraph div &#123;</span><br><span class="line">      margin: 0 2px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bargraph div:nth-child(1) &#123;</span><br><span class="line">      background: linear-gradient(to bottom, transparent 75%, #37c 0, #37c 85%, #3c7 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bargraph div:nth-child(2) &#123;</span><br><span class="line">      background: linear-gradient(to bottom, transparent 74%, #37c 0, #37c 89%, #3c7 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bargraph div:nth-child(3) &#123;</span><br><span class="line">      background: linear-gradient(to bottom, transparent 60%, #37c 0, #37c 83%, #3c7 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bargraph div:nth-child(4) &#123;</span><br><span class="line">      background: linear-gradient(to bottom, transparent 55%, #37c 0, #37c 75%, #3c7 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bargraph div:nth-child(5) &#123;</span><br><span class="line">      background: linear-gradient(to bottom, transparent 32%, #37c 0, #37c 63%, #3c7 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>效果如下图:<br><img src="https://Cinaiet.github.io/images/html-bar.png" alt="html-bar"></p>
<h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.piegraph &#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">width: 250px;</span><br><span class="line">height: 250px;</span><br><span class="line">border-radius: 50%;</span><br><span class="line">background-image: conic-gradient(#37c 30deg, #3c7 30deg, #3c7 65deg, orange 65deg, orange 110deg, #f73 110deg, #f73 200deg, #ccc 200deg); // 锥形渐变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下图:<br><img src="https://Cinaiet.github.io/images/html-pie.png" alt="html-bar"></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>简化开发，不需要引入额外的库，节省资源，提高网页打开的速度。</li>
<li>html + css 主要还是为了用于网页布局，虽然可以绘制可视化图表，但绘制的方法并不简洁。从 css 中很难看出图形与数据之间的关系，并且换算也需要 developer 自己来做，数据一旦发生变化，就需要重新计算生成。维护成本较高。</li>
<li>其次，开销较大。html+css 是浏览器渲染引擎的一部分，浏览器的渲染引擎在工作时，要先解析 html、css 绘制 dom 树，cssom 树,render 树等等，当用 html 绘图时，一旦图形发生变化，就要引发浏览器的重绘。</li>
</ul>
<h3 id="Canvas-2D"><a href="#Canvas-2D" class="headerlink" title="Canvas 2D"></a>Canvas 2D</h3><p>Canvas2D 是浏览器提供的简便快捷的指令式图形系统，它通过一些简单的指令就能快速绘制出复杂的图形。</p>
<p>MDN 使用教程链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">canvas 教程与指导</a></p>
<h4 id="canvas-元素和-2d-上下文"><a href="#canvas-元素和-2d-上下文" class="headerlink" title="canvas 元素和 2d 上下文"></a>canvas 元素和 2d 上下文</h4><p>canvas 元素本身的 width 和 height，不等同于 canvas 元素 css 样式的宽高属性。</p>
<p>css 宽高决定 canvas 页面呈现的大小，而 canvas 元素宽高决定了 canvas 的坐标系，决定可视区域的坐标范围。为了区分它们，我们称 canvas 元素属性宽高为<strong>画布宽高</strong>，css 样式宽高为<strong>样式宽高</strong></p>
<p>在实际绘制的过程中，如果不设置样式宽高，只设置了画布宽高，那么 canvas 的样式宽高就会等同于画布宽高。<br>如果不设置画布宽高，只设置了样式宽高，那么画布宽高将等同于样式宽高的二倍。</p>
<h4 id="canvas-操作步骤"><a href="#canvas-操作步骤" class="headerlink" title="canvas 操作步骤"></a>canvas 操作步骤</h4><p>此处不会赘述 canvas 的各个 api,只是做于简单说明。</p>
<ol>
<li>获取 Canvas 对象，通过 getContext(‘2d’) 得到 2D 上下文；</li>
<li>设置绘图状态，比如填充颜色 fillStyle，平移变换 translate 等等；</li>
<li>调用 beginPath 指令开始绘制图形；</li>
<li>调用绘图指令，比如 rect，表示绘制矩形；</li>
<li>调用 fill 指令，将绘制内容真正输出到画布上。</li>
</ol>
<h4 id="使用-canvas-绘制层次关系图"><a href="#使用-canvas-绘制层次关系图" class="headerlink" title="使用 canvas 绘制层次关系图"></a>使用 canvas 绘制层次关系图</h4><h5 id="层次结构数据"><a href="#层次结构数据" class="headerlink" title="层次结构数据"></a>层次结构数据</h5><p>用来表示能够体现层次结构的信息，例如城市与省与国家。一般来说，层次结构数据用层次关系图表来呈现。</p>
<h5 id="城市层级示例图"><a href="#城市层级示例图" class="headerlink" title="城市层级示例图"></a>城市层级示例图</h5><p>json 数据格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;中国&quot;,</span><br><span class="line">  &quot;children&quot;:</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;浙江&quot;,</span><br><span class="line">        &quot;children&quot;:</span><br><span class="line">          [</span><br><span class="line">            &#123; &quot;name&quot;: &quot;杭州&quot; &#125;,</span><br><span class="line">            &#123; &quot;name&quot;: &quot;宁波&quot; &#125;,</span><br><span class="line">            &#123; &quot;name&quot;: &quot;温州&quot; &#125;,</span><br><span class="line">            &#123; &quot;name&quot;: &quot;绍兴&quot; &#125;</span><br><span class="line">          ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;河南&quot;,</span><br><span class="line">        &quot;children&quot;:</span><br><span class="line">          [</span><br><span class="line">            &#123; &quot;name&quot;: &quot;濮阳&quot; &#125;,</span><br><span class="line">            &#123; &quot;name&quot;: &quot;洛阳&quot; &#125;,</span><br><span class="line">            &#123; &quot;name&quot;: &quot;南阳&quot; &#125;,</span><br><span class="line">            &#123; &quot;name&quot;: &quot;安阳&quot; &#125;,</span><br><span class="line">            &#123; &quot;name&quot;: &quot;信阳&quot; &#125;,</span><br><span class="line">          ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;广西&quot;,</span><br><span class="line">        &quot;children&quot;:</span><br><span class="line">          [</span><br><span class="line">            &#123; &quot;name&quot;: &quot;桂林&quot; &#125;,</span><br><span class="line">            &#123; &quot;name&quot;: &quot;南宁&quot; &#125;,</span><br><span class="line">          ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们想要实现的层级关系图效果如下：</p>
<p><img src="https://Cinaiet.github.io/images/canvas-hierarchy.png" alt="城市层级关系图"></p>
<p>数据中只有”城市&gt;省份&gt;中国”这样的层级数据，我们需要把数据层级、位置和要绘制的半径、位置一一对应起来。</p>
<p>换句话说，就是需要数学计算。不过，我们可以直接使用 <a href="https://www.d3js.org.cn/document/d3-hierarchy/#installing" target="_blank" rel="noopener">d3-hierarchy</a>这个工具库转换数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const regions = d3.hierarchy(cityData)</span><br><span class="line">  .sum(d =&gt; 1) //</span><br><span class="line">const pack = d3.pack()</span><br><span class="line">  .size([1000, 1000])</span><br><span class="line">  .padding(3);</span><br><span class="line">const root = pack(regions);</span><br></pre></td></tr></table></figure>
<p>使用 d3.hierarchy 进行数据转换。将数据映射到一个 1000 * 1000 的画布上，每个相邻圆之间间隔 3px。拿到数据之后，<strong>只需要遍历数据并且根据数据内容绘制圆弧</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const canvas = document.querySelector(&apos;canvas&apos;);</span><br><span class="line">  const context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">  const TAU = 2 * Math.PI;</span><br><span class="line"></span><br><span class="line">  function draw(ctx, node, &#123;fillStyle = &apos;rgba(0, 0, 0, 0.2)&apos;, textColor = &apos;white&apos;&#125; = &#123;&#125;) &#123;</span><br><span class="line">    const children = node.children;</span><br><span class="line">    const &#123;x, y, r&#125; = node;</span><br><span class="line">    ctx.fillStyle = fillStyle;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(x, y, r, 0, TAU);</span><br><span class="line">    ctx.fill();</span><br><span class="line">    if(children) &#123;</span><br><span class="line">      for(let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">        draw(context, children[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const name = node.data.name;</span><br><span class="line">      ctx.fillStyle = textColor;</span><br><span class="line">      ctx.font = &apos;1.5rem Arial&apos;;</span><br><span class="line">      ctx.textAlign = &apos;center&apos;;</span><br><span class="line">      ctx.fillText(name, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw(context, root);</span><br></pre></td></tr></table></figure>
<p>首先使用 arc 指令(api)在当前节点绘制一个圆，arc 方法的五个参数分别是圆心的 x、y 坐标、半径 r、起始角度和结束角度，前三个参数就是数据中的 x、y 和 r。因为我们要绘制的是整圆，所以后面的两个参数中起始角是 0，结束角是 2π。</p>
<p>绘制成图后，如果当前数据有下一级的数据，则遍历它的下一级数据，递归的调用绘图过程。如果没有下一级，则说明当前数据为城市数据(最小单元数据),通过 fillText 指令直接给出当前城市的名字。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>canvas 能够直接操作绘图上下文，不需要 html,css 解析、渲染、布局等一系列操作。</li>
<li>不容易添加操作事件(如 click 事件)</li>
</ul>
<h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>svg，可缩放矢量图。是一种基于 XML 语法的图像格式，可以用图片(img 元素)的 src 属性加载。</p>
<p>svg MDN 参考文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG" target="_blank" rel="noopener">地址</a></p>
<h4 id="实现柱状图"><a href="#实现柱状图" class="headerlink" title="实现柱状图"></a>实现柱状图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- dataset = &#123; total: [25, 26, 40, 45, 68], current: [15, 11, 17, 25, 37], &#125; --&gt;</span><br><span class="line">  &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;120px&quot; height=&quot;240px&quot; viewBox=&quot;0 0 60 100&quot;&gt;</span><br><span class="line">    &lt;g transform=&quot;translate(0, 100) scale(1, -1)&quot;&gt;</span><br><span class="line">      &lt;g&gt;</span><br><span class="line">        &lt;rect x=&quot;1&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;25&quot; fill=&quot;#37c&quot; /&gt;</span><br><span class="line">        &lt;rect x=&quot;13&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;26&quot; fill=&quot;#37c&quot; /&gt;</span><br><span class="line">        &lt;rect x=&quot;25&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;40&quot; fill=&quot;#37c&quot; /&gt;</span><br><span class="line">        &lt;rect x=&quot;37&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;45&quot; fill=&quot;#37c&quot; /&gt;</span><br><span class="line">        &lt;rect x=&quot;49&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;68&quot; fill=&quot;#37c&quot; /&gt;</span><br><span class="line">      &lt;/g&gt;</span><br><span class="line">      &lt;g&gt;</span><br><span class="line">        &lt;rect x=&quot;1&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;15&quot; fill=&quot;#3c7&quot; /&gt;</span><br><span class="line">        &lt;rect x=&quot;13&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;11&quot; fill=&quot;#3c7&quot; /&gt;</span><br><span class="line">        &lt;rect x=&quot;25&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;17&quot; fill=&quot;#3c7&quot; /&gt;</span><br><span class="line">        &lt;rect x=&quot;37&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;25&quot; fill=&quot;#3c7&quot; /&gt;</span><br><span class="line">        &lt;rect x=&quot;49&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;37&quot; fill=&quot;#3c7&quot; /&gt;</span><br><span class="line">      &lt;/g&gt;</span><br><span class="line">    &lt;/g&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">&lt;!-- total 和current中的每一项分别对应svg g中的height--&gt;</span><br></pre></td></tr></table></figure>
<h4 id="绘制层次关系图"><a href="#绘制层次关系图" class="headerlink" title="绘制层次关系图"></a>绘制层次关系图</h4><p>以 canvas 绘制的城市分级为例。数据同样需要经过<code>d3.hierarchy</code>进行转换。</p>
<p>转换完成之后获取当前的 svg 节点。同样实现 draw 方法从 root 开始遍历数据。不同于 canvas 的调用绘图指令(api)来绘图，svg 是通过创建 svg 元素，将元素添加到 DOM 中，来使得图像显现出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const svgroot = document.querySelector(&apos;svg&apos;);</span><br><span class="line"></span><br><span class="line">  function draw(parent, node, &#123;fillStyle = &apos;rgba(0, 0, 0, 0.2)&apos;, textColor = &apos;white&apos;&#125; = &#123;&#125;) &#123;</span><br><span class="line">    const children = node.children;</span><br><span class="line">    const &#123;x, y, r&#125; = node;</span><br><span class="line">    const circle = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;circle&apos;);</span><br><span class="line">    circle.setAttribute(&apos;cx&apos;, x);</span><br><span class="line">    circle.setAttribute(&apos;cy&apos;, y);</span><br><span class="line">    circle.setAttribute(&apos;r&apos;, r);</span><br><span class="line">    circle.setAttribute(&apos;fill&apos;, fillStyle);</span><br><span class="line">    circle.setAttribute(&apos;data-name&apos;, node.data.name);</span><br><span class="line">    parent.appendChild(circle);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw(svgroot, root);</span><br></pre></td></tr></table></figure>
<p>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createElementNS" target="_blank" rel="noopener">Document.createElementNS</a>来创建一个具有指定命名空间(arg1)和限定名称（arg2)的元素。</p>
<p>因为要绘制圆形，所以创建一个 circle 元素，指定 x,y,r 分别为圆的 cx(中心点 x),cy(中心点 y),cr(半径);fillStyle 赋值给 fill 属性。然后将 circle 元素添加到他的 parent 里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(children) &#123;</span><br><span class="line">      const group = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;g&apos;);</span><br><span class="line">      for(let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">        draw(group, children[i], &#123;fillStyle, textColor&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      group.setAttribute(&apos;data-name&apos;, node.data.name);</span><br><span class="line">      parent.appendChild(group);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>svg 的 g 代表一个分组，可以考虑用它(g)来建立一个层级结构，且 g 元素的属性，其子元素也可继承。</p>
<p>如果有子节点，则接着遍历下一层数据，直到数据最小单元(没有下一级的数据了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">      const text = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;text&apos;);</span><br><span class="line">      text.setAttribute(&apos;fill&apos;, textColor);</span><br><span class="line">      text.setAttribute(&apos;font-family&apos;, &apos;Arial&apos;);</span><br><span class="line">      text.setAttribute(&apos;font-size&apos;, &apos;1.5rem&apos;);</span><br><span class="line">      text.setAttribute(&apos;text-anchor&apos;, &apos;middle&apos;);</span><br><span class="line">      text.setAttribute(&apos;x&apos;, x);</span><br><span class="line">      text.setAttribute(&apos;y&apos;, y);</span><br><span class="line">      const name = node.data.name;</span><br><span class="line">      text.textContent = name;</span><br><span class="line">      parent.appendChild(text);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当没有下一级数据时，就需要为其添加 text 文字元素了，然后设置元素的属性，添加到父节点。</p>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>相较于 html + css ，弥补了 html 绘制不规则图形的能力，使用 svg 实现不规则形状图形要简单的多。</li>
<li>适用于元素较少的简单场景。同样需要经过浏览器渲染引擎的一系列操作。如果数据很复杂，同样会开销很多的内存空间。</li>
</ul>
<h4 id="svg-与-canvas"><a href="#svg-与-canvas" class="headerlink" title="svg 与 canvas"></a>svg 与 canvas</h4><ul>
<li>写法不同<br>svg 是以创建图形元素绘图的”声明式”的绘图系统，Canvas 是执行绘图指令绘图的“指令式”绘图系统。</li>
<li>交互实现不同<br>svg 的交互方式与 dom 操作大体相同。如(addEventListner)而 canvas，则需要用到复杂的数学计算。</li>
<li>svg 绘制大量几何图形会极大的增大浏览器的重绘和重排。<br>-</li>
</ul>
<h3 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h3><p>webGL 比上述三种方式要复杂一些，因为 WebGL 是基于 OpenGL ES 规范的浏览器实现的，API 相对更底层，使用起来不如前三种那么简单直接。要使用 webGL 绘图，我们必须要深入细节里。换句话说就是，我们必须要和内存、GPU 打交道，真正控制图形输出的每一个细节。</p>
<h4 id="图形是如何绘制的"><a href="#图形是如何绘制的" class="headerlink" title="图形是如何绘制的"></a>图形是如何绘制的</h4><p>首先说一下计算机图形系统的主要组成部分，以及他们在绘图过程中的作用。</p>
<ul>
<li><strong>光栅</strong> 指构成图像的像素阵列。</li>
<li><strong>像素</strong> 一个像素对应图像上的一个点，通常保存图像上的某个具体位置的颜色等信息。</li>
<li><strong>帧缓存</strong> 是一块内存地址。在绘图过程中，像素信息被存放于帧缓存中。</li>
<li><strong>CPU</strong> 中央处理单元，负责逻辑计算。</li>
<li><strong>GPU</strong> 图形处理单元，负责图形计算。</li>
</ul>
<p>数据经过 CPU 处理，成为具有特定结构的几何信息。然后，这些信息会被送到 GPU 中进行处理，在 GPU 中经过两个步骤生成光栅信息，这些光栅信息会输出到帧缓存中，最后渲染到屏幕上。</p>
<h5 id="一-创建-webGL-上下文"><a href="#一-创建-webGL-上下文" class="headerlink" title="一 创建 webGL 上下文"></a>一 创建 webGL 上下文</h5><p>创建 webGL 上下文这一步和 Canvas2D 基本一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const canvas = document.querySelector(&apos;canvas&apos;);</span><br><span class="line">const gl = canvas.getContext(&apos;2d&apos;);</span><br></pre></td></tr></table></figure>
<h5 id="二-创建-WebGL-程序"><a href="#二-创建-WebGL-程序" class="headerlink" title="二 创建 WebGL 程序"></a>二 创建 WebGL 程序</h5><p>要创建 WebGL 程序，需要先编写两个<strong>着色器</strong>。 在绘图的时候，WebGL 是以<strong>顶点</strong>和<strong>图元</strong>来描述图形几何信息的。<strong>顶点</strong>就是几何图形的顶点。<strong>图元</strong>是 WebGL 可直接处理的图形单元，由 WebGL 的绘图模式决定。<strong>顶点着色器</strong>负责处理图形的顶点信息；<strong>片元着色器</strong>负责处理图形的像素信息。我们可以把<strong>顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息</strong>(如顶点的坐标、法线方向、材质等等)。顶点处理完成后，WebGL 就会根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对他们执行片元着色器程序(对指定图元中的像素点着色)。</p>
<p>WebGL 从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是生成光栅信息的过程，也叫做光栅化过程。所以<strong>片元着色器的作用就是处理光栅化后的像素信息</strong>。</p>
]]></content>
      <categories>
        <category>大千世界</category>
      </categories>
      <tags>
        <tag>大千世界</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法之美</title>
    <url>/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<p>痛并快乐着。</p>
<a id="more"></a>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="大-O-复杂度表示法-时间复杂度"><a href="#大-O-复杂度表示法-时间复杂度" class="headerlink" title="大 O 复杂度表示法(时间复杂度)"></a>大 O 复杂度表示法(时间复杂度)</h3><p>T(n) = O(f(n))<br>T(n)表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 例1</span><br><span class="line">function cal1 (n) &#123;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    let i = 1;</span><br><span class="line">    for(; i &lt; n; ++i) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 例2</span><br><span class="line">function cal2 (n) &#123;</span><br><span class="line">    let sum = 0;</span><br><span class="line">    let i = 1;</span><br><span class="line">    let j = 1;</span><br><span class="line">    for(; i &lt; n; ++i) &#123;</span><br><span class="line">        j = 1;</span><br><span class="line">        for(; i &lt;= n; j++) &#123;</span><br><span class="line">            sum = sum + i * j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设每行代码的运行时间为 x,例 1 中的第二三行代码，分别需要 x 个时间,第 4、5 行代码,各执行了 n 次,执行时间分别需要 n <em> x。所以例 1 中代码执行时间需要(2n+2) </em>x 。可以看出，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数成正比。</strong></p>
<p>所以例 2 中代码所需要的执行时间 T(n) = 2n² + 2n + 3.<br>即: <strong>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong></p>
<p><strong>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势</strong></p>
<hr>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><ul>
<li>只关注循环执行次数最多的一段代码。<br>如例 1 中的代码，2、3 行代码的执行时间都是常量级,与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。</li>
<li>加法法则: 总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
<li>O(m+n)、O(m*n)<br>如一个函数中有两个数据规模的量，在事先又无法评估谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。乘法一样。</li>
</ul>
<h4 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h4><p>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。<br>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。</p>
<h4 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h4><p>比如要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0 ～ n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值<br>(1 + 2 + 3 + … + n + n) / (n+1)</p>
<h4 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h4><p>在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度<br>均摊复杂度在以下两个条件满足时使用</p>
<ol>
<li>代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；</li>
<li>低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</li>
</ol>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>表示算法的存储空间与数据规模之间的增长关系。</p>
<hr>
<h2 id="数据结构类型"><a href="#数据结构类型" class="headerlink" title="数据结构类型"></a>数据结构类型</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。<br>数组，链表、队列、栈等都是线性表结构。</p>
<hr>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组,用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
<ul>
<li>连续的内存空间和相同类型的数据</li>
<li>支持随机访问</li>
<li>低效的“插入”和“删除”<br>如果某个数组中，需要在 arr[x]的位置插入一个新的 val，就需要将原来的 x 向后挪出一位，最坏的时间复杂度的情况为 O(n)</li>
</ul>
<hr>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>与数组相反，它并不需要一块一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。其中，我们把内存块称为链表的”结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。</p>
<h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&gt; data --&gt; data -- &gt; data --&gt; null</span><br></pre></td></tr></table></figure>
<p>单链表有两个结点比较特殊,头结点(第一个结点)和尾结点(最后一个结点指向 null)</p>
<ul>
<li>插入删除非常便捷</li>
<li>但随即访问没有数组高效，无法像数组一样通过下标获取，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</li>
</ul>
<h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><p>是一种特殊的单链表。<br>单链表的尾结点指向 null(空地址),而循环链表的尾结点指针是指向链表的头结点.</p>
<h5 id="双向链表。"><a href="#双向链表。" class="headerlink" title="双向链表。"></a>双向链表。</h5><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<ul>
<li>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</li>
</ul>
<h4 id="链表与数组的对比"><a href="#链表与数组的对比" class="headerlink" title="链表与数组的对比"></a>链表与数组的对比</h4><ul>
<li>数组大小固定，一经声明就要占用整块连续内存空间。链表本身没有大小的限制，天然地支持动态扩容。</li>
</ul>
<h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p>
<p><strong>插入结点时一定要注意: 如果希望在 a 结点和 b 结点插入 c 结点，要先将 c 的 next 结点指向 b，再将 a 的 next 结点指向 c,这样才不会丢失指针，导致内存泄漏。同理，删除链表结点时，也一定要记得手动释放内存空间。</strong></p>
<h5 id="如何优雅的写出链表代码"><a href="#如何优雅的写出链表代码" class="headerlink" title="如何优雅的写出链表代码"></a>如何优雅的写出链表代码</h5><ol>
<li>理解指针或引用的含义</li>
<li>警惕指针丢失和内存泄漏（单链表）</li>
<li>利用“哨兵”简化实现难度<br>链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head 指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。</li>
<li>重点留意边界条件处理</li>
<li>举例画图，辅助思考</li>
</ol>
<hr>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>先进后出，后进先出。</p>
<ul>
<li>只允许在端插入和删除数据</li>
<li>存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。</li>
<li>可以由数组实现</li>
</ul>
<hr>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>先进先出</p>
<ul>
<li>最基本的操作有两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。</li>
<li>可以由数组实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。</li>
</ul>
<hr>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>指在运行的过程中调用自己。</p>
<h3 id="构成递归需要满足的条件"><a href="#构成递归需要满足的条件" class="headerlink" title="构成递归需要满足的条件"></a>构成递归需要满足的条件</h3><ol>
<li>一个问题的解可以分解为几个子问题的解。</li>
<li>子问题须与原始问题为同样的事,且更为简单。</li>
<li>存在递归终止条件。</li>
</ol>
<h3 id="如何编写递归"><a href="#如何编写递归" class="headerlink" title="如何编写递归"></a>如何编写递归</h3><p>写出递推公式，找到终止条件。</p>
<p>如斐波那契数列。 1, 1, 2, 3, 5, 8, 13, 21, …</p>
<p>如何求 斐波那契数列第 n 项的值？</p>
<ol>
<li>找出递推公式。 按数列不难发现，从第三项起，第三项的值，等于前两项值的和。<br>及 f(n) = f(n - 1) + f(n - 2)</li>
<li>终止条件<br>当只有一个数时，值为 1，所以 f(1) = 1。<br>校验递归终止条件是否足够时，可以将 n = 2,n = 3 带入地推公式里面实验一下。</li>
</ol>
<p>当 n = 2 时，f(2) = f(1) + f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。<br>所以除了 f(1) = 1 之外，还要有 f(0) = 1,用来表示 0 个数时的值，不过显然长度为 0 的数列是不符合正常逻辑的，所以，我们可以把 f(2) = 2，当做一个 终止条件。<br>当 n = 3 时 …</p>
<p>把得到的递推公式和终止条件结合在一起:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(1) = 1</span><br><span class="line">f(2) = 2</span><br><span class="line">f(n) = f(n -1) + f(n - 2)</span><br></pre></td></tr></table></figure>
<p>有了公式，将其转换成代码就容易多啦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 时间复杂度 2^n  2的n次方</span><br><span class="line">function fib(n) &#123;</span><br><span class="line">  if(n === 1) return 1</span><br><span class="line">  if(n === 2) return 1</span><br><span class="line">  return fib(n - 1) + fib(n - 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="避免-OOM-内存溢出"><a href="#避免-OOM-内存溢出" class="headerlink" title="避免 OOM(内存溢出)"></a>避免 OOM(内存溢出)</h3><ol>
<li>以通过在代码中限制递归调用的最大深度的方式来解决这个问题。及递归调用次数超过一定的深度(如 1000 以后)，我们就报错不再执行。</li>
</ol>
<h3 id="警惕重复计算"><a href="#警惕重复计算" class="headerlink" title="警惕重复计算"></a>警惕重复计算</h3><p>如果将上述代码的递归过程分解一下的话，不难发现有重复计算的问题。<br>如当 n 为 5 时，f(5) = f(4) + f(3), 当 n 为 4 时， f(4) = f(3) + f(2),这里的 f(3)就重复计算了。<br>还是斐波那契数列求 n 项的值，为了避免重复计算，可以考虑将前两位数作为参数避免重复计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fib(n) &#123;</span><br><span class="line">  function fun (n, fir, next) &#123;</span><br><span class="line">    if(n === 1) return fir</span><br><span class="line">    if(n === 2) return next</span><br><span class="line"></span><br><span class="line">    return fun(n-1, next, next + fir)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return fun(n, 1, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h4><p>冒泡排序只会操作两个相邻的数据。每次冒泡排序都会对两个相邻的元素进行比较，看是否满足大小关系，如果不满足就让他俩互换，一次冒泡会至少让一个元素移动到他应该在的位置，重复 n 次就完成了 n 个数据的排序工作。</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好时间复杂度 O(n)<br>最坏时间复杂度 O(n²)<br>平均时间复杂度 O(n²)</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bubbling(arr) &#123;</span><br><span class="line">  let len = arr.length; // 3</span><br><span class="line"></span><br><span class="line">  if(len &lt;=1 ) return</span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    let bool = false // 用于控制结束循环</span><br><span class="line"></span><br><span class="line">    for(let j = 0; j &lt; len - i - 1; j++) &#123;</span><br><span class="line">      if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">        let temp = arr[j] // 6</span><br><span class="line">        let next = arr[j + 1]  // 3</span><br><span class="line">        arr[j + 1] = temp // arr[1] = 6</span><br><span class="line">        arr[j] = next // arr[0] = 3</span><br><span class="line"></span><br><span class="line">        bool = true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(!bool) break</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="核心原理-1"><a href="#核心原理-1" class="headerlink" title="核心原理"></a>核心原理</h4><p>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，通常是数据的第一个元素。插入算法的核心思想就是取未排序区间中的数据，在已排序区间找到合适的位置将其插入，并保证已排序区间一直有序。重复这个过程，直到未排序区间数据为空，结束排序。</p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好时间复杂度 O(n)<br>最坏时间复杂度 O(n²)<br>平均时间复杂度 O(n²)</p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function insertSort(arr) &#123;</span><br><span class="line">  let len = arr.length</span><br><span class="line"></span><br><span class="line">  if(len &lt;= 1) return arr</span><br><span class="line"></span><br><span class="line">  for(let i = 1; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">    let j = i - 1</span><br><span class="line">    let val = arr[i] // 3</span><br><span class="line"></span><br><span class="line">    for(; j &gt;= 0; j--) &#123;</span><br><span class="line">      if(arr[j] &gt; val) &#123;</span><br><span class="line">        arr[j + 1] = arr[j] // 数据移动</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + 1] = val // 插入数据</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return arr</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="核心原理-2"><a href="#核心原理-2" class="headerlink" title="核心原理"></a>核心原理</h4><p>选择排序的思路与插入排序的方法有些类似，也分为已排序区和未排序区。但是选择排序每次会在未排序区选择一个 最小值插入到已排序区末尾。</p>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好时间复杂度 O(n)<br>最坏时间复杂度 O(n²)<br>平均时间复杂度 O(n²)</p>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function selectSort(arr) &#123;</span><br><span class="line">  let  len = arr.length</span><br><span class="line">  if(len &lt;= 1) return arr</span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">    let minIndex = i;</span><br><span class="line">    let minVal</span><br><span class="line"></span><br><span class="line">    for(let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">      let currMinVal  =  arr[minIndex]</span><br><span class="line">      let currEachVal = arr[j]</span><br><span class="line">      if(currEachVal &lt; currMinVal) &#123;</span><br><span class="line">        minIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minVal = arr[minIndex]</span><br><span class="line">    arr[minIndex] = arr[i]</span><br><span class="line">    arr[i] = minVal</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return arr</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="排序原理"><a href="#排序原理" class="headerlink" title="排序原理"></a>排序原理</h4><ol>
<li>尽可能的将一组元素拆分成两个元素相等的子组(若无法相等向下取整保留前多后少)，并对每一个子组继续拆分，直到拆分后的每个子组中的元素个数为 1 为止。</li>
<li>将相邻的两个子组归并成一个有序的大组。</li>
<li>重复上述步骤直到归并成一个数组为止。</li>
</ol>
<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好时间复杂度 O(nlogn)<br>最坏时间复杂度 O(nlogn)<br>平均时间复杂度 O(nlogn)</p>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function mergeSort(arr) &#123;</span><br><span class="line">  let len = arr.length</span><br><span class="line">  if(len &lt;= 1)  return arr</span><br><span class="line"></span><br><span class="line">  let midIndex = Math.floor(len / 2) // 向下取整。如数据有5条，分割成 2, 3</span><br><span class="line"></span><br><span class="line">  let leftArr = arr.slice(0, midIndex)</span><br><span class="line">  let rightArr = arr.slice(midIndex)</span><br><span class="line"></span><br><span class="line">  return merge(mergeSort(leftArr),mergeSort(rightArr))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function merge(left, right) &#123;</span><br><span class="line">  let arr = []</span><br><span class="line">  let leftIndex = 0</span><br><span class="line">  let rightIndex = 0</span><br><span class="line">  let leftLen = left.length</span><br><span class="line">  let rightLen = right.length</span><br><span class="line"></span><br><span class="line">  while(leftIndex &lt; leftLen &amp;&amp; rightIndex &lt; rightLen) &#123;</span><br><span class="line">    let leftTempVal = left[leftIndex]</span><br><span class="line">    let rightTempVal = right[rightIndex]</span><br><span class="line"></span><br><span class="line">    if(leftTempVal &lt;= rightTempVal) &#123;</span><br><span class="line">      arr.push(leftTempVal)</span><br><span class="line">      leftIndex++</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      arr.push(rightTempVal)</span><br><span class="line">      rightIndex++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while(leftIndex &lt; leftLen) &#123;</span><br><span class="line">    arr.push(left[leftIndex])</span><br><span class="line">    leftIndex++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while(rightIndex &lt; rightLen) &#123;</span><br><span class="line">    arr.push(right[rightIndex])</span><br><span class="line">    rightIndex++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return arr</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ol>
<li>在数集中选择一个元素作为基准。</li>
<li>所有小于基准的元素，都移到基准的左边，大于基准的元素，都挪到右边。</li>
<li>对基准左右两边的数集，重复 1,2 的步骤，直到所有的子集都只剩一个元素为止</li>
</ol>
<h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好时间复杂度 O(nlogn)<br>最坏时间复杂度 O(nlogn)<br>平均时间复杂度 O(nlogn)</p>
<h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">  let len = arr.length</span><br><span class="line">  if(len &lt;= 1) &#123;return arr&#125;</span><br><span class="line"></span><br><span class="line">  let baseIndex = Math.floor(len / 2)</span><br><span class="line">  let baseVal = arr.splice(baseIndex, 1)[0]</span><br><span class="line"></span><br><span class="line">  let leftArr = []</span><br><span class="line">  let rightArr = []</span><br><span class="line"></span><br><span class="line">  for(let i  = 0; i &lt; len; i++) &#123;</span><br><span class="line">    if(arr[i] &lt; baseVal) &#123;</span><br><span class="line">      leftArr.push(arr[i])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      rightArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return quickSort(leftArr).concat([baseVal], quickSort(rightArr))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h4 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h4><p>将要排序的数据，分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序后，再把桶里每个数据按照顺序依次取出，组成的序列就是有序的了。</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h4 id="核心思想-1"><a href="#核心思想-1" class="headerlink" title="核心思想"></a>核心思想</h4><p>当要排序的 n 个数据，所处的范围 并不大的时候，如最大值为 k,则把数据划分成 k 个桶，这样桶里的数据都是相同的，相较于桶排序，省去了桶内排序的时间。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>####核心思想<br>需要分割出独立的“位”来比较，而且位之间有递进 关系，如果 a 数据的高位比 b 数据的大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="核心思想-2"><a href="#核心思想-2" class="headerlink" title="核心思想"></a>核心思想</h3><p>每次都取数据中的中间数来比较大小，从而不断地缩小查找范围，直至找到数据为止。</p>
<h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(logn)</p>
<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><ol>
<li>需要数据为数组类型；</li>
<li>需要数据为有序数据；</li>
<li>数据量太小、太大，均不适合使用二分查找。</li>
</ol>
<h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 非递归</span><br><span class="line">function basearch(arr, target) &#123;</span><br><span class="line">  let low = 0</span><br><span class="line">  let high = arr.lenth - 1</span><br><span class="line"></span><br><span class="line">  while(low &lt;= high) &#123;</span><br><span class="line">    let mid  = Math.floor((low + high) / 2)</span><br><span class="line"></span><br><span class="line">    if(arr[mid] === target) &#123;</span><br><span class="line">      return mid</span><br><span class="line">    &#125; else if(arr[mid] &lt; target) &#123;</span><br><span class="line">      low = mid + 1</span><br><span class="line">    &#125;  else &#123;</span><br><span class="line">      high = mid - 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归</span><br><span class="line">function basearch(arr, target) &#123;</span><br><span class="line">  return recursive(arr, 0, arr.length - 1, target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function recursive(arr, low, high, target) &#123;</span><br><span class="line">  if(low &gt; high) return false</span><br><span class="line"></span><br><span class="line">  let mid = Math.floor((low + high) /2)</span><br><span class="line"></span><br><span class="line">  if(arr[mid] ===  target)   &#123;</span><br><span class="line">    return mid</span><br><span class="line">  &#125; else if(arr[mid] &lt; target) &#123;</span><br><span class="line">    return recursive(arr, mid + 1, high, target)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return recursive(arr, low, mid - 1, target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="散列表-Hash-Table"><a href="#散列表-Hash-Table" class="headerlink" title="散列表 Hash Table"></a>散列表 Hash Table</h2><p>散列表用的是数组下标支持随机访问的特性，所以散列表其实是数组的一种扩展，由数组演化而来。</p>
<p>假如有 50 名学生参加学校运动会，为了方便记录成绩，会在胸前贴上编号，通过编号可以快速的查找到某个学生的成绩。</p>
<p>参赛学生的编号我们 叫做 key,把参赛编号转化为数组下标的映射方法就叫作散列函数,而散列函数计算得到的值就叫作散列值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 找出两个数组中重复的项</span><br><span class="line"></span><br><span class="line">let firstArr = [1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">let nextArr = [2, 4, 6, 8, 10, 9, 12]</span><br><span class="line">function unque(firstArr, nextArr) &#123;</span><br><span class="line">  let map = &#123;&#125;, retArr = []</span><br><span class="line">  firstArr.forEach(item =&gt; &#123;</span><br><span class="line">    map[item] = true</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  nextArr.forEach(item =&gt; &#123;</span><br><span class="line">    if(map[item]) &#123;</span><br><span class="line">      retArr.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return retArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h3><p><img src="https://Cinaiet.github.io/images/tree-struth.png" alt="树结构"></p>
<ul>
<li>节点：树上的每一个元素我们称之为节点；</li>
<li>父子关系： 用来连接相邻节点之间的关系称之为父子关系；</li>
<li>高度：节点到叶节点的<strong>最长路径(边数)</strong> 由下往上的度量。图中二图的高度为 3(从零开始)</li>
<li>深度：根节点到这个节点所经历的<strong>边的个数</strong> 由上往下度量，从 0 开始。</li>
<li>层数：节点的深度 + 1。及层数的计算是由 1 开始。</li>
<li>树的高度 = 根节点的高度</li>
</ul>
<h3 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树 Binary Tree"></a>二叉树 Binary Tree</h3><p>每个节点最多有两个叉，也就是最多两个子节点，分别为<strong>左节点</strong>和<strong>右节点</strong>。不过二叉树也并不要求每个节点都有左右节点，有的只有左节点，有的只有右节点。</p>
<p><img src="https://Cinaiet.github.io/images/tree-binary.png" alt="二叉树"></p>
<ul>
<li>满二叉树： 除了根节点外，每个节点都有左右两个子节点。</li>
<li>完全二叉树： 最后一层的叶子节点都靠左排列，并且除了最后一层，其它层的节点数都打到了最大。</li>
</ul>
<h4 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h4><h5 id="链式存储法"><a href="#链式存储法" class="headerlink" title="链式存储法"></a>链式存储法</h5><h5 id="指针-1"><a href="#指针-1" class="headerlink" title="指针"></a>指针</h5><h4 id="时间复杂度-O-n"><a href="#时间复杂度-O-n" class="headerlink" title="时间复杂度 O(n)"></a>时间复杂度 O(n)</h4>]]></content>
      <categories>
        <category>大千世界</category>
      </categories>
      <tags>
        <tag>大千世界</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>web协议详解</title>
    <url>/2020/03/29/web%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>web协议及抓包</p>
<a id="more"></a>
<h2 id="评估web架构的关键属性"><a href="#评估web架构的关键属性" class="headerlink" title="评估web架构的关键属性"></a>评估web架构的关键属性</h2><h3 id="HTTP协议应当在以下属性中取得可接受的均衡"><a href="#HTTP协议应当在以下属性中取得可接受的均衡" class="headerlink" title="HTTP协议应当在以下属性中取得可接受的均衡:"></a>HTTP协议应当在以下属性中取得可接受的均衡:</h3><ul>
<li>性能 performance : 影响高可用的关键因素</li>
<li>可伸缩性 scalability : 支持部署可以交互的大量组件</li>
<li>简单性 simpilcity : 易理解、易实现、易验证</li>
<li>可见性 visiavle : 对两个组件间的交互进行监视或仲裁的能力。如缓存，分层设计等。</li>
<li>可移植性 portability : 在不同的环境下运行的能力</li>
<li>可靠性 reliablity : 出现部分故障时，对整体的影响程度</li>
<li>可修改性 modifiability : 对系统做出修改的难易程度，有可定制化性、可扩展性、可进化性、可配置性、可重用性构成<ul>
<li>可进化性: 一个组件独立升级而不影响其它组件</li>
<li>可扩展性: 向系统添加功能而不会影响系统其它部分</li>
<li>可定制型: 临时性、定制性的更改某一要素来提供服务，不对常规客户产生影响</li>
<li>可重用性: 组件可以不做修改在其它应用中使用</li>
<li>可配置性: 应用部署后可通过修改配置提供新的功能</li>
</ul>
</li>
</ul>
<h3 id="架构属性"><a href="#架构属性" class="headerlink" title="架构属性"></a>架构属性</h3><h4 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h4><ul>
<li>吞吐量 : 小于等于服务的带宽</li>
<li>开销: 首次开销、每次开销</li>
</ul>
<h4 id="用户感知到的性能"><a href="#用户感知到的性能" class="headerlink" title="用户感知到的性能"></a>用户感知到的性能</h4><ul>
<li>延迟: 发起请求到相应的时间</li>
<li>完成时间: 完成一个应用动作所花费的时间</li>
</ul>
<h4 id="网络效率"><a href="#网络效率" class="headerlink" title="网络效率"></a>网络效率</h4><ul>
<li>重用缓存、减少交互次数、数据传输距离更近、COD</li>
</ul>
<h3 id="架构风格"><a href="#架构风格" class="headerlink" title="架构风格"></a>架构风格</h3><table>
<thead>
<tr>
<th>风格</th>
<th>简单性</th>
<th>可靠性</th>
<th>可进化性</th>
<th>可扩展性</th>
<th>可配置性</th>
<th>可重用性</th>
<th>可伸缩性</th>
<th>网络效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据流风格</td>
<td>✔️</td>
<td></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>复制风格</td>
<td>用户可察觉的性能</td>
<td>✔️</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✔️</td>
<td>✔️</td>
<td></td>
</tr>
<tr>
<td>分层风格</td>
<td>✔️</td>
<td>✔️</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✔️</td>
<td></td>
<td></td>
</tr>
<tr>
<td>移动代码风格</td>
<td>可移植性</td>
<td></td>
<td></td>
<td>✔️</td>
<td></td>
<td></td>
<td></td>
<td>✔️</td>
<td></td>
</tr>
<tr>
<td>点对点风格</td>
<td></td>
<td></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>风格简单性可靠性可进化性可扩展性可配置性可重用性可伸缩性网络效率数据流风格✔️✔️✔️✔️✔️复制风格用户可察觉的性能✔️✔️✔️分层风格✔️✔️✔️移动代码风格可移植性✔️✔️点对点风格✔️✔️✔️✔️#### 数据流风格 Data-flow-style</p>
<ul>
<li>管道与过滤器(或者称为组件)<br>每个filter都有输入端和输出端,只能从输入端读取数据,处理后再从输出端产生数据</li>
<li>接口统一的管道与过滤器<br>如在每个接口都增加统一的约束,则整个架构的简单性会得到增强</li>
</ul>
<h4 id="复制风格-Replication-Style"><a href="#复制风格-Replication-Style" class="headerlink" title="复制风格 Replication Style"></a>复制风格 Replication Style</h4><ul>
<li>复制仓库<br>多个进程提供相同的服务,如通过反向代理对外提供您集中服务</li>
<li>缓存<br>在客户端或中间的代理中,通过复制请求的结果,为后续的请求复用</li>
</ul>
<h4 id="分层风格-Hierarchical-Styles"><a href="#分层风格-Hierarchical-Styles" class="headerlink" title="分层风格 Hierarchical Styles"></a>分层风格 Hierarchical Styles</h4><ul>
<li>客户端服务器 Client-Server CS<ul>
<li>由Client(客户端)触发请求,Server(服务端)监听到请求后响应,Client一直等待收到响应后,会话结束.</li>
<li>分离关注点隐藏细节,Server只关注资源的生成和管理,Client关注资源的可视化渲染,具有良好的可伸缩性、可进化性、简单性。</li>
</ul>
</li>
<li>分层系统 Layered System LS<ul>
<li>每一层为其之上的层服务,并使用在其下的层所提供的服务,如TCP,IP</li>
</ul>
</li>
<li>分层客户端服务器 Layered-Client-Server LCS<ul>
<li>如正向代理和反向代理,从空间上分为外部层和内部曾,正向代理把客户端和网络环境进行分离,反向代理将企业内网与外网进行分层。</li>
</ul>
</li>
<li>无状态、客户端服务器 Client-stateless-Server CSS<ul>
<li>基于CS,服务器上不允许有session,state等会话状态</li>
<li>提升了可伸缩性、可见性、可靠性、但重复数据降低了网络的性能</li>
</ul>
</li>
<li>缓存、无状态客户端服务器 Client-Cacha-Stateless Server C$SS<ul>
<li>提升性能</li>
</ul>
</li>
<li>分层、缓存、无状态客户端服务器 Layered-Client-Cacha-Stateless Server LC$SS</li>
</ul>
<h4 id="移动代码风格-Mobile-code-style"><a href="#移动代码风格-Mobile-code-style" class="headerlink" title="移动代码风格 Mobile code style"></a>移动代码风格 Mobile code style</h4><ul>
<li>虚拟机 Virtual Machine, VM<br>分离指令与实现</li>
<li>远程求值 Remote Evaluation REV<br>基于CS的VM,将代码发送至服务器运行</li>
<li>按需代码 Code on Demand COD<ul>
<li>服务器在响应中发回处理代码，在客户端执行</li>
<li>优秀的可扩展性和可移植性，提升用户可察觉性性能和网络效率</li>
</ul>
</li>
<li>分层、按需代码、缓存、无状态客户端服务器 LCODC$SS</li>
<li>移动代理 Mobile Agent MA<br>相当于 REV +COD</li>
</ul>
<h4 id="点对点风格-Peer-to-Peer-style"><a href="#点对点风格-Peer-to-Peer-style" class="headerlink" title="点对点风格 Peer-to-Peer style"></a>点对点风格 Peer-to-Peer style</h4><ul>
<li>Event-Based Integration EBI<ul>
<li>基于事件集成系统，如消息的订阅，消费。</li>
<li>优秀的可重用性、可扩展性、可进化性</li>
<li>缺乏可理解性</li>
<li>由于消息广播等因素造成的消息风暴,可伸缩性差</li>
</ul>
</li>
<li>Chiorn2 C2<br>相当于 EBI + LCS 控制了消息的方向</li>
<li>Distributed Objects DO<br>组件结对交互</li>
<li>Brokered Distributed Objects BDO<br>引入名字来解析组件来简化DO，例如CORBA</li>
</ul>
<hr>
<h2 id="HTTP的前世今生"><a href="#HTTP的前世今生" class="headerlink" title="HTTP的前世今生"></a>HTTP的前世今生</h2><h3 id="HTTP-是什么"><a href="#HTTP-是什么" class="headerlink" title="HTTP 是什么"></a>HTTP 是什么</h3><p><strong>超文本传输协议</strong></p>
<p>重点在于P(Protocol)，用于约定服务端与客户端 超文本(当前已有图片、音频超链接等)数据传递交互的规范。</p>
<h4 id="与HTTP相关的概念"><a href="#与HTTP相关的概念" class="headerlink" title="与HTTP相关的概念"></a>与HTTP相关的概念</h4><h5 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h5><p>内容分发器。应用了HTTP协议的缓存和代理技术，代替源站去相应客户端的请求。<br>简单来说，就是缓存了源网站的数据，客户端再次请求时，可以不用去源服务器去请求，降低响应时间。</p>
<h5 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h5><p>由W3C定义的应用服务开发规范，有client-server 主从架构，通过使用WSDL定义服务接口，使用HTTP传输xml或SOAP消息，也就是说，它是一个<strong>基于Web(HTTP)的服务架构技术</strong>。</p>
<h5 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h5><p>TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p>
<ul>
<li>TCP协议 属于<strong>传输层</strong> 传输控制协议。位于IP协议之上，基于IP协议提供 <font color="green">可靠的</font>、<font color="green">字节流</font>形式的通信。是HTTP协议实现的基础。<br>TCP是一个有状态的协议，需要先与对方建立连接，然后才能发送数据，并且保证数据不丢失不重复。TCP的数据时连续的字节流，有先后顺序。</li>
<li>IP 协议 属于<strong>网际层</strong> 主要目的是解决寻址和路由问题，以及如何在两点之间传递数据包。</li>
<li><p>TCP/IP协议总共有四层</p>
<ol>
<li>链接层  负责在以太网、WIFI这样的底层发送原始数据包，工作在网卡这个层次，使用MAC地址来标记网络上的设备，也叫MAC层。传输单位是帧。</li>
<li>网际层(网络互连层) IP协议就在这一层。把IP地址转换成MAC地址。传输单位是包。</li>
<li>传输层 保证数据在IP地址标记的两点之间“可靠的”传输，是TCP/IP协议工作的层次。传输单位是段。</li>
<li>应用层</li>
</ol>
</li>
</ul>
<h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>域名系统 是IP地址的等价替代，用域名解析实现IP地址的映射。<br>如 <a href="blog.wangguanwei.com">薄梦风轻棉</a></p>
<h5 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h5><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>只允许使用GET从服务端获取HTML文档，并在请求响应之后立即关闭连接。</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><ul>
<li>增加了HEAD、POST等方法；</li>
<li>增加了相应状态码，标记可能出现的错误原因；</li>
<li>引入协议版本号的概念；</li>
<li>引入了HTTP Header(头部)的概念，让HTTP处理请求和相应更加灵活；</li>
<li>传输的数据不再局限于文本。</li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><ul>
<li>增加了PUT、DELETE新方法；</li>
<li>增加缓存管理和控制；</li>
<li>明确连接管理，允许持久连接；</li>
<li>允许相应数据分块(chunked)，利于传输大文件；</li>
<li>强制要求Host头，让互联网主机托管称为可能。</li>
</ul>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p><strong>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及；</strong></p>
<ul>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃1.1中的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>要求加密通信，增加了安全性。</li>
</ul>
<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p><strong>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。</strong></p>
<hr>
<h2 id="HTTP1详解"><a href="#HTTP1详解" class="headerlink" title="HTTP1详解"></a>HTTP1详解</h2><h3 id="request-line-请求行"><a href="#request-line-请求行" class="headerlink" title="request-line 请求行"></a>request-line 请求行</h3><p>request-line = method + request-target + http-version CRLF</p>
<h4 id="method-方式"><a href="#method-方式" class="headerlink" title="method (方式)"></a>method (方式)</h4><p><strong>幂等： 多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”</strong></p>
<p>指明请求方式</p>
<ul>
<li>GET<br>主要的获取数据的方法，大量的性能优化都针对该方法，也是幂等方法(调用一次和调用多次获得的结果是完全一致的)</li>
<li>POST<br>主要用于向服务器提交数据(资源)。常用于form表单提交、新增资源等。POST有新建(credit)的含义。</li>
<li>HEAD<br>类似于GET方法，但服务器不会返回请求的实体数据，只会传回响应头，也就是元数据。幂等方法</li>
<li>PUT<br>替换或更新数据，更新资源时使用。带条件时是幂等方法（多次更新一个资源，资源还是第一次更新的状态。）PUT有修改(update)的含义。</li>
<li>DELETE<br>删除资源，因为该动作危险性大通常服务器不会执行真正的删除操作，而是对资源做一个删除的标记。当然更多的服务器直接不处理该方法。幂等方法（可以多次删除同一个资源，得到的结果都是“资源不存在”。）</li>
<li>CONNECT<br>建立tunnel隧道。要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。</li>
<li>OPTIONS<br>显示服务器对访问资源支持的方法，在响应头的ALLOW字段中返回。幂等方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl static.taohui.tech -X OPTIONS -I</span><br><span class="line">// Allow列举出支持的方式</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: openresty/1.15.8.1</span><br><span class="line">Date: Wed, 01 Apr 2020 15:27:15 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">DAV: 2</span><br><span class="line">Allow: GET,HEAD,PUT,DELETE,MKCOL,COPY,MOVE,PROPFIND,OPTIONS,LOCK,UNLOCK</span><br></pre></td></tr></table></figure>
<ul>
<li>TRACE<br>用于对HTTP链路或诊断，可以显示出请求-相应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。</li>
</ul>
<h4 id="request-target-Path"><a href="#request-target-Path" class="headerlink" title="request-target (Path)"></a>request-target (Path)</h4><p>request-target有四种类型。origin-form、absolute-form、authority-form、asterisk-form。</p>
<ul>
<li>origin-form<br>向语言服务器，及产生响应内容的服务器发送请求的方式</li>
<li>absolute-form<br>仅用于向正向代理发送请求时。后面需要跟完整的URI</li>
<li>authority-form<br>仅用于Connect方法，及需要建立VPN隧道时使用</li>
<li>asterisk-form<br>仅用于Option方法，可以在request-target中传 “*” 号。</li>
</ul>
<h4 id="http-version-版本号"><a href="#http-version-版本号" class="headerlink" title="http-version 版本号"></a>http-version 版本号</h4><ul>
<li>HTTP/0.9<br>只支持GET方法，已过时</li>
<li>HTTP/1.0<br>常适用于代理服务器中，如Nginx向上游发起连接时，默认还是使用的1.0 的协议</li>
<li>HTTP/1.1<br>对1.0做出的改进，支持缓存、超链接，通过Host对于域名的支持。</li>
<li>HTTP/2.0</li>
</ul>
<h4 id="用于文档管理的WEBDAV方法"><a href="#用于文档管理的WEBDAV方法" class="headerlink" title="用于文档管理的WEBDAV方法"></a>用于文档管理的WEBDAV方法</h4><blockquote>
<p>WebDAV是用于Web协作创作的Internet工程任务组（IETF）标准：超文本传输​​协议（HTTP）的一组扩展，便于远程用户之间的协作编辑和文件管理在互联网上互相访问。</p>
</blockquote>
<ul>
<li>PROPFIND 从web资源中检索以XML格式存储的属性，。它也被重载，以允许一个检索远程系统的集合结构(也叫目录层次结构)，如文件中切换目录</li>
<li>PROPPATCH 在单个原子性动作中更改和删除资源的多个属性。</li>
<li>MKCOL 创建集合或目录</li>
<li>COPY 将资源从一个URI复制到另一个URI</li>
<li>MOVE 将资源从一个URI移动到另一个URI</li>
<li>LOCK 锁定一个资源。WEBDAV支持共享锁和互斥锁</li>
<li>UNLOCK 解除资源的锁定</li>
</ul>
<h3 id="status-line-响应行"><a href="#status-line-响应行" class="headerlink" title="status-line 响应行"></a>status-line 响应行</h3><p>status-line = HTTP-version + status-code + reason-pharse CRLF</p>
<h4 id="status-code-响应码"><a href="#status-code-响应码" class="headerlink" title="status-code 响应码"></a>status-code 响应码</h4><h5 id="1xx-请求已经接收到，需要进一步处理才能完成，HTTP1-0不支持"><a href="#1xx-请求已经接收到，需要进一步处理才能完成，HTTP1-0不支持" class="headerlink" title="1xx : 请求已经接收到，需要进一步处理才能完成，HTTP1.0不支持"></a>1xx : 请求已经接收到，需要进一步处理才能完成，HTTP1.0不支持</h5><ul>
<li>100 Continue: 上传大文件前使用。(由客户端发起请求中携带 Expect: 100-continue 头部触发)</li>
<li>101 Switch Protocols : 协议升级使用。(由客户端发起请求中携带Upgrade: 头部触发，如升级websocket或http2.0</li>
<li>102 Processing : WEBDAV请求可能会包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示服务器已经接收到并正在处理请求，但无响应可用，这样可以防止客户端超时，并假设请求丢失。</li>
</ul>
<h5 id="2xx-成功处理请求"><a href="#2xx-成功处理请求" class="headerlink" title="2xx: 成功处理请求"></a>2xx: 成功处理请求</h5><ul>
<li>200 OK :  成功返回响应</li>
<li>201 Created : 由新资源在服务器端被成功创建</li>
<li>202 Accepted : 服务器接收并开始处理请求,但请求未处理完成。如异步、需要长时间处理的任务。</li>
<li>203 NON-Authoritative Information : 当代理服务器修改了 origin server 的原始响应包体时(例如更换了HTML中的元素值)，代理服务器可以通过修改200为203的方式告知客户端这一事实，方便客户端做出相应的处理。203也可被缓存。</li>
<li>204 No Content : 成功执行了请求且不携带请求包体,并暗示客户端无需更新当前页面视图。</li>
<li>205 Reset Content:成功执行了请求且不携带响应包体，同时指明客户端 需要更新当前页面视图。</li>
<li>206 Partial Content:使用 range 协议时返回部分响应内容时的响应码</li>
<li>207 Multi-Status:RFC4918 ，在 WEBDAV 协议中以 XML 返回多个资源的状态。</li>
<li>208 Already Reported:RFC5842 ，为避免相同集合下资源在207响应码 下重复上报，使用 208 可以使用父集合的响应码。</li>
</ul>
<h5 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx: 重定向"></a>3xx: 重定向</h5><p>使用 Location 指向的资源或者缓存中的资源。在 RFC2068 中规定客户端重定向次数不应超过 5 次，以防止死循环。</p>
<ul>
<li>300 Multiple Choices:资源有多种表述，通过 300 返回给客户端后由其 自行选择访问哪一种表述。由于缺乏明确的细节，300 很少使用。</li>
<li>301 Moved Permanently:资源永久性的重定向到另一个 URI 中。</li>
<li>302 Found:资源临时的重定向到另一个 URI 中。</li>
<li>303 See Other:重定向到其他资源，常用于 POST/PUT 等方法的响应中。</li>
<li>304 Not Modified:当客户端拥有可能过期的缓存时，会携带缓存的标识 etag、时间等信息询问服务器缓存是否仍可复用，而304是告诉客户端可以 复用缓存。</li>
<li>307 Temporary Redirect:类似302，但明确重定向后请求方法必须与原 请求方法相同，不得改变。</li>
<li>308 Permanent Redirect:类似301，但明确重定向后请求方法必须与原请 求方法相同，不得改变。</li>
</ul>
<h5 id="4xx-客户端出现错误"><a href="#4xx-客户端出现错误" class="headerlink" title="4xx: 客户端出现错误"></a>4xx: 客户端出现错误</h5><ul>
<li>400 Bad Request:服务器认为客户端出现了错误，但不能明确判断为以下哪种错误时使用此错误码。例如HTTP请求格式错误。</li>
<li>401 Unauthorized:用户认证信息缺失或者不正确，导致服务器无法处理请求。</li>
<li>407 Proxy Authentication Required:对需要经由代理的请求，认证信息未通过代理服务器的验证</li>
<li>403 Forbidden:服务器理解请求的含义，但没有权限执行此请求</li>
<li>404 Not Found:服务器没有找到对应的资源</li>
<li>410 Gone:服务器没有找到对应的资源，且明确的知道该位置永久性找不到该资源</li>
<li>405 Method Not Allowed:服务器不支持请求行中的 method 方法</li>
<li>406 Not Acceptable:对客户端指定的资源表述不存在(例如对语言或者编码有要求)，服务器返回表述列表供客户端选择。</li>
<li>408 Request Timeout:服务器接收请求超时</li>
<li>409 Conflict:资源冲突，例如上传文件时目标位置已经存在版本更新的资源</li>
<li>411 Length Required:如果请求含有包体且未携带 Content-Length 头部，且不属于 chunk类请求时，返回 411</li>
<li>412 Precondition Failed:复用缓存时传递的 If-Unmodified-Since 或 If- None-Match 头部不被满足</li>
<li>413 Payload Too Large/Request Entity Too Large:请求的包体超出服务器能处理的最大长度</li>
<li>414 URI Too Long:请求的 URI 超出服务器能接受的最大长度</li>
<li>415 Unsupported Media Type:上传的文件类型不被服务器支持</li>
<li>416 Range Not Satisfiable:无法提供 Range 请求中指定的那段包体</li>
<li>417 Expectation Failed:对于 Expect 请求头部期待的情况无法满足时的响应码</li>
<li>421 Misdirected Request:服务器认为这个请求不该发给它，因为它没有能力处理。</li>
<li>426 Upgrade Required:服务器拒绝基于当前 HTTP 协议提供服务，通过 Upgrade 头部告知客户端必须升级协议才能继续处理。</li>
<li>428 Precondition Required:用户请求中缺失了条件类头部，例如 If-Match</li>
<li>429 Too Many Requests:客户端发送请求的速率过快</li>
<li>431 Request Header Fields Too Large:请求的 HEADER 头部大小超过限制</li>
<li>451 Unavailable For Legal Reasons:RFC7725 ，由于法律原因资源不可访问</li>
</ul>
<h5 id="5xx-服务器端出现错误"><a href="#5xx-服务器端出现错误" class="headerlink" title="5xx:服务器端出现错误"></a>5xx:服务器端出现错误</h5><ul>
<li>500 Internal Server Error:服务器内部错误，且不属于以下错误类型</li>
<li>501 Not Implemented:服务器不支持实现请求所需要的功能</li>
<li>502 Bad Gateway:代理服务器无法获取到合法响应</li>
<li>503 Service Unavailable:服务器资源尚未准备好处理当前请求</li>
<li>504 Gateway Timeout:代理服务器无法及时的从上游获得响应</li>
<li>505 HTTP Version Not Supported:请求使用的 HTTP 协议版本不支持</li>
<li>507 Insufficient Storage:服务器没有足够的空间处理请求</li>
<li>508 Loop Detected:访问资源时检测到循环</li>
<li>511 Network Authentication Required:代理服务器发现客户端需要进 行身份验证才能获得网络访问权限</li>
</ul>
<h3 id="Host-头部"><a href="#Host-头部" class="headerlink" title="Host 头部"></a>Host 头部</h3><p>Host = uri-host [ “:” port ]</p>
<ul>
<li>HTTP/1.1 规范要求，不传递 Host 头部则返回 400 错误响应码</li>
<li>为防止陈旧的代理服务器，发向正向代理的请求 request-target 必须以 absolute-form 形式出现</li>
</ul>
<h3 id="Request-Headers-请求的上下文"><a href="#Request-Headers-请求的上下文" class="headerlink" title="Request Headers 请求的上下文"></a>Request Headers 请求的上下文</h3><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p>指明客户端的类型信息，服务器可以据此对资源的表述做抉择<br>User-Agent = product *( RWS ( product / comment ) )</p>
<ul>
<li>product = token [“/“ product-version]<br>包含两部分，一部分为token，一部分为描述token指向的软件的版本号<br>例: User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:66.0)<br>Gecko/20100101 Firefox/66.0</li>
</ul>
<h4 id="referer"><a href="#referer" class="headerlink" title="referer"></a>referer</h4><p>浏览器对来自某一页面的请求自动添加的头部<br>Referer = absolute-URI / partial-URI<br>例: Referer: <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent</a></p>
<p>Referer 不会被添加的场景:</p>
<ol>
<li>来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI</li>
<li>当前请求页面采用的是 http 协议，而来源页面采用的是 https 协议</li>
</ol>
<p>服务器端常用于统计分析、缓存优化、防盗链等功能</p>
<h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>主要用于网络爬虫，告诉服务器如何通过邮件联系到爬虫的负责人<br>From = mailbox<br>例如: From: <a href="mailto:webmaster@example.org" target="_blank" rel="noopener">webmaster@example.org</a></p>
<h3 id="Response-Headers-响应的上下文"><a href="#Response-Headers-响应的上下文" class="headerlink" title="Response Headers 响应的上下文"></a>Response Headers 响应的上下文</h3><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>Server = product *( RWS ( product / comment ) )<br>指明服务器上所用软件的信息，用于帮助客户端定位问题或者统计数据<br>product = token [“/“ product-version]</p>
<h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p>告诉客户端，服务器上该 URI 对应的资源允许哪些方法的执行<br>Allow = #method</p>
<h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><p>告诉客户端服务器上该资源是否允许 range 请求<br>Accept-Ranges = acceptable-ranges</p>
<h3 id="HTTP包体"><a href="#HTTP包体" class="headerlink" title="HTTP包体"></a>HTTP包体</h3><p>承载的消息内容</p>
<ul>
<li>请求或者响应都可以携带包体<br>HTTP-message = start-line <em>( header-field CRLF ) CRLF [ message-body ]<br>message-body = </em>OCTET:二进制字节流</li>
<li>以下消息不能含有包体<ol>
<li>HEAD 方法请求对应的响应</li>
<li>1xx、204、304 对应的响应</li>
<li>CONNECT 方法对应的 2xx 响应</li>
</ol>
</li>
</ul>
<h4 id="发送-HTTP-消息时已能够确定包体的全部长度"><a href="#发送-HTTP-消息时已能够确定包体的全部长度" class="headerlink" title="发送 HTTP 消息时已能够确定包体的全部长度"></a>发送 HTTP 消息时已能够确定包体的全部长度</h4><p>使用 Content-Length 头部明确指明包体长度<br>Content-Length = 1*DIGIT<br>用 10 进制(不是 16 进制)表示包体中的字节个数，且必须与实际传输的包体长度一致<br>优点:接收端处理更简单</p>
<h4 id="发送-HTTP-消息时不能确定包体的全部长度"><a href="#发送-HTTP-消息时不能确定包体的全部长度" class="headerlink" title="发送 HTTP 消息时不能确定包体的全部长度"></a>发送 HTTP 消息时不能确定包体的全部长度</h4><p>使用 Transfer-Encoding 头部指明使用 Chunk 传输方式，<br>含 Transfer-Encoding 头部后 Content-Length 头部应被忽略<br>优点:</p>
<ol>
<li>基于长连接持续推送动态内容</li>
<li>压缩体积较大的包体时，不必完全压缩完(计算出头部)再发送，可以边发送边压缩</li>
<li>传递必须在包体传输完才能计算出的 Trailer 头部</li>
</ol>
<h3 id="HTML-Form表单"><a href="#HTML-Form表单" class="headerlink" title="HTML Form表单"></a>HTML Form表单</h3><p>表单，HTML 中的元素，提供了交互控制元件用来向服务器通过 HTTP 协议提交信息。</p>
<h4 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h4><ul>
<li>action:提交时发起 HTTP 请求的 URI</li>
<li>method:提交时发起 HTTP 请求的 http 方法<ul>
<li>GET:通过 URI，将表单数据以 URI 参数的方式提交</li>
<li>POST:将表单数据放在请求包体中提交</li>
</ul>
</li>
<li>enctype:在 POST 方法下，对表单内容在请求包体中的编码方式<ul>
<li>application/x-www-form-urlencoded<br>数据被编码成以 ‘&amp;’ 分隔的键-值对, 同时以 ‘=’ 分隔键和值，字符以 URL 编码方式编码</li>
<li>multipart/form-data<br>boundary 分隔符<br>每部分表述皆有HTTP头部描述子包体，例如 Content-Type<br>last boundary 结尾</li>
</ul>
</li>
<li>Content-type 头部指明这是一个多表述包体<br>Content-type: multipart/form-data</li>
<li>Boundary 分隔符的格式</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>保存在客户端、由浏览器维护、表示应 用状态的 HTTP 头部。</p>
<ul>
<li>存放在内存或者磁盘中</li>
<li>服务器端生成 Cookie 在响应中通过 Set-Cookie 头部告知客户端(允许多 个 Set-Cookie 头部传递多个值)</li>
<li>客户端得到 Cookie 后，后续请求都会 自动将 Cookie 头部携带至请求中<br>Cookie 头部中可以存放多个 name/value 名值对<br>Set-Cookie 头部一次只能传递 1 个 name/value 名值对，响应中可以含多个头部</li>
</ul>
<h4 id="Cookie的使用限制"><a href="#Cookie的使用限制" class="headerlink" title="Cookie的使用限制"></a>Cookie的使用限制</h4><ul>
<li>每条 Cookie 的长度(包括 name、value 以及描述的属性等总长度)至于要达到 4KB • 每个域名下至少支持 50 个 Cookie</li>
<li>至少要支持 3000 个 Cookie</li>
<li>代理服务器传递 Cookie 时会有限制</li>
</ul>
<h4 id="Cookie在协议设计上的问题"><a href="#Cookie在协议设计上的问题" class="headerlink" title="Cookie在协议设计上的问题"></a>Cookie在协议设计上的问题</h4><ul>
<li>Cookie 会被附加在每个 HTTP 请求中，所以无形中增加了流量</li>
<li>由于在 HTTP 请求中的 Cookie 是明文传递的，所以安全性成问题(除<br>非用 HTTPS)</li>
<li>Cookie 的大小不应超过 4KB，故对于复杂的存储需求来说是不够用的</li>
</ul>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同一个浏览器发出的请求，未必都是用户自愿发出的请求。如果没有同源策略，只能保证用户请求来自于同一浏览器，不能确保是用户自愿发出的。</p>
<h4 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h4><p>详见文章 <a href="https://blog.wangguanwei.com/2017/07/23/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">解决跨域的几种方式</a>,本文不再一一赘述。</p>
<h3 id="Cache-Control-头部"><a href="#Cache-Control-头部" class="headerlink" title="Cache-Control 头部"></a>Cache-Control 头部</h3><p>请求中的头部:max-age、max-stale、min-fresh、no-cache、no- store、no-transform、only-if-cached<br>响应中的头部: max-age、s-maxage 、 must-revalidate 、proxy- revalidate 、no-cache、no-store、no-transform、public、private</p>
<h4 id="Cache-Control-头部在请求中的值"><a href="#Cache-Control-头部在请求中的值" class="headerlink" title="Cache-Control 头部在请求中的值"></a>Cache-Control 头部在请求中的值</h4><ul>
<li>max-age:告诉服务器，客户端不会接受 Age 超出 max-age 秒的缓存</li>
<li>max-stale:告诉服务器，即使缓存不再新鲜，但陈旧秒数没有超出 max-stale 时，客户端仍<br>打算使用。若 max-stale 后没有值，则表示无论过期多久客户端都可使用</li>
<li>min-fresh:告诉服务器，Age 至少经过 min-fresh 秒后缓存才可使用</li>
<li>no-cache:告诉服务器，不能直接使用已有缓存作为响应返回，除非带着缓存条件到上游服 务端得到 304 验证返回码才可使用现有缓存</li>
<li>no-store:告诉各代理服务器不要对该请求的响应缓存(实际有不少不遵守该规定的代理服务 器)</li>
<li>no-transform:告诉代理服务器不要修改消息包体的内容</li>
<li>only-if-cached:告诉服务器仅能返回缓存的响应，否则若没有缓存则返回 504 错误码</li>
</ul>
<h4 id="Cache-Control-头部在响应中的值"><a href="#Cache-Control-头部在响应中的值" class="headerlink" title="Cache-Control 头部在响应中的值"></a>Cache-Control 头部在响应中的值</h4><ul>
<li>must-revalidate:告诉客户端一旦缓存过期，必须向服务器验证后才可使用</li>
<li>proxy-revalidate:与 must-revalidate 类似，但它仅对代理服务器的共享缓存<br>有效</li>
<li>no-cache:告诉客户端不能直接使用缓存的响应，使用前必须在源服务器验证 得到 304 返回码。如果 no-cache 后指定头部，则若客户端的后续请求及响应 中不含有这些头则可直接使用缓存</li>
<li>max-age:告诉客户端缓存 Age 超出 max-age 秒后则缓存过期</li>
<li>s-maxage:与 max-age 相似，但仅针对共享缓存，且优先级高于 max-age 和 Expires</li>
<li>public:表示无论私有缓存或者共享缓存，皆可将该响应缓存</li>
<li>private:表示该响应不能被代理服务器作为共享缓存使用。若 private 后指定头<br>部，则在告诉代理服务器不能缓存指定的头部，但可缓存其他部分</li>
<li>no-store:告诉所有下游节点不能对响应进行缓存</li>
<li>no-transform:告诉代理服务器不能修改消息包体的内容</li>
</ul>
<h2 id="TSL-协议"><a href="#TSL-协议" class="headerlink" title="TSL 协议"></a>TSL 协议</h2><h3 id="AES对称加密"><a href="#AES对称加密" class="headerlink" title="AES对称加密"></a>AES对称加密</h3><h4 id="对称加密实现原理"><a href="#对称加密实现原理" class="headerlink" title="对称加密实现原理"></a>对称加密实现原理</h4><p>对称机密之所以能实现同一把密钥既能加密又能解密，主要是基于XOR异或运算。</p>
<table>
<thead>
<tr>
<th>input</th>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B</td>
<td>A XOR B</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>inputinputoutputABA XOR B000011101110inputinputoutputABA XOR B000011101110inputinputoutputABA XOR B000011101110inputinputoutputABA XOR B000011101110#### padding填充</p>
<p>Block cipher 分组加密: 将明文分成多个等长的 Block 模块，对每个模块分别加解密。<br>目的: 当最后一个明文 Block 模块长度不足时，需要填充。<br>填充方法:</p>
<ul>
<li>位填充: 以 bit 位为单位来填充</li>
<li>字节填充:以字节为单位为填充。有四种方法<ol>
<li>补零: 字节位数不够，全部用零来补。</li>
<li>ANSIX9.23: 末尾补零，最后一个字节表明补了几个零。</li>
<li>ISO10126: 末尾填充完全随机字符，填充的最后一个字节表明一共填充了几个字节</li>
<li>PKCS7(RFC5652): 在需要填充的地方，全部填充数字，数字为需要几个字节。如需要填充4个字节，那么末尾补充 04040404 |.</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>大千世界</category>
      </categories>
      <tags>
        <tag>花满楼</tag>
      </tags>
  </entry>
</search>
